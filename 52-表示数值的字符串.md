考点    

字符串

热点指数    26401
通过率    26.45%
题目    

表示数值的字符串


具体题目    请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串"+100","5e2","-123","3.1416"和"-1E-16"都表示数值。      但是"12e","1a3.14","1.2.3","+-5"和"12e+4.3"都不是。
讨论    210
C/C++
networkcpx
class Solution {
public:
    bool isNumeric(char* str) {
        // 标记符号、小数点、e是否出现过
        bool sign = false, decimal = false, hasE = false;
        for (int i = 0; i < strlen(str); i++) {
            if (str[i] == 'e' || str[i] == 'E') {
                if (i == strlen(str)-1) return false; // e后面一定要接数字
                if (hasE) return false;  // 不能同时存在两个e
                hasE = true;
            } else if (str[i] == '+' || str[i] == '-') {
            	  // 第二次出现+-符号，则必须紧接在e之后
                if (sign && str[i-1] != 'e' && str[i-1] != 'E') return false;
                // 第一次出现+-符号，且不是在字符串开头，则也必须紧接在e之后
                if (!sign && i > 0 && str[i-1] != 'e' && str[i-1] != 'E') return false;
                sign = true;
            } else if (str[i] == '.') {
            	// e后面不能接小数点，小数点不能出现两次
                if (hasE || decimal) return false;
                decimal = true;
            } else if (str[i] < '0' || str[i] > '9') // 不合法字符
                return false;
        }
        return true;
    }
};
64
Java
傻傻傻傻
//正则表达式解法
public class Solution {
    public boolean isNumeric(char[] str) {
        String string = String.valueOf(str);
        return string.matches("[\\+\\-]?\\d*(\\.\\d+)?([eE][\\+\\-]?\\d+)?");
    }
}
/*
以下对正则进行解释:
[\\+\\-]?            -> 正或负符号出现与否
\\d*                 -> 整数部分是否出现，如-.34 或 +3.34均符合
(\\.\\d+)?           -> 如果出现小数点，那么小数点后面必须有数字；
                        否则一起不出现
([eE][\\+\\-]?\\d+)? -> 如果存在指数部分，那么e或E肯定出现，+或-可以不出现，
                        紧接着必须跟着整数；或者整个部分都不出现
*/
//参见剑指offer
public class Solution {
    private int index = 0;
 
    public boolean isNumeric(char[] str) {
        if (str.length < 1)
            return false;
        
        boolean flag = scanInteger(str);
        
        if (index < str.length && str[index] == '.') {
            index++;
            flag = scanUnsignedInteger(str) || flag;
        }
        
        if (index < str.length && (str[index] == 'E' || str[index] == 'e')) {
            index++;
            flag = flag && scanInteger(str);
        }
        
        return flag && index == str.length;
        
    }
    
    private boolean scanInteger(char[] str) {
        if (index < str.length && (str[index] == '+' || str[index] == '-') )
            index++;
        return scanUnsignedInteger(str);
        
    }
    
    private boolean scanUnsignedInteger(char[] str) {
        int start = index;
        while (index < str.length && str[index] >= '0' && str[index] <= '9')
            index++;
        return start < index; //是否存在整数
    }
}
 
84
SHINE.
  编译原理中自动机可以实现，识别如下图所示： 
class Solution {
public:
    bool isNumeric(char* string)
    {
        int i = 0;
        if(string[i]=='+' || string[i]=='-' || IsNum(string[i])){
            while(string[++i]!='\0' && IsNum(string[i]));
            if(string[i]=='.'){
                if(IsNum(string[++i])){
                    while(string[++i]!='\0' && IsNum(string[i]));
                    if(string[i]=='e'||string[i]=='E'){
                        i++;
                        if(string[i]=='+' || string[i]=='-' || IsNum(string[i])){
                            while(string[++i]!='\0' && IsNum(string[i]));
                            if(string[i]=='\0') return true;
                            else return false;
                        }else return false;
                    }else if(string[i]=='\0') return true;
                    else return false;
                }else if(string[++i]=='\0') return true;
                else return false;
            }else if(string[i]=='e'||string[i]=='E'){
                i++;
                if(string[i]=='+' || string[i]=='-' || IsNum(string[i])){
                    while(string[++i]!='\0' && IsNum(string[i]));
                    if(string[i]=='\0') return true;
                    else return false;
                }else return false;
            }else if(string[i]=='\0') return true;
            else return false;            
        }else return false;
    }
	
    bool IsNum(char ch)
    {
        if(ch<'0'||ch>'9') return false;
        else return true;
    }
};
132
冒菜。
public class Solution {
    public boolean isNumeric(char[] str) {
        String string = String.valueOf(str);
        return string.matches("[\\+-]?[0-9]*(\\.[0-9]*)?([eE][\\+-]?[0-9]+)?");
    }
}
28
Bine
class Solution {
public:
    char arr[10] = "+-n.ne+-n";
    int turn[10][9] = {
       //+  -  n  .  n  e  +  -  n
        {1, 1, 1, 0, 0, 0, 0, 0, 0},    // # start
        {0, 0, 1, 1, 0, 0, 0, 0, 0},    // +
        {0, 0, 1, 1, 0, 0, 0, 0, 0},    // -
        {0, 0, 1, 1, 0, 1, 0, 0, 0},    // n
        {0, 0, 0, 0, 1, 0, 0, 0, 0},    // .
        {0, 0, 0, 0, 1, 1, 0, 0, 0},    // n
        {0, 0, 0, 0, 0, 0, 1, 1, 1},    // e
        {0, 0, 0, 0, 0, 0, 0, 0, 1},    // +
        {0, 0, 0, 0, 0, 0, 0, 0, 1},    // -
        {0, 0, 0, 0, 0, 0, 0, 0, 1}     // n
    };
    bool isNumeric(char* string) {
        int cur = 0;
        for(int j, i = 0; string[i]; i++) {
            for(j = 0; j < 9; j++) {
                if(turn[cur][j]) {
                    if(('0' <= string[i] && string[i] <= '9' && arr[j] == 'n') ||
                        (string[i] == 'E' && arr[j] == 'e')||
                        string[i] == arr[j]) {
                        cur = j + 1;
                        break;
                    }
                }
            }
            if(j == 9) return false;
        }
        if(cur == 3 || cur == 4 || cur == 5 || cur == 9)
           return true;
        return false;
    }
};
58
Blankeer
public class Solution {
    public boolean isNumeric(char[] str) {
        try {
			double re = Double.parseDouble(new String(str));
		} catch (NumberFormatException e) {
			return false;
		}
		return true;
    }
}
10
Python
zxlly要offer
# -*- coding:utf-8 -*-
'''
请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。
例如，字符串"+100","5e2","-123","3.1416"和"-1E-16"都表示数值。 但是"12e","1a3.14","1.2.3","+-5"和"12e+4.3"都不是。
'''
class Solution:
    # s字符串
    def isNumeric(self, s):
        # write code here
        if len(s) <= 0:
            return False
        # 分别标记是否出现过正负号、小数点、e，因为这几个需要特殊考虑
        has_sign = False
        has_point = False
        has_e = False
        for i in range(len(s)):
            # 对于e的情况
            if s[i] == 'E' or s[i] == 'e':
                # 不同出现两个e
                if has_e:
                    return False
                # e不能出现在最后面，因为e后面要接数字
                else:
                    has_e = True
                    if i == len(s) -1:
                        return False   
            # 对于符号位的情况
            elif s[i] == '+' or s[i] == '-':
                # 如果前面已经出现过了符号位，那么这个符号位，必须是跟在e后面的
                if has_sign:
                    if s[i-1] != 'e' and s[i-1] != 'E':
                        return False
                # 如果这是第一次出现符号位，而且出现的位置不是字符串第一个位置，那么就只能出现在e后面
                else:
                    has_sign = True
                    if i > 0 and s[i-1] != 'e' and s[i-1] != 'E':
                        return False
            # 对于小数点的情况
            elif s[i] == '.':
                # 小数点不能出现两次；而且如果已经出现过e了，那么就不能再出现小数点，因为e后面只能是整数
                if has_point or has_e:
                    return False
                # 如果是第一次出现小数点，如果前面出现过e，那么还是不能出现小数点
                else:
                    has_point = True
                    if i > 0 and (s[i-1] == 'e' or s[i-1] == 'E'):
                        return False
            else:
                # 其他字符必须是‘0’到‘9’之间的
                if s[i] < '0' or s[i] > '9':
                    return False
        return True
 
11
赢在拼搏中
class Solution {
public:
    bool isNumeric(char* string)
    {
        int len=strlen(string);
        int i=0,dot=0,nume=0,num=0;
        if(len==0)
            return true;
        if(string[0]=='+'||string[0]=='-')
            i++;
       while(i<len){
            if(string[i]>='0'&&string[i]<='9'){
                i++;
                num=1;
            }
            else if(string[i]=='.'){
                if(nume>0)
                    return false;
                dot++;
                i++;
            }
            else if(string[i]=='e' ||string[i]=='E'){
                if(nume>0 || num==0)
                    return false;
                nume++;
                i++;
                if(string[i]=='-'||string[i]=='+')
                    i++;
                if(string[i]=='\0')
                    return false;
            }
            else
                return false;
                  
        }
        if(dot>1 ||nume>1)
            return false;
        return true;
    }
};
7
C/C++
吴鹏_2016
class Solution {
    void check(char *&s, bool &res) {
        while (isdigit(*s)) {
            ++s;
            res = true;
        }
    }
public:
    bool isNumeric(char* s) {
        if (!s) return false;
        if (*s == '-' || *s == '+') ++s;
        bool res = false;
        check(s, res);
        if (*s == '.') check(++s, res);
        if (res & (*s == 'e' || *s == 'E')) {
            ++s;
            res = false;
            if (*s == '-' || *s == '+') ++s;
            check(s, res);
        }
        return res && *s == '\0';
    }
};
10
啥
  几个关键点： 
  1.基本边界。     string == NULL || *string == '\0' 
  2.检测是否有符号位 
  3.检测除符号位外的第一个有效位，有效位只能是数字或者小数点. 
  4.检测是否有E或者e，且不能重复出现 
  5.小数点不能重复出现 
  6.数字的合法性，不能是其他字母如‘a’等 
  代码如下： 
  用了重载函数，设置参数hasPoint、hasEe来判断E、e、小数点是否重复出现 
bool isNumeric(char* string)
    {
        return isNumeric(string, false, false);
    }
    bool isNumeric(char* string, bool hasPoint, bool hasEe)
    {
        // 基本边界
        if(string == NULL || *string == '\0') {
            return false;
        }
        // 检测是否有符号位
        bool isMinus = false;
        if(*string == '-') {
            isMinus = true;
            string++;
        } else if(*string == '+') {
            isMinus = false;
            string++;
        }
        // 检测第一个数字或者小数点是否存在
        if((*string >= '0' && *string <= '9') || *string == '.') {
            string++;
        } else {
            return false;
        }
        while(*string != '\0') {
            // 是否为E或者e
            if(*string == 'E' || *string == 'e') {
                if(hasEe == true) {
                    return false;
                } else {
                    if(isNumeric(string+1, true, true)) {
                        return true;
                    } else {
                        return false;
                    }
                }
            }
            // 是否为小数点.
            if(*string == '.') {
                if(hasPoint == true) {
                    return false;
                } else {
                    hasPoint = true;
                    string++;
                }
            } else if(*string >= '0' && *string <= '9') {
                // 是否为合法数字
                string++;
            } else {
                return false;
            }
        }
        // 如果不是所有不合法，则返回true
        return true;
    }
6
Java
我去个地方啊
题目描述 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串"+100","5e2","-123","3.1416"和"-1E-16"都表示数值。 但是"12e","1a3.14","1.2.3","+-5"和"12e+4.3"都不是。 解题思路  12e说明e的后面必须有数字，不能有两个e +-5说明符号位要么出现一次在首位，要么出现一次在e的后一位，其他地方都不能有 12e4.3说明e的后面不能有小数，1.2.3说明不能有两个小数点 1a3.14说明不能有其他的非法字符，比如这里的a  我的答案 public class Solution {
    public boolean isNumeric(char[] str) {
        //signal表示符号，decimal表示小树点，hasE表示含有符号e
        boolean signal = false,decimal = false,hasE = false;
        for(int i=0;i<str.length;i++){
            if(str[i] == 'E' || str[i] == 'e'){
                //e后面必须有数字，所以是最后一位肯定不通过
                if(i==str.length-1){
                    return false;
                }
                //不能有两个e
                if(hasE){
                    return false;
                }
                hasE = true;
            }else if(str[i] == '+' || str[i] == '-'){
                //不是第一次出现，那么后面能出现符合的地方只有紧贴着e的后面一位，不是则不通过
                if(signal && str[i-1] != 'E' && str[i-1] != 'e'){
                    return false;
                }
                //第一次出现，如果不是出现在第一位，那么还是判断一下是不是出现在e的后面一位
                if(!signal && i>0 && str[i-1] != 'E' && str[i-1] != 'e'){
                    return false;
                }
                signal = true;
            }else if(str[i] == '.'){
                //如果存在e并且e后面为小数则不通过
                if(hasE){
                    for(;i>=0;i--){
                        if(str[i] == 'e' || str[i] == 'E'){
                            return false;
                        }
                    }
                }
                //不能有两个小数点
                if(decimal){
                    return false;
                }
                decimal = true;
            }else if(str[i] < '0' || str[i] > '9'){
                //不是e也不是+-符号也不是小数点，那么只能是数字，不是数字就是非法的字符
                return false;
            }
        }
        return true;
    }
}
6
Allen()
思路，构建一个状态机
class Solution {
private:
    enum STATUS{ END = 0, START, SIGNED1, INTEGER, POINT, FLOAT, EXPONENT, SIGNED2, SCIENCE };
    STATUS dfa[256][9] = { END };
public:   
    Solution(){
		for (int i = 0; i < 256; ++i)
		{
			for (int j = 0; j < 9; ++j)
			{
				dfa[i][j] = END;
			}
		}
        initDFA();
	}
    bool isNumeric(char* string)
    {
        STATUS current = START;
        while (*string && current != END)
        {
            current = DFA(current, *string);
            ++string;
        }
        switch (current)
        {
        case INTEGER:
        case FLOAT:
        case SCIENCE:
            return true;
        }
        return false;
    }
private:
    void initDFA(){
        char d = '0';
        // 1. START 变迁
        dfa['+'][START] = SIGNED1;
        dfa['-'][START] = SIGNED1;
        dfa['.'][START] = POINT;
        for (d = '0'; d <= '9'; ++d)
        {
            dfa[d][START] = INTEGER;
        }
        // 2. SIGNED1 变迁
        for (d = '0'; d <= '9'; ++d)
        {
            dfa[d][SIGNED1] = INTEGER;
        }
        dfa['.'][SIGNED1] = POINT;
        // 3. INTEGER 变迁
        for (d = '0'; d <= '9'; ++d)
        {
            dfa[d][INTEGER] = INTEGER;
        }
        dfa['.'][INTEGER] = FLOAT;
        dfa['E'][INTEGER] = EXPONENT;
        dfa['e'][INTEGER] = EXPONENT;
        // 4. POINT 变迁
        for (d = '0'; d <= '9'; ++d)
        {
            dfa[d][POINT] = FLOAT;
        }
        // 5. FLOAT 变迁
        for (d = '0'; d <= '9'; ++d)
        {
            dfa[d][FLOAT] = FLOAT;
        }
        dfa['E'][FLOAT] = EXPONENT;
        dfa['e'][FLOAT] = EXPONENT;
        // 6. EXPONENT 变迁
        for (d = '0'; d <= '9'; ++d)
        {
            dfa[d][EXPONENT] = SCIENCE;
        }
        dfa['+'][EXPONENT] = SIGNED2;
        dfa['-'][EXPONENT] = SIGNED2;
        // 7. SIGNED2 变迁
        for (d = '0'; d <= '9'; ++d)
        {
            dfa[d][SIGNED2] = SCIENCE;
        }
        // 8. SCIENCE 变迁
        for (d = '0'; d <= '9'; ++d)
        {
            dfa[d][SCIENCE] = SCIENCE;
        }
        // 其余情况均变迁到  END
    }
    STATUS DFA(STATUS current, char input)
    {
        STATUS ret = START;
        return dfa[input][current];
    }
    
};
17
Python
华科平凡
python solution: # -*- coding:utf-8 -*-
class Solution:
    # s字符串
    def isNumeric(self, s):
        # write code here
        try:
            ss=float(s)
            return True
        except:
            return False
10
oo-┈&rarr;駭孓気℡~
  没看到有人写python，我写个python的吧，索性就一行 
# -*- coding:utf-8 -*-
import re
class Solution:
    def isNumeric(self, s):
    	return re.match(r"^[\+\-]?[0-9]*(\.[0-9]*)?([eE][\+\-]?[0-9]+)?$",s)
4
搬一块叫CV的砖
/*
思路：1、首先判断正负号，如果是否为空或\0，返回false。
2、扫描所有数字，如果还没到结尾。若此时是.则证明是浮点型数，继续扫描数字，如果碰到e或者E还需要判断后续是否合法
3、若扫描的不是.那么若是e或者E则进行后续判断，如果也不是e或者E就直接返回错误
4、正确的条件是numeric为true且string扫描到了末尾
*/
class Solution {
public:
    void scanDigits(char**string)
{
	while (**string != '\0'&&**string >= '0'&&**string<='9')
	{
		++(*string);
	}
}
bool isExponential(char **string)
{
	if (**string != 'e'&&**string != 'E')
		return false;
	++(*string);
	if ((**string == '+') ||( **string == '-'))
	    ++(*string);
	if (**string == '\0')
		return false;
	scanDigits(string);
	return (**string == '\0') ? true : false;
}
bool isNumeric(char* string)
{
	if (string == NULL)
		return false;
	if (*string == '+' || *string == '-')
		++string;
	if (*string == '\0')
		return false;
	bool numeric = true;
	//扫描到最后一个不是数字的位置,string指针指向该位置
	scanDigits(&string);
	if (*string != '\0')
	{
		if (*string == '.')
		{
			++string;
			scanDigits(&string);
			if (*string == 'e' || *string == 'E')
				numeric = isExponential(&string);
		}
		else if (*string == 'e' || *string == 'E')
			numeric = isExponential(&string);
		else
			numeric = false;
	}
	//cout <<numeric<<"         "<< *string << endl;
	return numeric && *string == '\0';
}
};
6
C/C++
7厘海岸
先说一下思路吧：
1.整数开始部分遇到+、-号跳过
2.小数点只能出现一次
3.小数点之前不能存在e
4.e之前必须有整数
5.e只能出现一次
6.e之后可存在+、-号，但+-之后必须有整数
class Solution {
public:
    bool isNumeric(char* str)
    {
        if (str == NULL)
		return false;
	if (*str == '+' || *str == '-')
		++str;
	if (*str == '\0')
		return false;
	int x = 0;    //标记整数部分
	int digit = 0; //标记小数点
	int e = 0;     //标记e的状态
	while (*str != '\0')
	{
		//标记整数部分的状态
		if (*str >= '0' && *str <= '9')
		{
			++str;
			x = 1;
		}
		//小数点
		else if (*str == '.')
		{
			//前面已经出现过小数点或小数点之前存在e，则返回false
			if (digit > 0 || e > 0)
				return false;
			++str;
			digit = 1;    //标记小数点已经出现过
		}
		//e
		else if (*str == 'e' || *str == 'E')
		{
			//e之前没有整数或e已经出现过，则返回false
			if (x == 0 || e > 0)
				return false;
			++str;
			e = 1;     //标记e表示已经出现过
			//e之后可以出现+-号再加整数
			if (*str == '+' || *str == '-')
				++str;
			if (*str == '\0')
				return false;
		}
		else
			return false;
	}
	return true;
    }
}; 
3
虵乡遇故知
public class Solution {
    public boolean isNumeric(char[] str) {
        if (str == null || str.length == 0) {
            return false;
        }
        // '.'的数量
        int pointCount = 0;
        // 是否遇到过'E'或者'e'
        boolean isMeetE = false;
        for (int i = 0; i < str.length; i++) {
            if(str[i] == 'e' || str[i] == 'E') {
                // 如果已经遇过e现在又遇到了e，或者e出现在最后位置，返回false
                if (isMeetE == true || i == str.length - 1) {
                    return false;
                } else {
                    isMeetE = true;
                    continue;
                }
            }
            
            // 看字符是否在0~9之间或者是否为e
            if((str[i] > '9' || str[i] < '0') && (str[i] != 'e' || str[i] != 'E')) {
                if (str[i] == '+' || str[i] == '-' || str[i] == '.') {
                    if (str[i] == '.' && pointCount > 1) {
                        return false;
                    } else if((str[i] == '+' || str[i] == '-') && i != 0 && !isMeetE) {
                        return false;
                    }
                } else {
                    return false;
                }
            }
            
            // 遇到E之前
            if(!isMeetE) {
                // 在E之前，下标0后遇到+=的
                if (i != 0 && (str[i] == '+' || str[i] == '-')) {
                    return false;
                }
                // E之前.数量>1的
                if (str[i] == '.' && ++pointCount > 1) {
                    return false;
                }
            } else {
                // E之后存在'.'的返回false
                if(str[i] == '.') {
                    return false;
                } 
            }
        }
        return true;
    }
}
 
3
Java
Mr.『黑』℡
/*
请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串"+100","5e2","-123","3.1416"和"-1E-16"都表示数值。 但是"12e","1a3.14","1.2.3","+-5"和"12e+4.3"都不是。
1.整数开始部分遇到+、-号跳过
2.小数点只能出现一次
3.小数点之前不能存在e
4.e之前必须有整数
5.e只能出现一次
6.e之后可存在+、-号，但+-之后必须有整数
*/
public class Solution {
    public boolean isNumeric(char[] str) {
        if ( str == null ){
            return false ;
        }
        if ( str.length < 1 ){
            return false ;
        }
        
        boolean sign = false ;
        boolean dot = false ;
        boolean hasE = false ;
        int index = 0 ;
        
        if ( !Character.isDigit(str [index]) ){
            if ( str [0] == '+' || str [0] == '-' ){
                sign = true ;
                index ++ ;
            }else if ( str [0] == '.' ){
                dot = true ;
                index ++;
            }else{
                return false ;
            }
        }
        
        if ( index == str.length - 1 ){
            return false ;
        }
        
        for ( int i = index ; i < str.length ; ++ i ){
            if ( Character.isDigit (str[i]) ){
                continue ;
            }
            else if ( str[i] == 'E' || str[i] == 'e' ){
                if ( i == str.length - 1 ){
                    return false ;
                }else if ( str [i-1] == '.' && !dot ){
                    dot = true ;
                    hasE = true ;
                }else if ( Character.isDigit(str[i-1]) ){
                    hasE = true ;
                }else{
                    return false ;
                }
            }
            else if ( i != str.length - 1 && str [i] == '+' || str [i] == '-' ){
                if ( (i + 1 < str.length) && (str[i-1] == 'E' || str [i-1] == 'e') && Character.isDigit(str[i+1]) ){
                    sign = true ;
                }else if ( sign ){
                    return false ;
                }else {
                    return false ;
                }
            }
            else if ( str [i] == '.' ){
                if ( dot || hasE ){
                    return false ;
                }else {
                    dot = true ;
                }
            }else{
                return false;
            }
        }
        return true ;
    }
}
 
3
Duqcuid
public class Solution {
    public boolean isNumeric(char[] str) {
        // 过滤特殊情况
        if(str == null || str.length == 0)
            return false;
        
        // 这里注意几个细节
        // 1、特殊字符可以是+-.eE，其中+-.可以出现在开头
        // 2、.在数字中只能出现一次
        // 3、+-可以在eE后面再出现一次
        // 4、e只能在数字或.的后面出现
        // 5、e不能出现在末尾
        // 6、不能只出现+-或者.
        // 7、不能出现上述的几个特殊字符意外的字符
        int start = 0;
        boolean dot = false, sign = false, hasE = false;
        if(!Character.isDigit(str[0])){
            if(str[0] == '+' || str[0] =='-'){
                sign = true;
                start++;
            }else if(str[0] == '.'){
                dot = true;
                start++;
            }else
                return false;
        }
        
        if(start == str.length - 1)
            return false;
        
        for(int i = start; i < str.length; i++){
            if(Character.isDigit(str[i]))
                continue;
            else if(str[i] == '+' || str[i] == '-'){
                if(sign)
                    return false;
                else if(str[i - 1] == 'E' || str[i - 1] == 'e')
                    sign = true;
                else return false;
            }else if(str[i] == '.'){
                if(dot)
                    return false;
                dot = true;
            }else if(str[i] == 'e' || str[i] == 'E'){
                if(hasE || i == str.length - 1)
                    return false;
                else if(str[i - 1] == '.' || Character.isDigit(str[i - 1])){
                    hasE = true;
                    sign = false;
                    dot = true;
                }else return false;
            }else
                return false;
        }
        return true;
    }
} 
3
~一念执着~
class Solution {
public:
    bool isNumeric(char* string) {
        if (string == NULL)
            return false;
        if (*string == '+' || *string == '-')
            ++string;
        scanNum(&string);
        if (*string == '\0')
            return true;
        //判断小数
        if (*string == '.') {
            ++string;
            if (*string == '\0')//小数点后面没有数字
                return false;
            scanNum(&string);
            if (*string == '\0')//小数点后面只有数字
                return true;
            else if (*string == 'e' || *string == 'E')//小数点后面有指数
                return isExp(&(++string));
        }
        //判断指数
        else if (*string == 'e' || *string == 'E') {
            return isExp(&(++string));
        }
        return false;
    }
    //扫描数字
    void scanNum(char** str) {
        while (**str!='\0'&&**str >= '0'&&**str <= '9')
            ++(*str);
    }
    //判断是不是指数
    bool isExp(char** str){
        if(**str=='\0')
            return false;
        if(**str=='+'||**str=='-'){
            ++(*str);
            if(**str=='\0')
                return false;
        }
        scanNum(str);
        if(**str=='\0')
            return true;
        else
            return false;
    }
};
