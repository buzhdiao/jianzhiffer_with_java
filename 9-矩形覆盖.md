#### 题目    	矩形覆盖

考点    递归和循环	热点指数    80347	通过率    34.42%

#### 具体题目

​    我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？


  假设：n块矩形有f(n)种覆盖方法。进行逆向分析，要完成最后的搭建有两种可能。       第一种情况等价于情形1中阴影部分的n-1块矩形有多少种覆盖方法，为f(n-1);    第二种情况等价于情形2中阴影部分的n-2块矩形有多少种覆盖方法，为f(n-2);    故f(n) = f(n-1) + f(n-2)，还是一个斐波那契数列。。。。    且f(1) = 1, f(2) = 2，代码如下 
  ```
  public class Solution {
    public int RectCover(int target) {
		if(target <= 0){
            return 0;
        }
        if(target == 1){
            return 1;
        }
        if(target == 2){
            return 2;
        }
        int first = 1;
        int second = 2;
        int result = 0;
        for(int i = 3; i <= target; i++){
            result = first + second;
            first = second;
            second = result;
        }
        return result;
    }
}
  ```

  这里必须要吐槽一下，target为0的时候怎么就返回1了？？？出题者你出来解释一下，我保证不打残你。。。 
/**
	 * 其实就是一个斐波那契数列，满足公式：d(n) = d(n-1) + d(n-2) 
	 * @param target
	 * @return
	 */
```
	public int RectCover(int target) {
		int tempNum = 1;
		int result = 2;
		
		if (target == 0) {
			return 1;
		}
		
		if (target == 1 || target == 2) {
			return target;
		}
		
		int count = 2;
		while (count < target) {
			result += tempNum;
			tempNum = result - tempNum;
			count ++;
		}
		return result;
	}
```

 
  思路：    f(1) = 1;    f(2) = 2;    当n>2时，画图可知，第一块小矩形可横放和竖放。横放后剩余的长度为n-2，竖放后剩余的长度为n-1。    所以：f(n) = f(n-1) + f(n-2);  (n > 2)  
```
 public class Solution {
    public int RectCover(int target) {
        if (target <= 2) {
            return target;
        }
        int one = 1;
        int two = 2;
        int result = 0;
        for (int i = 3; i <= target; i++) {
            result = one + two;
            one = two;
            two = result;
        }
        return result;
    }
}

```


 薛定谔的矩形：我们不用管矩形放在哪，只关注矩形本身。 很容易发现，当矩形横着放时，它下面必然还有一个横着放的矩形，那么就相当于一次放了两个矩形； 当矩形竖着放时，相当于一次放了一个矩形，那么结果就出来了，n个矩形可投放的方式只有一次放一块或者一次放两块， 所以得到f(n) = f(n-1) + f(n-2)，至于矩形放在哪，不放下去我们也不知道矩形在哪，但是那不重要。 我们只要知道当n小于等于2时的具体情况就可以。 


```
 public class Solution {
    public int RectCover(int target) {
        if(target <= 2){
            return target;
        }else{
            return RectCover(target-1)+RectCover(target-2);
        }
    }
} 

```