考点    

回溯法

热点指数    25170
通过率    21.84%
题目    

矩阵中的路径


具体题目    请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如      a b c e      s f c s      a d e e 这样的3 X 4 矩阵中包含一条字符串"bcced"的路径，但是矩阵中不包含"abcb"路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。
讨论    48
张佃鹏
分析：回溯算法  这是一个可以  
查看全部
174
lizo
/**
用一个状态数组保存之前访问过的字符，然后再分别按上，下，左，右递归
*/
public class Solution {
	public boolean hasPath(char[] matrix, int rows, int cols, char[] str) {
		int flag[] = new int[matrix.length];
		for (int i = 0; i < rows; i++) {
			for (int j = 0; j < cols; j++) {
				if (helper(matrix, rows, cols, i, j, str, 0, flag))
					return true;
			}
		}
		return false;
	}
	private boolean helper(char[] matrix, int rows, int cols, int i, int j, char[] str, int k, int[] flag) {
		int index = i * cols + j;
		if (i < 0 || i >= rows || j < 0 || j >= cols || matrix[index] != str[k] || flag[index] == 1)
			return false;
		if(k == str.length - 1) return true;
		flag[index] = 1;
		if (helper(matrix, rows, cols, i - 1, j, str, k + 1, flag)
				|| helper(matrix, rows, cols, i + 1, j, str, k + 1, flag)
				|| helper(matrix, rows, cols, i, j - 1, str, k + 1, flag)
				|| helper(matrix, rows, cols, i, j + 1, str, k + 1, flag)) {
			return true;
		}
		flag[index] = 0;
		return false;
	}
}
56
Java
我去个地方啊
  回溯    基本思想：    0.根据给定数组，初始化一个标志位数组，初始化为false，表示未走过，true表示已经走过，不能走第二次    1.根据行数和列数，遍历数组，先找到一个与str字符串的第一个元素相匹配的矩阵元素，进入judge    2.根据i和j先确定一维数组的位置，因为给定的matrix是一个一维数组    3.确定递归终止条件：越界，当前找到的矩阵值不等于数组对应位置的值，已经走过的，这三类情况，都直接false，说明这条路不通    4.若k，就是待判定的字符串str的索引已经判断到了最后一位，此时说明是匹配成功的    5.下面就是本题的精髓，递归不断地寻找周围四个格子是否符合条件，只要有一个格子符合条件，就继续再找这个符合条件的格子的四周是否存在符合条件的格子，直到k到达末尾或者不满足递归条件就停止。    6.走到这一步，说明本次是不成功的，我们要还原一下标志位数组index处的标志位，进入下一轮的判断。  public class Solution {
    public boolean hasPath(char[] matrix, int rows, int cols, char[] str)
    {
        //标志位，初始化为false
        boolean[] flag = new boolean[matrix.length];
        for(int i=0;i<rows;i++){
            for(int j=0;j<cols;j++){
                 //循环遍历二维数组，找到起点等于str第一个元素的值，再递归判断四周是否有符合条件的----回溯法
                 if(judge(matrix,i,j,rows,cols,flag,str,0)){
                     return true;
                 }
            }
        }
        return false;
    }
    
    //judge(初始矩阵，索引行坐标i，索引纵坐标j，矩阵行数，矩阵列数，待判断的字符串，字符串索引初始为0即先判断字符串的第一位)
    private boolean judge(char[] matrix,int i,int j,int rows,int cols,boolean[] flag,char[] str,int k){
        //先根据i和j计算匹配的第一个元素转为一维数组的位置
        int index = i*cols+j;
        //递归终止条件
        if(i<0 || j<0 || i>=rows || j>=cols || matrix[index] != str[k] || flag[index] == true)
            return false;
        //若k已经到达str末尾了，说明之前的都已经匹配成功了，直接返回true即可
        if(k == str.length-1)
            return true;
        //要走的第一个位置置为true，表示已经走过了
        flag[index] = true;
        
        //回溯，递归寻找，每次找到了就给k加一，找不到，还原
        if(judge(matrix,i-1,j,rows,cols,flag,str,k+1) ||
           judge(matrix,i+1,j,rows,cols,flag,str,k+1) ||
           judge(matrix,i,j-1,rows,cols,flag,str,k+1) ||
           judge(matrix,i,j+1,rows,cols,flag,str,k+1)  )
        {
            return true;
        }
        //走到这，说明这一条路不通，还原，再试其他的路径
        flag[index] = false;
        return false;
    }
}
 
18
Java
Nobody_Zheng
 /**
 @author zhengyanan
 @date 2017/3/14 @time 10:07
 version_2:
 核心思路：优化版回溯法，参考《剑指offer》
 1.将matrix字符串模拟映射为一个字符矩阵(但并不实际创建一个矩阵)
 2.取一个boolean[matrix.length]标记某个字符是否已经被访问过。
 3.如果没找到结果，需要将对应的boolean标记值置回false,返回上一层进行其他分路的查找。
 运行时间：37ms
 占用内存：528k
 */
    public boolean hasPath(char[] matrix, int rows, int cols, char[] str){
        boolean[] visited = new boolean[matrix.length];
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (searchFromHere(matrix,rows,cols,i,j,0,str,visited))
                    return true;
            }
        }
//        System.out.println(Arrays.toString(visited));
        return false;
    }
    public boolean searchFromHere(char[] matrix,int rows,int cols,int r,int c,int index,char[] str,boolean[] visited){
        if (r < 0 || r >= rows || c < 0 || c >= cols || matrix[r * cols + c] != str[index] || visited[r * cols + c])
            return false;
        if (index == str.length - 1)    return true;
        visited[r * cols + c] = true;
        if (searchFromHere(matrix,rows,cols,r - 1,c,index + 1,str,visited) ||
                searchFromHere(matrix,rows,cols,r,c -1,index + 1,str,visited) ||
                searchFromHere(matrix,rows,cols,r + 1,c,index + 1,str,visited) ||
                searchFromHere(matrix,rows,cols,r,c + 1,index + 1,str,visited))
            return true;
        visited[r * cols + c] = false;
        return false;
    }
 /**
 @author zhengyanan
 @time 22:10
 @description
 version_1:
 核心思路：回溯法
 1.先将matrix字符串映射为字符矩阵；
 2.从原字符串中找到第一个跟str[0]相等的字符，得到其对应的在矩阵中的位置[r,c]
 1）从[r,c]开始按 上、左、右、下的顺序搜索；
 2）每当搜索到一个节点，先判断path是否包括它，包括就说明已经经过此节点，不能
 再经过了；如果不包括，就将其加入path容器
 3）直到搜索到str[length - 1]节点，说明成功找到，标记result为true，标记
 isFinished为true,尽快结束所有的递归操作
 4）如果某节点起的 上、左、右、下 都搜索过但还没找到结果，说明经过此节点的路
 径都不满足题意，将其从path中删除，回溯到上一层继续找。
 （PS:确实是回溯法，不过代码有点长，实现的有点繁杂）
 运行时间：51ms
 占用内存：625k
 */
//    private char[][] data;
//    private int rows;
//    private int cols;
//    private LinkedList<Integer> path = new LinkedList<Integer>();
//    private boolean result = false;
//    private boolean isFinished = false;
//
//    public boolean hasPath(char[] matrix, int rows, int cols, char[] str){
//        this.rows = rows;
//        this.cols = cols;
//        data = new char[rows][cols];
//        for (int i = 0,k = 0; i < rows; i ++) {
//            for (int j = 0; j < cols; j ++) {
//                data[i][j] = matrix[k ++];
//            }
//        }
//
//        int r,c;
//        for (int i = 0; i < matrix.length; i++) {
//            if (matrix[i] == str[0] && !isFinished){
//                r = i / cols;
//                c = i % cols;
//                tryPath(r,c,str,0);
//            }
//        }
//
//        return result;
//    }
//
//    public void tryPath(int r,int c,char[] str,int index){
//        if (isFinished) return;
//        if (path.contains(r * cols + c))   return;
//
//        path.addLast(r * cols + c);
//
//        if (index == str.length - 1)    {
//            isFinished = true;
//            result = true;
//        }
//        else {
//            for (int i = 0; i < 4; i++) {
//                switch (i) {
//                    case 0:
//                        if (r - 1 >= 0 && data[r - 1][c] == str[index + 1]) {
//                            tryPath(r - 1, c, str, index + 1);
//                        }
//                        break;
//                    case 1:
//                        if (c - 1 >= 0 && data[r][c - 1] == str[index + 1]) {
//                            tryPath(r, c - 1, str, index + 1);
//                        }
//                        break;
//                    case 2:
//                        if (r + 1 < rows && data[r + 1][c] == str[index + 1]) {
//                            tryPath(r + 1, c, str, index + 1);
//                        }
//                        break;
//                    case 3:
//                        if (c + 1 < cols && data[r][c + 1] == str[index + 1]) {
//                            tryPath(r, c + 1, str, index + 1);
//                        }
//                        break;
//                }
//            }
//        }
//        path.removeLast();
//    }
15
Python
华科平凡
python solution: # -*- coding:utf-8 -*-
class Solution:
    def hasPath(self, board, row, col, word):
        self.col, self.row = col, row
        board = [list(board[col * i:col * i + col]) for i in range(row)]
        for i in range(row):
            for j in range(col):
                if board[i][j] == word[0]:
                    self.b = False
                    self.search(board, word[1:], [(i, j)], i, j)
                    if self.b:
                        return True
        return False
    def search(self, board, word, dict, i, j):
        if word == "":
            self.b = True
            return
        if j != 0 and (i, j - 1) not in dict and board[i][j - 1] == word[0]:
            self.search(board, word[1:], dict + [(i, j - 1)], i, j - 1)
        if i != 0 and (i - 1, j) not in dict and board[i - 1][j] == word[0]:
            self.search(board, word[1:], dict + [(i - 1, j)], i - 1, j)
        if j != self.col - 1 and (i, j + 1) not in dict and board[i][j + 1] == word[0]:
            self.search(board, word[1:], dict + [(i, j + 1)], i, j + 1)
        if i != self.row - 1 and (i + 1, j) not in dict and board[i + 1][j] == word[0]:
            self.search(board, word[1:], dict + [(i + 1, j)], i + 1, j)
15
zhuma
//所谓的回溯无非就是对使用过的字符进行标记后和处理后的去标记
class Solution {
    bool hasPathRecu(char* matrix, int rows, int cols, int row, int col, char *str, int length, vector<bool> used)
    {
        if(length==strlen(str))
            return true;
        if(row<0||row>=rows||col<0||col>=cols)
            return false;
        int index = col + row*cols;
        bool result = false;
        if( !used[index] && matrix[index]==str[length]){
            used[index] = true;
            result = hasPathRecu(matrix, rows, cols, row-1, col, str, length+1, used)|| hasPathRecu(matrix, rows, cols, row+1, col, str, length+1, used)
                ||hasPathRecu(matrix, rows, cols, row, col+1, str, length+1, used)||hasPathRecu(matrix, rows, cols, row, col-1, str, length+1, used);
            used[index] = false;
        }
        if(result)
            return true;
        return false;
    }
public:
    bool hasPath(char* matrix, int rows, int cols, char* str)
    {
        vector<bool> used(strlen(matrix),false);
        if(str==NULL) return true;
        for(int i=0;i<rows;i++){
            for(int j=0;j<cols;j++){
                if(hasPathRecu(matrix, rows, cols, i, j, str, 0, used))
                    return true;
            }
        }
        return false;
    
    }
};
14
忆水寒
class Solution {
public:
    /*
      大家好，我是yishuihan，这个题目是回溯法的典型题目；
      还有八皇后问题也是经典的回溯法例题，大家可以参考;在《剑指offer》书中也给出了八皇后问题的思路；
      不过，那个是在全排列问题中引出来的。其实回溯法也是全排列的一种方案，在本题中，也就是尝试了
      matrix矩阵中所有点作为起点的方法，然后依据这个点进行向四个方向的递归；
      在递归中，不满足题目的会自动出栈回到上一个状态；
    */
    bool hasPath(char* matrix, int rows, int cols, char* str)
    {
       if(matrix==NULL||rows<1||cols<1||str==NULL) return false;
       bool *flag=new bool[rows*cols];
       memset(flag,false,rows*cols);
       for(int i=0;i<rows;i++)
       {
           for(int j=0;j<cols;j++)
           {
               if(haha(matrix,rows,cols,i, j,str,0,flag))
               {
                   return true;
               }
           }
       }
        delete[] flag;
        return false;
    }
     /*参数说明*/
    bool haha(char* matrix,int rows,int cols,int i,int j,char* str,int k,bool* flag)
    {
        //因为是一维数组存放二维的值，index值就是相当于二维数组的（i，j）在一维数组的下标
       int index = i * cols + j;
        //flag[index]==true,说明被访问过了，那么也返回true;
       if(i<0 || i>=rows || j<0 || j>=cols || matrix[index]!=str[k] || flag[index]==true)
               return false;
        //字符串已经查找结束，说明找到该路径了
       if(str[k+1]=='\0') return true;
        //向四个方向进行递归查找,向左，向右，向上，向下查找
       flag[index] = true;//标记访问过
       if(  haha(matrix, rows, cols, i - 1, j,     str, k + 1, flag)
          ||haha(matrix, rows, cols, i + 1, j,     str, k + 1, flag)
          ||haha(matrix, rows, cols, i,     j - 1, str, k + 1, flag)
          ||haha(matrix, rows, cols, i,     j + 1, str, k + 1, flag))
        {
            return true;
        }
        flag[index] = false;
        return false;
    }
};
8
C/C++
Aking
  无需额外的空间 
  class Solution { 
  public: 
  bool dfs(char* matrix, int rows, int cols, char* str, int i,
  int j){ 
  if(!str || !(*str)) return true; 
  bool ans = false; 
  if((i>=0) && (i<rows) && (j>=0)
  && (j<cols) && (matrix[i*cols+j]== *str)){ 
  matrix[i*cols+j]='\0'; 
  ans =  dfs(matrix, rows, cols, str+1, i-1, j) 
  || dfs(matrix, rows, cols, str+1, i+1, j) 
  || dfs(matrix, rows, cols, str+1, i, j-1) 
  || dfs(matrix, rows, cols, str+1, i, j+1); 
  matrix[i*cols+j]=*str; 
  } 
  return ans; 
  } 
  bool hasPath(char* matrix, int rows, int cols, char* str) 
  { 
for(int i=0;i<rows;i++){ 
  for(int j=0;j<cols;j++){ 
  if(dfs(matrix, rows, cols, str, i, j)){ 
  return true; 
  } 
  } 
  } 
  return false; 
  } 
  }; 
6
chestnut7
PYTHON 回溯法 # -*- coding:utf-8 -*-
#回溯法
#遍历矩阵中的每一个位置
class Solution:
    def hasPath(self, matrix, rows, cols, path):
        # write code here
        if not matrix:
            return False
        if not path:
            return True
        x = [list(matrix[cols*i:cols*i+cols]) for i in range(rows)]
        for i in range(rows):
            for j in range(cols):
                if self.exist_helper(x, i, j, path):
                    return True
        return False
    def exist_helper(self, matrix, i, j, p):
        if matrix[i][j] == p[0]:
            if not p[1:]:
                return True
            matrix[i][j] = ''
            if i > 0 and self.exist_helper(matrix, i-1, j, p[1:]):
                return True
            if i < len(matrix)-1 and self.exist_helper(matrix, i+1, j ,p[1:]):
                return True
            if j > 0 and self.exist_helper(matrix, i, j-1, p[1:]):
                return True
            if j < len(matrix[0])-1 and self.exist_helper(matrix, i, j+1, p[1:]):
                return True
            matrix[i][j] = p[0]
            return False
        else:
            return False
6
C/C++
I_hate_algorithm
//思路：扫一遍矩阵 如果矩阵当前字符等于要查找的第一个字符，则从这个点dfs
//    详见代码注释
char maze[100][100];    //题目给的是char* matrix转换为二维char**maze
int vis[100][100];    //记录是否被访问过
int m,n;
int dx[]={0,1,0,-1},dy[]={1,0,-1,0};    //四个方向
class Solution {
public:
    void build(char* matrix,int rows,int cols)    //建立二维的矩阵
    {
        int cnt=0;
        for(int i=0;i<rows;++i)
            for(int j=0;j<cols;++j)
                maze[i][j]=matrix[cnt++];
        
    }
    //(x,y)表示当前坐标，des表示要查找的字符串，cnt表示已经匹配上了多少个
    //len表示要查找的字符串的长度(好确定递归出口)
    bool dfs(int x,int y,char *des,int cnt,int len)
    {
        if(cnt>=len)    //出口
            return true;
        vis[x][y]=1;
        for(int i=0;i<=3;++i)
        {
            int newx=x+dx[i],newy=y+dy[i];
            if(vis[newx][newy]==0&&newx>=0&&newx<m&&newy>=0&&newy<n&&maze[newx][newy]==des[cnt])
            {
                if(dfs(newx,newy,des,cnt+1,len))
                    return true;
            }
        }
        return false;    //匹配失败
        
    }
    bool hasPath(char* matrix, int rows, int cols, char* str)
    {
        m=rows,n=cols;
    	build(matrix,rows,cols);
        memset(vis,0,sizeof(vis));
     	for(int i=0;i<rows;++i)    //遍历一遍，所以要记得重置vis数组
        {
            for(int j=0;j<cols;++j)
            {
                if(maze[i][j]==str[0]&&dfs(i,j,str,1,strlen(str)))
                    return true;
                memset(vis,0,sizeof(vis));    //重置
            }
        }
        return false;
    }
};
5
Java
hustZa
 【java】标准的带记忆DFS搜索，提供递归和非递归 两种 方法，了解一下。   一，标准的DFS，非递归，了解一下    思路：带记忆的BFS或者DFS，    需要辅助容器帮助记录路径，选用栈stack，还需要标记是否遍历过，用boolean[] visited   1.DFS深度优先， 进：peek一次，str的位子index++，对应位子visited[i+j*rows]=true，    并且把周围合适的点（上下左右&&字符匹配&&未遍历）加入到stack中  退:当前遍历过，复位：visited设为false，并且s.pop移除当前元素，str的位置减一 2.如果str匹配成功就返回true 是不是看起来很简单，接下来看实现   public  boolean hasPath(char[] matrix, int rows, int cols, char[] str)
    {
        if(matrix == null || matrix.length != rows * cols 
                || str == null || str.length == 0 
                || str.length > matrix.length) return false;
        boolean[] visited = new boolean[matrix.length];
        for (int j = 0; j < rows; j++) {
            for (int i = 0; i < cols; i++) {//每个节点都有可能是起点
                if(dfs(matrix,rows,cols,str,i,j,visited)) return true;
            }
        }
        return false;
    }    
      //这里方便遍历上下左右
    private static int[] x = {0,1,0,-1};//顺时针
    private static int[] y = {1,0,-1,0};//顺时针
    //这里复用了boolean[] visited 减少内存开销
    private  boolean dfs(char[] matrix, int rows, int cols, char[] str, int i, int j, boolean[] visited) {
        if(matrix[i + j * cols] != str[0]) return false;//第一个字符必须相等
        Stack<Integer> s = new Stack<>();//存的是坐标
        int index = 0;//当前str的索引
        s.push(i + j * cols);
        while(!s.empty()) {
            int location = s.peek();
            if(visited[location] == true){//访问过,全部复位
                visited[location] = false;//取消访问记录
                s.pop();//退出该节点
                if(--index < 0) return false;  
                continue;//防止该路径再次遍历
            }
            visited[location] = true;//标记已访问 
            if(++index == str.length) return true;//如果这个字符恰好是最后一个字符，直接返回true
           
            /*
             * 将当前节点周围(上下左右)符合标准的点加入到s中,
             * 1.边界条件：i = location % cols  j = location / cols i和j判断边界
             * 2.必须未遍历过visited[cur] == false
             * 3.当前字符匹配matrix[cur] == str[index]
             */
           for (int k = 0; k < 4; k++) {
               int xn = location % cols + x[k];
               int yn = location / cols + y[k];
               int cur = xn + yn * cols;
               if(xn >= 0 && xn < cols && yn >= 0 
                          && yn < rows && visited[cur] == false
                          && matrix[cur] == str[index]) {
                   s.push(cur);
               }
           }
        }
        return false;
    }   二,前面大佬都是递归，没有新意，为了保证完整性，还是加上，递归也确实容易理解，代码简单    用递归来实现DFS 1.确定出口：  false:1.边界条件不满足，2.当前字符不匹配，3.已经遍历过  true：字符串str已经遍历结束 2.递：设置访问过 递归方式，按照上下左右递归 3.归：复位，未访问   public boolean hasPath(char[] matrix, int rows, int cols, char[] str)
    {
        if(matrix == null || matrix.length != rows * cols 
                || str == null || str.length == 0 
                || str.length > matrix.length) return false;
        boolean[] visited = new boolean[matrix.length];
        for (int j = 0; j < rows; j++) {
            for (int i = 0; i < cols; i++) {//每个节点都有可能是起点
                if(dfs(matrix,rows,cols,str,i,j,0,visited)) return true;
            }//这里多了个k=0来充当str的索引
        }
        return false;
        
    }
//递归开始，真是短啊
private boolean dfs(char[] matrix, int rows, int cols, char[] str, int i, int j, int k,
            boolean[] visited) {
        if(i < 0 || i >= cols || j < 0 || j >= rows 
                || visited[i + j * cols] || matrix[i + j * cols] != str[k])
            return false;
        if(k == str.length - 1) return true;//出口
        visited[i + j * cols] = true;//递
        if(dfs(matrix, rows, cols, str, i, j - 1, k + 1, visited)
              || dfs(matrix, rows, cols, str, i + 1, j, k + 1, visited)
              || dfs(matrix, rows, cols, str, i, j + 1, k + 1, visited)
              || dfs(matrix, rows, cols, str, i - 1, j, k + 1, visited))
            return true;
        visited[i + j * cols] = false;//归
        return false;
    }
        
5
‭free2ing
//非递归法。由于一次只能出栈一个，且无法保证下一个的顺序，因此标记必须“随身携带”。
typedef pair<int, int> Pos;
struct State{
    Pos p;
    int s;
    vector<int> vis;
    State(Pos pos,int step,vector<int>visit) :
            p(pos), s(step), vis(visit) {}
};
class Solution {
    int dx[4]={0,0,-1,1};
    int dy[4]={-1,1,0,0};
public:
    bool hasPath(char* matrix, int rows, int cols, char* str)
    {
        stack<State>q;
        int maxS=strlen(str)-1;
        vector<int> v(rows*cols,0);
        
        //every start
        for(int x=0;x<rows;x++)
            for(int y=0;y<cols;y++){
                if(matrix[x*cols+y]==str[0])
                {
                	v[x*cols+y]=true;
                     q.push(State(Pos(x,y),0,v));
                     v[x*cols+y]=false;
                }
            }
       
        while(!q.empty()){
            //get
            auto t=q.top();q.pop();
            auto p=t.p;auto x=p.first,y=p.second; //position
            auto s=t.s;           //current step
            auto vis=t.vis;
            
            //operation
            if(s==maxS)return true;
            
            //next
            for(int d=0;d<4;d++){
                   int nx=x+dx[d],ny=y+dy[d],ns=s+1;
                   if(nx>=0 && nx<rows && ny>=0 && ny<cols &&
                      ns<=maxS &&
                      matrix[nx*cols+ny]==str[ns] && 
                      !vis[nx*cols+ny]){
                       vis[nx*cols+ny]=true;
                       q.push(State(Pos(nx,ny),ns,vis)); 
                   }
            }
        }
        
        
        
        return false;
    }
};
 
4
C/C++
danqiuBear
//我们的二维数组board中每个数都作为起点和给定的字符串做匹配，我们需要
//一个和原二维数组board等大小的visited数组，是bool型的，用来记录当前位置
//是否被访问过。因为题目要求一个cell只能被访问一次。
//如果二维数组的当前字符和目标字符串str对应的字符相等，则对其上下左右四个邻字
//符串分别调用dfs的递归函数，只要有一个返回true，那么就表示找到对应的字符串  
class Solution {
public:
    bool hasPath(char* matrix, int rows, int cols, char* str)
    {
        if(str==NULL||rows<=0||cols<=0)
           return false;
        vector<vector<char>> board(rows, vector<char>(cols));
        for(int i = 0; i < rows; ++i){//将matrix装入二维数组board中
            for(int j = 0; j < cols; ++j){
                board[i][j] = matrix[i*cols + j];
            }
        }
        vector<vector<bool>> visited(rows,vector<bool>(cols, false));
        for(int i = 0; i < rows; ++i){
            for(int j = 0; j < cols; ++j){
                if(dfs(board, str, 0, i, j, visited) == true)
                    return true;//以矩阵board中的每个字符为起点进行广度优先搜索
                //找到一个符合条件的即返回true.
            }
        }
        return false;//遍历完都没找到匹配的路径，返回false
    }
private:
    bool dfs(vector<vector<char>> board, char* str, int index, int x, int y,
            vector<vector<bool>>& visited){
        if(index == strlen(str))return true;//搜寻超过路径长度，符合条件，返回true
        if((x < 0)||(y < 0)||(x >= board.size()) || (y >= board[0].size()))
            return false;//访问越界，终止，返回false
        if(visited[x][y]) return false;//之前访问过，剪枝
        if(board[x][y] != str[index]) return false;//不相等，剪枝
        visited[x][y] = true;
        bool ret = dfs(board, str, index+1, x, y-1,visited)|| //上
               dfs(board, str, index+1, x, y+1,visited)||     //下
               dfs(board, str, index+1, x-1, y,visited)||     //左
               dfs(board, str, index+1, x+1, y,visited);      //右
        visited[x][y] = false;//记得此处改回false，以方便下一次遍历搜索。
        return ret;
    } 
}; 
4
Python
冯毅东
#python 2.7 递归 时间：34ms 内存：5504k
class Solution:
    def hasPath(self, matrix, rows, cols, path):
        for i, s in enumerate(matrix):
            if s==path[0] and self.visit([(i//cols, i%cols)], matrix, rows, cols, path):
                return True
        return False
    
    def visit(self, ans, matrix, rows, cols, path):
        if len(ans)==len(path):
            return True
        i,j = ans[-1]
        nex = [(ii,jj) for ii,jj in [(i,j-1),(i,j+1),(i-1,j),(i+1,j)]
               if 0<= ii <rows and 0<= jj <cols and 
               (ii,jj) not in ans and
               matrix[ii*cols +jj]==path[len(ans)]]
        return sum([self.visit(ans+[x], matrix, rows, cols, path) for x in nex])
 
2
小黄豆3
// dfs遍历。。。
class Solution {
public:
    bool dfs(char *matrix,char *str,int *visited,int rows,int cols,int r,int c,int l,int *stop){
        if(*stop==1)return true;
        int r1,c1,p;
        int dr[]={-1,0,1,0};
        int dc[]={0,1,0,-1};
        p=r*cols+c;
        visited[p]=1;
        if(str[l+1]=='\0'){
            *stop=1;
            return true;
        }
        for(int i=0;i<4;i++){
            r1=r+dr[i];
            c1=c+dc[i];
            if(r1<0||r1>=rows)continue;
            if(c1<0||c1>=cols)continue;
            p=r1*cols+c1;
            if(!visited[p]&&str[l+1]==matrix[p]){
                if(dfs(matrix,str,visited,rows,cols,r1,c1,l+1,stop))
                    return true;
            }
        }
        return false;
    }
    bool hasPath(char* matrix, int rows, int cols, char* str)
    {
        int visited[rows*cols],p,stop;
        for(int i=0;i<rows;i++){
            for(int j=0;j<cols;j++){
                p=i*cols+j;
                if(matrix[p]==str[0]){
                    for(int i=0;i<rows;i++){
                        for(int j=0;j<cols;j++){
                            p=i*cols+j;
                            visited[p]=0;
                        }
                    }
                    stop=0;
                    if(dfs(matrix,str,visited,rows,cols,i,j,0,&stop)){return true;}
                }
            }
        }
        return false;
    }
}; 
2
~一念执着~
//回溯法，写了两种，注意flag矩阵的处理
//第一种
class Solution {
public:
    bool hasPath(char* matrix, int rows, int cols, char* str) {
        bool res = 0;
        for (int i = 0;i<rows;++i) {
            for (int j = 0;j<cols;++j) {
                //bool *flag = (bool *)calloc(rows*cols, 1);
                //vector<bool> flag(rows*cols,0);
                bool *flag=new bool[rows*cols];
                memset(flag,0,rows*cols);
                res = dfs(matrix, rows, cols, i, j, flag, str);
                if (res == true)
                    return res;
            }
        }
        return res;
    }
    bool dfs(char* matrix, int rows, int cols, int i, int j, bool* flag, char* str) {
        if (*(flag+i*cols + j) == 1 || (*(flag+i*cols + j) == 0 && *(matrix + i*cols + j) != *str))
            return false;
        else {
            *(flag+i*cols + j) = 1;
            if (*(str+1) == '\0')
                return true;
            bool res1 = 0, res2 = 0, res3 = 0, res4 = 0;
            //左
            if (j > 0 && j < cols)
                res1 = dfs(matrix, rows, cols, i, j - 1, flag, str + 1);
            //右
            if (j >= 0 && j<cols - 1)
                res2 = dfs(matrix, rows, cols, i, j + 1, flag, str+1);
            //上
            if (i>0 && i<rows)
                res3 = dfs(matrix, rows, cols, i - 1, j, flag, str+1);
            //下
            if (i >= 0 && i<rows - 1)
                res4 = dfs(matrix, rows, cols, i + 1, j, flag, str+1);
            if(res1 || res2 || res3 || res4==0)
                *(flag+i*cols + j)=0;
            return res1 || res2 || res3 || res4;
        }
    }
};
//第二种，参照剑指offer简化了一下
class Solution {
public:
	bool hasPath(char* matrix, int rows, int cols, char* str) {
		bool res = 0;
        bool *flag=new bool[rows*cols];
        memset(flag,0,rows*cols);
		for (int i = 0;i<rows;++i) {
			for (int j = 0;j<cols;++j) {
				//bool *flag = (bool *)calloc(rows*cols, 1);
				res = dfs(matrix, rows, cols, i, j, flag, str);//1
				if (res == true)
					return res;
			}
		}
        delete[] flag;
		return res;
	}
	bool dfs(char* matrix, int rows, int cols, int i, int j, bool* flag, char* str) {
        if (*str == '\0')
			return true;
        if(i<0||i>=rows||j<0||j>=cols)
            return false;
		if (*(flag+i*cols + j) == 1 || (*(flag+i*cols + j) == 0 && *(matrix + i*cols + j) != *str)) 
			return false;
		else {
			*(flag+i*cols + j) = 1;
			bool res=dfs(matrix, rows, cols, i, j - 1, flag, str + 1)//左
                ||dfs(matrix, rows, cols, i, j + 1, flag, str+1)//右
                ||dfs(matrix, rows, cols, i - 1, j, flag, str+1)//上
                ||dfs(matrix, rows, cols, i + 1, j, flag, str+1);//下
            if(res==0)
                *(flag+i*cols + j)=0;//这样从1处开始进入的DFS即使没找到路径，但是flag最后全部置为0
			return res;
		}
	}
};
1
威德·刘
Python 版本的，有兴趣可以参考一下。代码就是根据剑指offer上C++版本改写过来的，改正了一个小bug（第5行的判断）。欢迎指教
# -*- coding:utf-8 -*-
class Solution:
    def hasPath(self,matrix,rows,cols,path):
        len_string=len(path)
        if(matrix=='' or (rows==1 and cols!=1) or (cols==1 and rows!=1) or str==''):
            return False
        visited=[False for t in range(rows*cols)]
        pathlength=0
        for row in range(rows):
            for col in range(cols):
                if(self.HasPathCore(matrix,rows,cols,row,col,path,pathlength,visited)):
                    return True
        return False
    def HasPathCore(self,matrix,rows,cols,row,col,path,pathlength,visited):
        len_string=len(path)
        if pathlength>=len_string:
            return True
        hasPath=False
        if (row>=0 and row<rows and col>=0 and col<cols and matrix[row*cols+col]==path[pathlength] and (not visited[row*cols+col])):
            pathlength=pathlength+1
            visited[row*cols+col]=True
            hasPath=self.HasPathCore(matrix,rows,cols,row,col-1,path,pathlength,visited) or self.HasPathCore(matrix,rows,cols,row-1,col,path,pathlength,visited)\
                    or self.HasPathCore(matrix,rows,cols,row,col+1,path,pathlength,visited)\
                    or self.HasPathCore(matrix,rows,cols,row+1,col,path,pathlength,visited)
            if(not hasPath):
                pathlength=pathlength-1
                visited[row*cols+col]=False
        return hasPath
	
 
1
Java
Mono_Chrome
public class Solution {
    public boolean hasPath(char[] matrix, int rows, int cols, char[] str)
    {
        boolean[] visited = new boolean[rows * cols];
        boolean res = false;
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                res = process(matrix, str, rows, cols, i, j, 0, visited);
                if (res == true) {
                    return true;
                }
            }
        }
        return res;
    }
    public static boolean process(char[] matrix, char[] str, int rows, int cols, int row, int col, int index, boolean[] visited) {
        if (index == str.length) {
            return true;
        }
        boolean hasPath = false;
        if (row < rows && row >= 0 && col < cols && col >= 0 && visited[row * cols + col] == false && matrix[row * cols + col] == str[index]) {
            ++index;
            visited[row * cols + col] = true;
            hasPath = process(matrix, str, rows, cols, row + 1, col, index, visited) ||
                    process(matrix, str, rows, cols, row - 1, col, index, visited) ||
                    process(matrix, str, rows, cols, row, col + 1, index, visited) ||
                    process(matrix, str, rows, cols, row, col - 1, index, visited);
            if (!hasPath) {
                --index;
                visited[row * cols + col] = false;
            }
        }
        return hasPath;
    }
}
1
刀轻城_algo
    # 基于深度优先遍历的方法
    # 与原本的深度遍历不同的地方在于，除了当前路径的节点被标记为DISCOVERED，其他路径上的节点撤销该标记
    def hasPath(self, matrix, rows, cols, path):
        # write code here
        self.discovered = {} # 维护矩阵中的节点是否遍历
        self.tar = 0 # 维护要遍历到的path的位置
        matrix = list(matrix)
        matrix = [matrix[i*cols:i*cols+cols] for i in range(rows)] # 将输入的字符串复原为矩阵
        def dfs(x,y): # 深度优先遍历的子函数，只有在遍历刚好结束于path的最后一个字符也相等的时候，返回TRUE
            if x<0 or x==rows or y<0 or y==cols: # 如果坐标非法
                return False
            if (x,y) in self.discovered or matrix[x][y] != path[self.tar]: # 如果坐标已被访问或者坐标与应匹配字符串不同
                return False
            # 如果坐标合法且匹配正确
            if self.tar == len(path) - 1: # 如果已经匹配到了最后一个字符
                return True
            # 匹配到中间字符，则继续向下遍历
            self.discovered[x,y] = 1 # 标记当前坐标，防止重复访问
            self.tar += 1 # 向后移动匹配位置
            ret = dfs(x-1,y) or dfs(x+1,y) or dfs(x,y-1) or dfs(x,y+1) # 向四个方向进行深度优先遍历，确定匹配最终结果
            # 当遍历返回的时候，重置该坐标的访问标志和path的匹配位置
            self.discovered.pop((x,y))
            self.tar -= 1
            return ret
        # 依次将每一个单元格作为遍历起点
        for i in range(rows):
            for j in range(cols):
                if dfs(i,j):
                    return True
        return False
1
可爱的考拉
class Solution {
public:
    bool hasPath(char* matrix, int rows, int cols, char* str)
    {
        if(matrix==nullptr||rows<1||cols<1||str==nullptr) return false;
        bool* visited=new bool[rows*cols];
        memset(visited,0,rows*cols);
        int length=0;
        for(int row=0;row<rows;row++)
            for(int col=0;col<cols;col++){
                if(hasPathCore(matrix,visited,rows,cols,row,col,str,length))
                    return true;
            }
        delete[] visited;
        return false;
    }
    bool hasPathCore(char* matrix, bool* visited, int rows,
                      int cols, int row, int col, char* str,int length){
        if(str[length]=='\0')
            return true;
        bool haspath=false;
        if(row>=0&&row<rows&&col>=0&&col<cols&&matrix[row*cols+col]==str[length]&&!visited[row*cols+col]){
            visited[row*cols+col]=true;
            length++;
            haspath=hasPathCore(matrix,visited,rows,cols,row+1,col,str,length)||
                hasPathCore(matrix,visited,rows,cols,row,col+1,str,length)||
                hasPathCore(matrix,visited,rows,cols,row,col-1,str,length)||
                hasPathCore(matrix,visited,rows,cols,row-1,col,str,length);
            if(!haspath){
                length--;
                visited[row*cols+col]=false;
            }
        }
        return haspath;
    }
};
 
1
Java
牛客网老用户
public class Solution {
    public boolean hasPath(char[] matrix, int rows, int cols, char[] str){
        for(int i = 0; i < rows; i ++){
            for(int j = 0; j < cols; j ++){
                if(isPath(matrix, str, 0, 
                          i, j, rows, cols)){
                    return true;
                }
            }
        }
        return false;
    }
    //   i 当前行  j  当前列   len已经计算的长度
    public boolean isPath(char[] matrix, char[] str, int len, 
                          int i, int j, int rows, int cols){
        //先根据i和j计算匹配的第一个元素转为一维数组的位置
        int index = i * cols + j;
        //不等...该路径不是
        if(str[len] != matrix[index]){
            return false;
        }
        //长度够了...该路径是
        if(str.length == len + 1){
            return true;
        }
        char c = matrix[index];
        //访问过了改个状态
        matrix[index] = '*';
        int[] di = {-1, 0, 1, 0}, dj = {0, 1, 0, -1};
        for(int k = 0; k < 4; k ++){
            int a = i + di[k];
            int b = j + dj[k];
            if((a > -1) && (a < rows) && (b > -1) && (b < cols) 
               && (len + 1 < str.length)){//不越界就搞下一个上下左右走
                if(isPath(matrix, str, len + 1, a, b, rows, cols)){
                    return true;
                }
            }
        }
        //状态改回来
        matrix[index] = c;
        return false;
    }
}
