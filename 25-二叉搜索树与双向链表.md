考点    

分解让复杂问题简单

热点指数    40641
通过率    27.70%
题目    

二叉搜索树与双向链表


具体题目    输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。
讨论    560
nailperry
方法一：非递归版 解题思路：   
查看全部
228
Polaris045217
中序遍历即可。只需要记录一个pre指针即可。
高分答案也太绕了吧
class Solution {
public:
    TreeNode* Convert(TreeNode* pRootOfTree)
    {
        if(pRootOfTree == nullptr) return nullptr;
        TreeNode* pre = nullptr;
        
        convertHelper(pRootOfTree, pre);
        
        TreeNode* res = pRootOfTree;
        while(res ->left)
            res = res ->left;
        return res;
    }
    
    void convertHelper(TreeNode* cur, TreeNode*& pre)
    {
        if(cur == nullptr) return;
        
        convertHelper(cur ->left, pre);
        
        cur ->left = pre;
        if(pre) pre ->right = cur;
        pre = cur;
        
        convertHelper(cur ->right, pre);
        
        
        
    }
};
194
fleese
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;
    public TreeNode(int val) {
        this.val = val;
    }
}
*/
//直接用中序遍历
public class Solution {
    TreeNode head = null;
	TreeNode realHead = null;
    public TreeNode Convert(TreeNode pRootOfTree) {
        ConvertSub(pRootOfTree);
        return realHead;
    }
    
    private void ConvertSub(TreeNode pRootOfTree) {
        if(pRootOfTree==null) return;
		ConvertSub(pRootOfTree.left);
		if (head == null) {
			head = pRootOfTree;
			realHead = pRootOfTree;
		} else {
			head.right = pRootOfTree;
			pRootOfTree.left = head;
			head = pRootOfTree;
		}
		ConvertSub(pRootOfTree.right);
    }
}
40
麦芽
public class Solution {  //类似树的线索化,相当简洁
      TreeNode pre=null;
    TreeNode lastLeft=null;
    public TreeNode Convert(TreeNode pRootOfTree) {
        if(pRootOfTree==null){
            return null;
        }
    	Convert(pRootOfTree.left);
        pRootOfTree.left=pre;
        if(pre!=null)pre.right=pRootOfTree;
        pre=pRootOfTree;
        lastLeft=lastLeft==null?pRootOfTree:lastLeft;
        Convert(pRootOfTree.right);
    	return lastLeft; 
    }
}
64
Logout
//递归调用 左 根 右 遍历
public class Solution {
     //双向链表的左边头结点和右边头节点
    TreeNode leftHead = null;
    TreeNode rightHead = null;
    public TreeNode Convert(TreeNode pRootOfTree) {
         //递归调用叶子节点的左右节点返回null
        if(pRootOfTree==null) return null;
          //第一次运行时，它会使最左边叶子节点为链表第一个节点
        Convert(pRootOfTree.left);
        if(rightHead==null){
            leftHead= rightHead = pRootOfTree;
        }else{
            //把根节点插入到双向链表右边，rightHead向后移动
           rightHead.right = pRootOfTree;
           pRootOfTree.left = rightHead;
           rightHead = pRootOfTree;
        }
         //把右叶子节点也插入到双向链表（rightHead已确定，直接插入）
        Convert(pRootOfTree.right);
         //返回左边头结点
        return leftHead;
    }
}
30
Python
Yannyezixin
  思路： 
  非递归版本： 
二叉树的中序遍历
    中序遍历中每个结点的链接
  
# -*- coding:utf-8 -*-
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    def Convert(self, pRootOfTree):
        if not pRootOfTree:
            return None
        
        p = pRootOfTree
        
        stack = []
        resStack = []
        
        while p or stack:
            if p:
                stack.append(p)
                p = p.left
            else:
                node = stack.pop()
                resStack.append(node)
                p = node.right
            
        resP = resStack[0]
        while resStack:
            top = resStack.pop(0)
            if resStack:
                top.right = resStack[0]
                resStack[0].left = top
        
        return resP
  递归版本 
# -*- coding:utf-8 -*-
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    def Convert(self, root):
        if not root:
            return None
        if not root.left and not root.right:
            return root
        
        # 将左子树构建成双链表，返回链表头
        left = self.Convert(root.left)
        p = left
        
        # 定位至左子树的最右的一个结点
        while left and p.right:
            p = p.right
        
        # 如果左子树不为空，将当前root加到左子树链表
        if left:
            p.right = root
            root.left = p
        
        # 将右子树构造成双链表，返回链表头
        right = self.Convert(root.right)
        # 如果右子树不为空，将该链表追加到root结点之后
        if right:
            right.left = root
            root.right = right
            
        return left if left else root
27
spursKawhi
/** 递归：中序遍历 右 中 左 */
public class Solution {
    TreeNode list = null;
    public TreeNode Convert(TreeNode pRootOfTree) {
        if(pRootOfTree == null) return pRootOfTree;
        
        Convert(pRootOfTree.right);
        if(list == null){
            list = pRootOfTree;
        } else {
            list.left = pRootOfTree;
            pRootOfTree.right = list;
            list = pRootOfTree;
        }
        Convert(pRootOfTree.left);
        
        return list;
    }
}
/** 非递归 */
import java.util.Stack;
public class Solution {
    public TreeNode Convert(TreeNode pRootOfTree) {
        if(pRootOfTree == null) return pRootOfTree;
        
        TreeNode list = null;
        Stack<TreeNode> s = new Stack<>();
        while(pRootOfTree != null || !s.isEmpty()){
            if(pRootOfTree != null) {
                s.push(pRootOfTree);
                pRootOfTree = pRootOfTree.right;
            } else {
                pRootOfTree = s.pop();
                if(list == null)
                    list = pRootOfTree;
                else {
                    list.left = pRootOfTree;
                    pRootOfTree.right = list;
                    list = pRootOfTree;
                }
                pRootOfTree = pRootOfTree.left;
            }
        }
        
        return list;
    }
}
https://en.wikipedia.org/wiki/Tree_traversal#Iterative_Traversal
30
Python
华科平凡
python solution: 先中序遍历，将所有的节点保存到一个列表中。对这个list[:-1]进行遍历，每个节点的right设为下一个节点，下一个节点的left设为上一个节点。 class Solution:
    def Convert(self, pRootOfTree):
        # write code here
        if not pRootOfTree:return 
        self.arr = []
        self.midTraversal(pRootOfTree)
        for i,v in enumerate(self.arr[:-1]):
            v.right = self.arr[i + 1]
            self.arr[i + 1].left = v
        return self.arr[0]
    def midTraversal(self, root):
        if not root: return
        self.midTraversal(root.left)
        self.arr.append(root)
        self.midTraversal(root.right)
19
丁满历险记
  高票几个解法要么递归实现，要么借助栈迭代实现，其实都需要O(h)或O(n)的额外空间。这里分享一种非递归、O(1)空间复杂度的解法。该方法通过Morris遍历实现（不熟悉的同学可以搜索Morris Traversal），将二叉树重构为所有结点只有右子树的一条链。代码如下：   public class Solution {
    public TreeNode Convert(TreeNode pRootOfTree) {
        TreeNode p = pRootOfTree, pre = null, res = null;
        while (p != null) {
            while (p.left != null) {
                TreeNode q = p.left;
                while (q.right != null) {
                    q = q.right;
                }
                q.right = p;
                TreeNode tmp = p.left;
                p.left = null;
                p = tmp;
            }
            p.left = pre;
            if (pre == null) {
                res = p;
            } else {
                pre.right = p;
            }
            pre = p;
            p = p.right;
        }
        return res;
    }
}  
10
月印万川
/*
非递归中序遍历，加个指针pre记录上一次出栈值
*/
class Solution {
public:
    TreeNode* Convert(TreeNode* pRootOfTree)
    {
        TreeNode *head = NULL, *pre = NULL;//head 输出，pre记录上一次出栈值
        stack<TreeNode*> s;
        while (pRootOfTree || !s.empty())
        {
            while (pRootOfTree)
            {
                s.push(pRootOfTree);
                pRootOfTree = pRootOfTree->left;
            }
            if (!s.empty())
            {
                pRootOfTree = s.top();
                s.pop();
                if (pre != NULL)
                {
                    pre->right = pRootOfTree;
                    pRootOfTree->left = pre;
                }
                else//pre为空，表示s第一次出栈，第一次出栈值为最左值，即输出值
                    {
                    head = pRootOfTree;
                }
                pre = pRootOfTree;
                pRootOfTree = pRootOfTree->right;
            }
        }
        return head;
    }
}; 
20
什么都不会
直接使用递归即可 
class Solution {
public:
    TreeNode* Convert(TreeNode* pRootOfTree)
    {
        if(pRootOfTree == NULL) return pRootOfTree;
        pRootOfTree = ConvertNode(pRootOfTree);
        while(pRootOfTree->left) pRootOfTree = pRootOfTree->left;
        return pRootOfTree;
    }
    TreeNode* ConvertNode(TreeNode* root)
    {
        if(root == NULL) return root;
        if(root->left)
        {
            TreeNode *left = ConvertNode(root->left);
            while(left->right) left = left->right;
            left->right = root;
            root->left = left;
        }
        
        if(root->right)
        {
            TreeNode *right = ConvertNode(root->right);
            while(right->left) right = right->left;
            right->left = root;
            root->right = right;
        }
        return root;
    }
};
11
Warren
  采用中序遍历 
  修改中序遍历，在其中加入一个前驱结点 
  遍历左子树 
  当前结点指向左指针指向前驱结点 
  前驱结点右指针指向当前结点 
  前驱 = 当前 
  遍历右子树 
7
C/C++
lca1826
【思路】因为二叉搜索树的中序遍历就是递增排列的，所以只要在中序遍历时将每个结点放入vector中，再分别为每个结点的左右指针赋值即可。
  /* 
  struct TreeNode { 
int val; 
struct TreeNode *left; 
struct TreeNode *right; 
TreeNode(int x) : 
val(x), left(NULL), right(NULL) { 
} 
  };*/ 
  class Solution 
  { 
  public: 
      vector<TreeNode *> nodeVector; 
      void inOrder(TreeNode* root) 
      { 
          if(root->left) 
              inOrder(root->left); 
          nodeVector.push_back(root); 
          if(root->right) 
              inOrder(root->right); 
      } 
      TreeNode* Convert(TreeNode* pRootOfTree) 
      { 
          if((pRootOfTree == NULL) || (!pRootOfTree->left)
  && (!pRootOfTree->right)) 
              return pRootOfTree; 
          inOrder(pRootOfTree); 
          nodeVector[0]->left = NULL; 
          nodeVector[0]->right = nodeVector[1]; 
          int i = 1; 
          for( ; i < nodeVector.size() - 1; i ++) 
          { 
              nodeVector[i]->left = nodeVector[i - 1]; 
              nodeVector[i]->right = nodeVector[i + 1]; 
          } 
          nodeVector[i]->left = nodeVector[i - 1]; 
          nodeVector[i]->right = NULL; 
          return nodeVector[0]; 
      } 
  }; 
6
Java
大北砸
我认为最高赞答案的代码有些冗余，这里采用的是和剑指offer完全一样的思想。  明确Convert函数的功能。输入：输入一个二叉搜索树的根节点。过程：将其转化为一个有序的双向链表。输出：返回该链表的头节点。  明确成员变量pLast的功能。pLast用于记录当前链表的末尾节点。  明确递归过程。递归的过程就相当于按照中序遍历，将整个树分解成了无数的小树，然后将他们分别转化成了一小段一小段的双向链表。再利用pLast记录总的链表的末尾，然后将这些小段链表一个接一个地加到末尾。 private TreeNode pLast = null;
public TreeNode Convert(TreeNode root) {
 if (root == null)
     return null;
 // 如果左子树为空，那么根节点root为双向链表的头节点
 TreeNode head = Convert(root.left);
 if (head == null)
     head = root;
 // 连接当前节点root和当前链表的尾节点pLast
 root.left = pLast;
 if (pLast != null)
     pLast.right = root;
 pLast = root;
 Convert(root.right);
 return head;
} 
6
yang251
 先将左子树变为有序的排序链表，再将右子树变为有序的链表，然后将当前结点插入在两个链表中间就可以了，需要注意左子树和右子树为空的情况    /*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};*/
classSolution {
public:
    TreeNode* Convert(TreeNode* pRootOfTree)
    {
        if(pRootOfTree == NULL)
            returnNULL;
         
        TreeNode* list1 = Convert(pRootOfTree->left);    // 将左子树变为排序链表
        TreeNode* list2 = Convert(pRootOfTree->right);   // 将右子树变为排序链表
        TreeNode* tmp = list1;
        if(tmp != NULL)
        {
            while(tmp->right)
            {
                tmp = tmp->right;
            }
            tmp->right     = pRootOfTree;
        }
        
        pRootOfTree->left  = tmp;
        pRootOfTree->right = list2;
        if(list2 != NULL)
            list2->left        = pRootOfTree;
         
        return(list1 == NULL ? pRootOfTree:list1);
    }
};     
4
东方小龙2129360
/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};*/
class Solution {
public:
    TreeNode* Convert(TreeNode* pRootOfTree)
    {
        if(pRootOfTree == NULL)
            return NULL;
        TreeNode* pre = NULL;//此处需要初始化，否则循环输入程序判错
        MiddleList(pRootOfTree,pre);
        while(pre->left != NULL)
            pre = pre->left;
        return pre;
    }
    void MiddleList(TreeNode* pRoot,TreeNode* &pre)//中序遍历可得双向链表
    {
        if(pRoot == NULL)
            return;
        MiddleList(pRoot->left,pre);
        if(pre!=NULL)//改变指针的指向
        {
            pRoot->left = pre;
            pre->right = pRoot;
        }
        pre = pRoot;//记录前一个指针
        MiddleList(pRoot->right,pre);
    }
};
 
3
Python
冯毅东
#python 2.7 递归， 时间 37ms，内存：5764k
class Solution:
    def Convert(self, pRootOfTree):
        # write code here
        if pRootOfTree is None :
            return None
        N_min, N_max = self.Conv(pRootOfTree)
        while N_min.left is not None:
            N_min = N_min.left
        return N_min
    def Conv(self,Root):
        N_min = Root; N_max = Root
        if Root.left is not None:
            temp, N_min = self.Conv(Root.left)
            Root.left = N_min
            N_min.right = Root
        if Root.right is not None:
            N_max, temp = self.Conv(Root.right)
            N_max.left = Root
            Root.right = N_max
        return N_min,N_max 
3
悠上清河
  public class Solution { 
      public TreeNode Convert(TreeNode root) { 
       if (root==null) 
           return null; 
       if(root.left==null&&root.right==null) 
           return root; 
          //将左子树转换为双向链表 
       TreeNode left = Convert(root.left); 
       TreeNode p =left;   //返回链表的头结点 
       while(p!=null&&p.right!=null)//找到链表的最后一个节点 
           { 
           p =p.right; 
       } 
          //如果左子树不为空，将根节点添加其后 
          if (left!=null) 
              { 
              p.right=root; 
              root.left=p; 
          } 
              //将右子树转换为双向链表 
       TreeNode right = Convert(root.right); 
       //如果右子树不为空，将根节点与右子树进行连接 
          if (right!=null) 
              { 
              root.right=right; 
              right.left=root; 
          } 
               
         return left!=null?left:root;   
      } 
  } 
3
C/C++
imalwayshere
  可以中序遍历，然后push到一个vector里面，最后两个循环就OK了： 
class Solution {
public:
    vector<TreeNode*> nodes;
    
    void tranverse(TreeNode* pRoot) {
        if (nullptr == pRoot)
            return;
        tranverse(pRoot->left);
        nodes.push_back(pRoot);
        tranverse(pRoot->right);
    }
    
    TreeNode* adjustTree() {
        for (int i = 0; i < nodes.size() - 1; ++i)
            nodes[i]->right = nodes[i+1];
        nodes[nodes.size()-1]->right = nullptr;
        for (int i = nodes.size() - 1; i > 0; --i)
            nodes[i]->left = nodes[i-1];
        nodes[0]->left = nullptr;
        return nodes[0];
    }
    
    TreeNode* Convert(TreeNode* pRoot)
    {
        if (nullptr == pRoot)
            return nullptr;
        tranverse(pRoot);
        return adjustTree();
    }
};
3
Blankeer
  递归中序遍历，左右子树处理不同，左边需要返回最右边的节点，右边需要返回最左边的 
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;
    public TreeNode(int val) {
        this.val = val;
    }
}
*/
public class Solution {
    public TreeNode Convert(TreeNode pRootOfTree) {
        return fun(pRootOfTree, 1);// 得到最左边节点
    }
    TreeNode fun(TreeNode item, int or) {// 左边0，右边1
		if (item == null) {
			return null;
		}
		TreeNode l = fun(item.left, 0);
		item.left = l;
		if (l != null) {
			l.right = item;
		}
		TreeNode r = fun(item.right, 1);
		item.right = r;
		if (r != null) {
			r.left = item;
		}
		if (or == 1) {// 右子树需要得到最左边节点
			while (item.left != null) {
				item = item.left;
			}
		} else {
			while (item.right != null) {
				item = item.right;
			}
		}
		return item;
	}
}
4
老石基
public class Solution {
    public TreeNode Convert(TreeNode root) {
        if(root==null)
            return null;
        get(root);
        while(root.left!=null)
            root = root.left;
        return root;
    }
    public TreeNode get(TreeNode root) {
        if(root.left!=null){
            TreeNode pre = get(root.left);
            while(pre.right!=null)
                pre = pre.right;
            pre.right = root;
            root.left = pre;
        }
        if(root.right!=null){
            TreeNode next = get(root.right);
            while(next.left!=null)
                next = next.left;
            next.left = root;
            root.right = next;
        }
        return root;
    }
}
