考点    

树

热点指数    34685
通过率    30.20%
题目    

对称的二叉树


具体题目    请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。
讨论    161
Ron
/*思路：首先根节点以及其左右  
查看全部
76
Java
hustZa
  【java代码】满屏递归，无法挖掘这一题的价值。接下来提供递归的一个方法和非递归的2个方法参考。    //===================递归算法=============================//    1.只要pRoot.left和pRoot.right是否对称即可    2.左右节点的值相等且对称子树left.left， right.right ;left.rigth,right.left也对称   boolean isSymmetrical(TreeNode pRoot)
    {
        if(pRoot == null) return true;
        return isSymmetrical(pRoot.left, pRoot.right);
    }
    private boolean isSymmetrical(TreeNode left, TreeNode right) {
        if(left == null && right == null) return true;
        if(left == null || right == null) return false;
        return left.val == right.val //为镜像的条件：左右节点值相等
                && isSymmetrical(left.left, right.right) //2.对称的子树也是镜像
                && isSymmetrical(left.right, right.left);
    }
  //===================非递归算法，利用DFS和BFS=============================//     /*      * DFS使用stack来保存成对的节点        * 1.出栈的时候也是成对成对的 ，                   1.若都为空，继续；                   2.一个为空，返回false;                   3.不为空，比较当前值，值不等，返回false；       * 2.确定入栈顺序，每次入栈都是成对成对的，如left.left， right.right ;left.rigth,right.left      */  boolean isSymmetricalDFS(TreeNode pRoot)
    {
        if(pRoot == null) return true;
        Stack<TreeNode> s = new Stack<>();
        s.push(pRoot.left);
        s.push(pRoot.right);
        while(!s.empty()) {
            TreeNode right = s.pop();//成对取出
            TreeNode left = s.pop();
            if(left == null && right == null) continue;
            if(left == null || right == null) return false;
            if(left.val != right.val) return false;
            //成对插入
            s.push(left.left);
            s.push(right.right);
            s.push(left.right);
            s.push(right.left);
        }
        return true;
    }
   /*      * BFS使用Queue来保存成对的节点，代码和上面极其相似        * 1.出队的时候也是成对成对的                      1.若都为空，继续；                      2.一个为空，返回false;                      3.不为空，比较当前值，值不等，返回false；         * 2.确定入队顺序，每次入队都是成对成对的，如left.left， right.right ;left.rigth,right.left      */  boolean isSymmetricalBFS(TreeNode pRoot)
    {
        if(pRoot == null) return true;
        Queue<TreeNode> s = new LinkedList<>();
        s.offer(pRoot.left);
        s.offer(pRoot.right);
        while(!s.isEmpty()) {
            TreeNode right = s.poll();//成对取出
            TreeNode left = s.poll();
            if(left == null && right == null) continue;
            if(left == null || right == null) return false;
            if(left.val != right.val) return false;
            //成对插入
            s.offer(left.left);
            s.offer(right.right);
            s.offer(left.right);
            s.offer(right.left);
        }
        return true;
    }
 
75
Aurora1
boolean isSymmetrical(TreeNode pRoot) {
		if (pRoot == null) 
			return true;
		return f(pRoot.left,pRoot.right);
	}
	
	boolean f(TreeNode t1, TreeNode t2) {
		if (t1 == null && t2 == null) 
			return true;
		
		if (t1 != null && t2 != null) 
			return t1.val == t2.val && f(t1.left,t2.right) && f(t1.right, t2.left);
		
		return false;
	}
44
搬一块叫CV的砖
代码很简单，关键还是知道怎么样才能判断一个
二叉树是否对称，只要采用前序、中序、后序、层次遍历等任何一种遍历方法，分为先左后右和先
右后左两种方法，只要两次结果相等就说明这棵树是一颗对称二叉树。
迭代版本
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(root==NULL) return true;
        queue<TreeNode*> q1,q2;
        TreeNode *left,*right;
        q1.push(root->left);
        q2.push(root->right);
        while(!q1.empty() and !q2.empty())
        {
            left = q1.front();
            q1.pop();
            right = q2.front();
            q2.pop();
            //两边都是空
            if(NULL==left && NULL==right)
                continue;
            //只有一边是空
            if(NULL==left||NULL==right)
                return false;
             if (left->val != right->val)
                return false;
            q1.push(left->left);
            q1.push(left->right);
            q2.push(right->right);
            q2.push(right->left);
        }
        
        return true;
        
    }
};
递归版本
/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};
*/
/*
思路：如果先序遍历的顺序分为两种先左后右和先右后左两种顺序遍历，如果两者相等说明二叉树是对称的二叉树
*/
class Solution {
public:
    bool isSymmetrical(TreeNode* pRoot)
    {
    	return isSymmetrical(pRoot,pRoot);
    }
    
    bool isSymmetrical(TreeNode* pRoot1,TreeNode* pRoot2)
    {
        if(pRoot1==NULL&&pRoot2==NULL)
            return true;
        if(pRoot1==NULL || pRoot2==NULL)            
            return false;
        if(pRoot1->val!=pRoot2->val)
            return false;
        return isSymmetrical(pRoot1->left,pRoot2->right) && isSymmetrical(pRoot1->right,pRoot2->left);
        
    }
};
10
Java
黄小斜
拷贝当前树
对当前树做镜像操作
比较两个树是否相同
/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;
    public TreeNode(int val) {
        this.val = val;
    }
}
*/
public class Solution {
    boolean isSymmetrical(TreeNode pRoot)
    {
        TreeNode temp = copyTree(pRoot);
        Mirror(pRoot);
        return isSameTree(temp, pRoot);
    }
    void Mirror(TreeNode root) {
        if(root == null)return;
        Mirror(root.left);
        Mirror(root.right);
        if(root.left!=null || root.right!=null)
        {
            TreeNode temp=root.left;
            root.left=root.right;
            root.right=temp;
        }
    }
    boolean isSameTree(TreeNode t1,TreeNode t2){
        if(t1==null && t2==null)return true;
        else if(t1!=null && t2!=null && t1.val==t2.val) {
            boolean left = isSameTree(t1.left, t2.left);
            boolean right = isSameTree(t1.right, t2.right);
            return left && right;
        }
        else return false;
    }
    TreeNode copyTree (TreeNode root) {
        if (root == null) return null;
        TreeNode t = new TreeNode(root.val);
        t.left = copyTree(root.left);
        t.right = copyTree(root.right);
        return t;
    }
}   
10
Python
JeffreyWxj
Python Solution  递归比较左右节点，然后对左右节点的左右分支进一步递归比较    class Solution:
    def isSymmetrical(self, pRoot):
        if not pRoot:
            return True
        return self.compare(pRoot.left, pRoot.right)
    def compare(self, pRoot1, pRoot2):
        if not pRoot1 and not pRoot2:
            return True
        if not pRoot1 or not pRoot2:
            return False
        if pRoot1.val == pRoot2.val:
            if self.compare(pRoot1.left, pRoot2.right) and self.compare(pRoot1.right, pRoot2.left):
                return True
        return False
9
烟消bug云散
递归做
class Solution {
public:
	bool isSame(TreeNode* p1,TreeNode* p2)
	{
		if(p1==NULL&&p2!=NULL)return false;
		if(p2==NULL&&p1!=NULL)return false;
        if(p1==NULL&&p2==NULL)return true;
		if(p1->val==p2->val)return isSame(p1->right,p2->left)
			&& isSame(p1->left,p2->right);
		else
			return false;
	}
    bool isSymmetrical(TreeNode* pRoot)
    {
        if(pRoot==NULL)return true;			
		return isSame(pRoot->left,pRoot->right);
    }
};
6
Python
zkqiang
# Python 简单解法，判断左右子节点的值是否相同即可，并通过递归左右节点遍历整个树
# -*- coding:utf-8 -*-
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    def isSymmetrical(self, pRoot):
        # write code here
        if not pRoot:
            return True
        def Traversal(left, right):
            if left is None and right is None:
                return True
            elif left and right and left.val == right.val:
                return Traversal(left.left, right.right) and Traversal(left.right, right.left)
            else:
                return False
        return Traversal(pRoot.left, pRoot.right)
 
9
牛客722730号
  目前好多代码都太复杂了，这里给一个精简的代码 
class Solution {
public:
    bool isSymmetrical(TreeNode* pRoot)
    {
        return aux(pRoot,pRoot);
    }
    bool aux(TreeNode* l, TreeNode* r) {
        if(l&&r&&l->val==r->val)
            return aux(l->left,r->right)&&aux(l->right,r->left);
        return !l&&!r;
    }
};
4
崩溃DE够彻底︶｀
public class Solution {
    boolean a=true;
    boolean isSymmetrical(TreeNode pRoot)
    {
      if(pRoot==null)return a;
      cal(pRoot.left,pRoot.right);   
      return a;
    }
    void cal(TreeNode b,TreeNode c){
        if(b==null&&c==null){return;}
        if(b!=null&&c==null||b==null&&c!=null){a=false;return;}
        cal(b.left,c.right);
        if(b.val!=c.val){a=false;return;}
        cal(b.right,c.left);
        return;
    }
}
 对称树的话除了跟节点随以外只需将其左右子树镜像对称，进行反方向遍历，如若有不等就返回false即可。
3
yudw1316
class Solution
{
    bool isSymmetrical(TreeNode *p_root1, TreeNode *p_root2)
    {
        if (p_root1 == nullptr && p_root2 == nullptr)   // 对称的两个节点为空
            return true;
        else if (p_root1 == nullptr || p_root2 == nullptr)  // 其中一个节点不为空
            return false;
        if (p_root1->val != p_root2->val)   // 对称位置的值不相等
            return false;
        
        // 递归检查对称的位置：p1的左孩子和p2的右孩子，p1的右孩子p2的左孩子
        return isSymmetrical(p_root1->left, p_root2->right) && isSymmetrical(p_root1->right, p_root2->left);
    }
public:
    bool isSymmetrical(TreeNode *pRoot)
    {
        return isSymmetrical(pRoot, pRoot);
    }
}; 
3
ZLXP
//超简单java递归版本
public class Solution {
    boolean isSymmetrical(TreeNode pRoot)
    {
        return is(pRoot,pRoot);
    }
    boolean is(TreeNode t1,TreeNode t2){
        if(t1==null&&t2==null){return true;}
        if(t1==null||t2==null){return false;}
        if(t1.val==t2.val){return is(t1.left,t2.right)&&is(t1.right,t2.left);}
        else return false;
    }
}
5
小松nino
class Solution {
public:
    bool isSymmetrical(TreeNode* pRoot)
    {
        stack<TreeNode*> s1,s2;
        TreeNode *p1,*p2;
        p1=p2=pRoot;
        while((!s1.empty()&&!s2.empty())||(p1!=NULL&&p2!=NULL)){
            while(p1!=NULL&&p2!=NULL){
                s1.push(p1);
                s2.push(p2);
                p1=p1->left;
                p2=p2->right;
            }
            p1=s1.top();
            s1.pop();
         	p2=s2.top();
            s2.pop();
            if(p1->val!=p2->val)
                return false;
            p1=p1->right;
            p2=p2->left;
        }
    	if(!s1.empty()||!s2.empty())
            return false;
        if(p1!=NULL||p2!=NULL)
            return false;
        return true;
    }
};
2
JacobGo！
boolean isSymmetrical(TreeNode pRoot) {
		if (pRoot == null)
			return true;
		return isSymmetrical(pRoot.left, pRoot.right);
	}
	//比较左右子树对应节点是否相同
	private boolean isSymmetrical(TreeNode pRoot1, TreeNode pRoot2) {
		if (pRoot1 == null && pRoot2 == null)
			return true;
		if (pRoot1 == null || pRoot2 == null)
			return false;
		if (pRoot1.val != pRoot2.val)
			return false;
		return isSymmetrical(pRoot1.left, pRoot2.right) && isSymmetrical(pRoot1.right, pRoot2.left);
	}
2
drdr
class Solution {
public:
    bool isSymmetrical(TreeNode* pRoot)
    {  
        if(pRoot == NULL) return true;  
    	return helper(pRoot->left, pRoot->right);                
    }
private:
    bool helper(TreeNode* node1, TreeNode* node2){
        if(node1==NULL && node2==NULL) 
            return true;
        else if(node1!=NULL && node2!=NULL)
        	return (node1->val==node2->val) && helper(node1->left, node2->right)
            	&& helper(node1->right, node2->left);
        else return false;
    }
};
2
Hao.D Yen
class isSymmetricalTree
{
public:
    bool isSymmetricalCore(TreeNode* pRoot,TreeNode* spRoot) //递归方法判断左右节点是否满足对称性
    {
        if(pRoot==nullptr && spRoot==nullptr) return true;
        if(pRoot!=nullptr && spRoot!=nullptr && pRoot->val==spRoot->val) //树节点值相等
            //递归，左右节点全满足对称性
            return isSymmetricalCore(pRoot->left,spRoot->right) && isSymmetricalCore(pRoot->right,spRoot->left);
        else
            return false;
    }
    bool isSymmetrical(TreeNode* pRoot)
    {
        if(pRoot==nullptr) return true;
        TreeNode* spRoot=pRoot;
        return isSymmetricalCore(pRoot,spRoot);
    }
};
6
牛客264587号
中序遍历后检查序列是否对称即可
2
夜小楼Dream
#Python 版
#思路： 同时进行中左右 和中右左的遍历，并在遍历的时候比较节点
# -*- coding:utf-8 -*-
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
class Solution:
    def isSymmetrical(self, pRoot):
        if pRoot is None:
            return True
        return self.isSymmetricalCore(pRoot,pRoot)
    def isSymmetricalCore(self, pRoot, pRoot1):
        if pRoot is None and pRoot1 is None:
            return True
        if pRoot is None or pRoot1 is None:
            return False
        if pRoot.val != pRoot1.val :
            return False
        return self.isSymmetricalCore(pRoot.left,pRoot1.right) and self.isSymmetricalCore(pRoot.right,pRoot1.left)
2
老石基
public class Solution {
    boolean isSymmetrical(TreeNode pRoot){
        if(pRoot==null)
            return true;
        return isMirror(pRoot.left,pRoot.right);
    }
    public boolean isMirror(TreeNode left,TreeNode right){
        if(left==null&&right==null)
            return true;
        if((left==null&&right!=null)
           ||(right==null&&left!=null)
           ||(left.val!=right.val)
           ||!(isMirror(left.left,right.right))
           ||!(isMirror(right.left,left.right))
          )
            return false;
        return true;
    }
}
1
WangSH1996
  /* 从上到下递归遍历，比较左右两棵子树，分别错位比较，    即左子树的左节点与右子树的右节点比较，左子树的右节点与右子树的左节点比较  */    class Solution {  public:     bool isSymmetrical(TreeNode* pRoot)     {         return isSymmetrical(pRoot, pRoot);     }     bool isSymmetrical(TreeNode* pRoot, TreeNode* pCompare)     {         if(pRoot == nullptr && pCompare == nullptr)             return true;         if(pRoot && pCompare)         {             if(pRoot->val == pCompare->val)             {                 return (isSymmetrical(pRoot->left, pCompare->right) && \                   isSymmetrical(pRoot->right, pCompare->left));             }         }         return false;     } }; 
1
可爱又迷人的zcc
/**
 * 找出二叉树的下一个结点(中序遍历)
 * @author zzc
 * 核心思路:二叉树遍历顺序 左 中 右
 * 给出任意一个结点，那么它的下一个结点：有可能是右子树的最左结点,
 * 另一种情况如果没有右子树那么下一个结点就是
 * 1.自己是父结点的左孩子，那么下一个遍历结点就是父结点
 * 2.自己是父结点的右孩子，那么下一个遍历结点就不是父结点，同过父指针向上
 *       寻找是父结点左孩子的结点，该结点才是我们要的
 */
public TreeLinkNode GetNext(TreeLinkNode pNode)
    {
        TreeLinkNode nextNode=GetLeft(pNode.right);
        if(pNode.right==null){
            while(pNode.next!=null){
                if(pNode.next.left==pNode){
                    nextNode=pNode.next;
                    break;
                }else if(pNode.next.right==pNode){
                    pNode=pNode.next;
                }
            }            
        }
        return nextNode;       
    }
    public TreeLinkNode GetLeft(TreeLinkNode pNode){
        if(pNode==null){
            return null;
        }
        if(pNode.left!=null){
            return GetLeft(pNode.left); 
        }else{
            return pNode;
        }        
    } 
