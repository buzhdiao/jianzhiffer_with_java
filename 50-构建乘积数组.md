考点    

数组

热点指数    32962
通过率    38.21%
题目    

构建乘积数组


具体题目    给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],其中B中的元素B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]。不能使用除法。
讨论    126
张佃鹏
<分析>： 解释下代码，设有数  
查看全部
404
披萨大叔
  剑指的思路： 
B[i]的值可以看作下图的矩阵中每行的乘积。
  下三角用连乘可以很容求得，上三角，从下向上也是连乘。 
  因此我们的思路就很清晰了，先算下三角中的连乘，即我们先算出B[i]中的一部分，然后倒过来按上三角中的分布规律，把另一部分也乘进去。 
public class Solution {
    public int[] multiply(int[] A) {
        int length = A.length;
        int[] B = new int[length];
        if(length != 0 ){
            B[0] = 1;
            //计算下三角连乘
            for(int i = 1; i < length; i++){
                B[i] = B[i-1] * A[i-1];
            }
            int temp = 1;
            //计算上三角
            for(int j = length-2; j >= 0; j--){
                temp *= A[j+1];
                B[j] *= temp;
            }
        }
		return B;
    }
}
77
L0L
//B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]
//从左到右算 B[i]=A[0]*A[1]*...*A[i-1]
//从右到左算B[i]*=A[i+1]*...*A[n-1] 
class Solution {
public:
    vector<int> multiply(const vector<int>& A) {
    
    	int n=A.size();
    	vector<int> b(n);
    	int ret=1;
    	for(int i=0;i<n;ret*=A[i++]){
    		b[i]=ret;
		}
		ret=1;
		for(int i=n-1;i>=0;ret*=A[i--]){
			b[i]*=ret;
		}
    	return b;
    }
};
54
不是一个响亮的名字
  分两步：1.计算前i - 1个元素的乘积，及后N - i个元素的乘积分别保存在两个数组中。这可以用动态
            规划实现。 
          2.计算B[i]的值。
import java.util.ArrayList;
public class Solution {
    int[] multiply(int[] A) {
        int len = A.length;
        int forword[] = new int[len];
        int backword[] = new int[len];
        int B[] = new int[len];
        forword[0] = 1;
        backword[0] = 1;
        for(int i = 1;i < len; i++){
            forword[i] = A[i - 1]*forword[i-1];
            backword[i] = A[len - i]*backword[i - 1];
        }
        for(int i = 0; i < len; i++){
            B[i] = forword[i] * backword[len - i -1];
        }
        return B;
    }
}
 
14
Python
zkqiang
        思路：按上图把每行被1分割的两部分乘积都计算出来，这样可以从首尾分别用累乘算出两个列表，然后两个列表首尾相乘就是B的元素     # -*- coding:utf-8 -*-
class Solution:
    def multiply(self, A):
        # write code here
        head = [1]
        tail = [1]
        for i in range(len(A)-1):
            head.append(A[i]*head[i])
            tail.append(A[-i-1]*tail[i])
        return [head[j]*tail[-j-1] for j in range(len(head))]
 
9
老石基
  动态规划 
import java.util.ArrayList;
public class Solution {
    public int[] multiply(int[] A) {
        if(A==null||A.length==0)
            return A;
		int[] left = new int[A.length];//记录除了自己，左边的乘积
        int[] right = new int[A.length];//记录除了自己，右边的乘积
        right[A.length-1] = 1;
        for(int i = A.length-2;i>=0;i--){
            right[i] = right[i+1]*A[i+1];
        }
        left[0] = 1;
        for(int i = 1;i<A.length;i++){
            left[i] = left[i-1]*A[i-1];
        }
        int[] B = new int[A.length];
        for(int i = 0;i<A.length;i++){
            B[i] = left[i]*right[i];
        }
        return B;
    }
}
16
nomico271
  很简单。    B[0] = A[1] * A[2] * A[3] * A[4] *....*A[n-1] ;（没有A[0]）    B[1 ]= A[0] * A[2] * A[3] * A[4] *....*A[n-1] ;（没有A[1]）    B[2] = A[0] * A[1] * A[3] * A[4] *....*A[n-1] ;（没有A[2]）    ....    即B[i]项等于A数组所有数的乘积，但是去除A[i]项。由于是乘法，所以直接令A[i]项等于1即可。    代码中加个flag标志做判断即可。  import java.util.ArrayList;
public class Solution {
    public int[] multiply(int[] A) {
		int[] B = new int[A.length];
        boolean changed = false;
        for(int k = 0; k < B.length; k++){
            B[k] = 1;
            for(int i = 0; i < A.length; i++){
                int temp = 1;
                if(i == k){
                    changed = true;
                    temp = A[i];
                    A[i] = 1;
                }
                B[k] *= A[i];
                if(changed){
                    A[i] =temp;
                    changed = false;
                }
            }
            
        }
        return B;
    }
}         
5
此广告位出租
 借助两个数组lefts和rights，一个记录B[i]值的左乘结果A[0]*A[1]*...*A[i-1]，一个记录B[i]值的右乘结果A[i+1]*A[i+2]*...*A[n-1]，然后B[i]=lefts[i]*rights[i];   public class Solution {
    public int[] multiply(int[] A) {
        int len = A.length;
		int[] lefts = new int[len];
		int[] rights = new int[len];
		lefts[0] = lefts[len-1] = rights[0] = rights[len-1] = 1;
		int l = 1;
		int r = 1;
		for (int i=1; i<len; i++){
			lefts[i] = A[i-1]*lefts[i-1];
		}
		
		for (int i=len-2; i>=0; i--){
			rights[i] = A[i+1]*rights[i+1];
		}
		int[] B = new int[len];
		while (len>0){
			len--;
			B[len] = lefts[len]*rights[len];
		}
		return B;
    }
}  
5
夕一啊
  构造c=A，每次算之前把c[i]=1,然后算所有c的乘积给b[i]然后再让c[i]=A[i] ，i++ 
class Solution {
public:
    vector<int> multiply(const vector<int>& A) {
        int n=A.size();
        int k=n;
    	vector<int> b;
        vector<int> c;
        for(int i=0;i<n;i++){
            c.push_back(A[i]);
        }
        for(int i=0;i<n;i++){
            b.push_back(1);
        }
        for(int i=0;i<n;i++){
            c[i]=1;
            k=n;
            for(int j=0;j<n;j++){
                b[i]*=c[j];
            }
            c[i]=A[i];
        }
        return b;
        
    }
};
4
闲逛的蚂蚁
        public static int[] multiply(int[] A) {
		if(A == null){
			return null;
		}
		int len = A.length;
		int[] forword = new int[len];
		int[] back = new int[len];
		int[] B = new int[len];
		forword[0] = 1;
		back[len - 1] = 1;
		for(int i = 1; i < len; i++){
			forword[i] = A[i - 1] * forword[i - 1];
		}
		for(int i = len - 2; i >= 0; i--){
			back[i] = A[i + 1] * back[i + 1];
		}
		for(int i = 0; i < len; i++){
			B[i] = forword[i] * back[i];
		}
		return B;
	}
3
Python
yzdeng
  特别要注意的是list b=list a会改变list a 的值，新的变量和原来的变量实际上指向的是同一个地址，等号连接起来的变量互相影响。 所以要使用copy函数，必须时可以使用deepcopy。  # -*- coding:utf-8 -*-
class Solution:
    def multiply(self, A):
        import copy
        # write code here
        B=[1]*len(A)
        for i in range(len(A)):
            C=copy.copy(A)
            C.pop(i)
            for j in range(len(C)):
                B[i]*=C[j]
        return B
 
3
朱宇宙🏋🏼
# -*- coding:utf-8 -*-
class Solution:
    def multiply(self, A):
        # write code here
        B = []
        for i in range(len(A)):
            temp = A[i]
            b= 1
            for j in range(len(A)):
                A[i] = 1
                b*=A[j]
            B.append(b)
            A[i] = temp
        return B 
3
C/C++
scutlzy
class Solution 
{
public:
    vector<int> multiply(const vector<int>& A) 
    {
     /*   vector<int> B;//直接暴力解决，逐行遍历，然后逐个相乘
        if (!A.empty())
        {
            int n = A.size();
            for (int i = 0; i <= n - 1; i++)
            {     
                int mult = 1;
                for (int j = 0; j <= n - 1; j++)
                {
                    if (j != i)
                        mult *= A[j];
                }
                B.push_back(mult);
            }
        }
        return B;*/
        vector<int> B;//剑指offer思路，总结规律，使用递推公式求解
        if (!A.empty())
        {
            int n = A.size();
            vector<int> C, D;
            B.assign(n, 1);
            C.assign(n, 1);
            D.assign(n, 1);
            if (n > 1)
            {
                C[1] = A[0];
                D[n - 2] = A[n - 1];
            }
            for (int i = 2; i <= n - 1; i++)
                C[i] = C[i - 1] * A[i - 1];  
            for (int i = n - 3; i >= 0; i--)
                D[i] = D[i + 1] * A[i + 1];
            for (int i = 0; i < n; i++)
                B[i] = C[i] * D[i];
        }
        return B;
    }
};
2
Python
我滴个神呀
# -*- coding:utf-8 -*- class Solution:     def multiply(self, A):         # write code here         A1 = [1 for i in A]         A2 = [1 for i in A]         B = [1 for i in A]         for i in range(1,len(A)):             A1[i] = A1[i-1] * A[i-1]         for i in range(len(A)-2,-1,-1):             A2[i] = A2[i+1] * A[i+1]         for i in range(len(A)):             B[i] = A1[i] * A2[i]         return B
2
drdr
class Solution {
public:
    vector<int> multiply(const vector<int>& A) {
        int n = A.size();
    	vector<int> B(n, 1);
        vector<int> C(n, 1);
        vector<int> D(n, 1);
        for(int i = 1; i < n; ++i){
            C[i] = C[i-1]*A[i-1];
            D[i] = D[i-1]*A[n-i];
        }
        for(int i = 0; i < n; ++i)
            B[i] = C[i]*D[n-1-i];
		return B;
    }
}; 
2
忆水寒
class Solution {
public:
    vector<int> multiply(const vector<int>& A) {
       vector<int> vec;
       vec.push_back(1);
       for(int i=1;i<A.size();i++)
       {
           int temp=A[i-1]*vec[i-1];
           vec.push_back(temp);
       }
       int temp=1;
       for(int i=A.size()-2;i>=0;--i)
       {
           temp =temp*A[i+1];
           vec[i]=vec[i]*temp;
       }
        return vec;
    }
};
2
Ron
	/*复杂度O(n)*/
         int[] multiply(int[] A) {
		int length = A.length;
		int[] B = new int[length];
		if(length <= 0)
			return B;
		int[] before = new int[length];
		int[] after = new int[length];
		before[0] = 1;
		after[0] = 1;
		for(int i = 0 ; i < length; i ++){
			if(i > 0)
				before[i] = before[i-1]*A[i-1];
			if(i < length-1)
				after[i+1] = after[i]*A[length-i-1];
		}
		for(int i = 0; i < length; i ++){
			B[i] = before[i]*after[length-i-1];
		}
		return B;
	}
2
鹿鹿鹿
//唔…自觉做得还比较简单，既然不能用除法，就以i为界限分为两部分来计算
class Solution {
public:
    vector<int> multiply(const vector<int>& A) 
    {
        vector<int> B;
        for (unsigned int i=0; i<A.size(); ++i)
        {            
            int Temp1 = 1, Temp2 = 1;
            for (unsigned int k=0; k<i; ++k)
                Temp1 *= A[k];
            for (unsigned int m=i+1; m<A.size(); ++m)
                Temp2 *= A[m];
            B.push_back(Temp1 * Temp2);
        }
        return B;    
    }
};
2
搬一块叫CV的砖
	public:
  vector<int> multiply(const vector<int>& A) {
  	  vector<int> B;
  	  int length = A.size();
      if(length==0)
          return B;
      B.push_back(1);
      for(int i=0;i<length-1;++i)
      {
          B.push_back(B.back()*A[i]);
      }
      int temp = 1;
      for(int i=length-2;i>=0;--i)
      {
          temp *= A[i+1];
          B[i] *=temp;
      }
      return B;
  }
1
Java
秋招拿好offer
public class Solution {
    public int[] multiply(int[] A) {
        if (A.length <= 0 || A == null)
            return null;
        int len = A.length;
        int[] C = new int[len];
        int[] D = new int[len];
        int[] B = new int[len];
        for(int i = 0; i < len; i ++){  //对下三角矩阵
            if(i == 0)
                C[i] = 1;
            else
                C[i] = C[i-1] * A[i-1];
        }
        for(int j = len - 1; j >= 0; j--){  //对上三角矩阵
            if(j == len - 1)
                D[j] = 1;
            else
                D[j] = D[j+1] * A[j+1];
        }
        for (int i = 0; i < len; i++){
            B[i] = C[i]*D[i];
        }
        return B;
    }
}
 
1
菜鸟四号
class Solution {
public:
    vector<int> multiply(const vector<int>& A) {
        vector<int> vec;
        vector<int> result;
        int len=A.size(),i=0,j=0,k=0;
        for(;k<len;k++){
            vec.push_back(A[k]);
        }
        for(;i<len;i++){
            int res=1;
            for(j=0;j<len;j++){
                if(i!=j)
                res*=vec[j];
            }
            result.push_back(res);
        }
        return result;
    }
};
   最开始的版本，直接暴力破解，时间复杂度O(N^2)，并不如意。    然后后面优化了一下：    举个例子，以样例为例：   1 2 3 4 5    1 2 3 4 5    1 2 3 4 5    1 2 3  4 5    1 2 3 4 5    变为如下：   1 2 3 4 5    1 1 3 4 5    1 2 1 3 5    1 2 3 1 5    1 2 3 4 1    我们这里可以构建两个数组，分别保存左下角和右下角每行的乘积，然后两个数组相乘就可以了    代码如下：  class Solution {
public:
    vector<int> multiply(const vector<int>& A) {
        vector<int> vec;
        vector<int> vec1;
        vector<int> vec2;
        int len=A.size(),i=0,num=1,j=len-1,num2=1,k=0;
        for(;i<len;i++){
            if(i!=0)
            num*=A[i-1];
            vec1.push_back(num);
        }
        for(;j>=0;j--){
            if(j!=len-1)
            num2*=A[j+1];
            vec2.push_back(num2);
        }
        for(;k<len;k++) vec.push_back(vec1[k]*vec2[len-k-1]);
        return vec;
    }
};
 这样，就从O(N^2)的复杂度变为了O(N)
