考点    

代码的完整性

热点指数    79138
通过率    31.19%
题目    

数值的整数次方


具体题目    给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。
讨论    359
nailperry
 /** * 1.全面考察指数  
查看全部
21
C/C++
吴鹏_2016
  这个题的难点在于把所有情况都理清楚，并且做到非常的直观。              class Solution {
    double power(double base, int exp) {
        if (exp == 1) return base;
        if ((exp & 1) == 0) {
            int tmp = power(base, exp >> 1);
            return tmp * tmp;
        } else {
            int tmp = power(base, (exp - 1) >> 1);
            return tmp * tmp * base;
        }
    }
public:
    double Power(double base, int exp) {
        if (base == 0) {
            if (exp > 0) return 0;
            else if (exp == 0) return 0;
            else throw invalid_argument("Invalid input!");
        } else {
            if (exp > 0) return power(base, exp);
            else if (exp == 0) return 1;
            else return 1 / power(base, -exp);
        }
    }
}; 
140
马客(Mark)
  简单快速幂 
class Solution {
public:
    double Power(double base, int exponent) {
        long long p = abs((long long)exponent);
    	double r = 1.0;
        while(p){
            if(p & 1) r *= base;
            base *= base;
            p >>= 1;
        }
        return exponent < 0 ? 1/ r : r;
    }
};
61
猫丫
java 实现
传统公式求解时间复杂度O(n)
public class Solution {
    public double Power(double base, int exponent) {
        double  result=1;
        for(int i=0;i<Math.abs(exponent);i++){
            result*=base;
        }
        if(exponent<0){
            result=1/result;
        }
        return result;             
  }
} 
递归：n为偶数，a^n=a^n/2*a^n/2;n为奇数，a^n=（a^（n-1）/2）*（a^（n-1/2））*a
时间复杂度O（logn） public class Solution {
    public double Power(double base, int exponent) {
        int n=Math.abs(exponent);
        if(n==0)
            return 1;
        if(n==1)
            return base;
        double  result=Power(base,n>>1);
        result*=result;
        if((n&1)==1)
            result*=base; 
        if(exponent<0)
            result=1/result;
        return result;             
  }
}
结合各位道友的意见，二刷如下
public class Solution {
    public double Power(double base, int exponent) { 
        if(exponent==0 && base != 0)
            return 1;
        if(exponent==1)
            return base;
        if(base == 0 && exponent <= 0){
            throw new RuntimeException();
        }
        if(base ==0 && exponent>0){ 
            return 0;
        }
        int n= exponent;
        if(exponent<0){
            n = -exponent;
        }
        double  result=Power(base,n>>1);
        result*=result;
        if((n&1)==1)
            result*=base; 
        if(exponent<0)
            result=1/result;
        return result;     
  }
}
 
29
Python
华科平凡
  python one line solution:  # -*- coding:utf-8 -*-
class Solution:
    def Power(self, base, exponent):
        # write code here
        return base**exponent
22
曾~
/*剑指书中细节：
*1.当底数为0且指数<0时
*会出现对0求倒数的情况，需进行错误处理，设置一个全局变量；
*2.判断底数是否等于0
*由于base为double型，不能直接用==判断
*3.优化求幂函数
*当n为偶数，a^n =（a^n/2）*（a^n/2） 
*当n为奇数，a^n = a^[(n-1)/2] * a^[(n-1)/2] * a 
*时间复杂度O(logn)
*/
public class Solution {  
      boolean invalidInput=false;     
      public double Power(double base, int exponent) {      
        if(equal(base,0.0)&&exponent<0){
            invalidInput=true;
            return 0.0;
        }
        int absexponent=exponent;
        if(exponent<0)
            absexponent=-exponent;
        double res=getPower(base,absexponent);
        if(exponent<0)
            res=1.0/res;
        return res;
  }
    boolean equal(double num1,double num2){
        if(num1-num2>-0.000001&&num1-num2<0.000001)
            return true;
        else
            return false;
    }
    double getPower(double b,int e){
        if(e==0)
            return 1.0;
        if(e==1)
            return b;
        double result=getPower(b,e>>1);
        result*=result;
        if((e&1)==1)
            result*=b;
        return result;
    }
} 
21
Python
牛客104285号
  python # -*- coding:utf-8 -*-
class Solution:
    def Power(self, base, exponent):
        result = 1
        if base == 0:
            return 0
        if exponent == 0:
            return 1
        if exponent < 0:
            for i in range(-exponent):
                result = result * base
            return 1/result
        for i in range(exponent):
            result = result * base
        return result
  上面的很简单，没有使用快速幂算法，下面使用一下快速幂算法，快速幂算法参考下面的博客 https://blog.csdn.net/hkdgjqr/article/details/5381028     def fast_power(self, base, exponent):
        if base == 0:
            return 0 
        if exponent == 0:
            return 1
        e = abs(exponent)
        tmp = base
        res = 1
        while(e > 0):
            #如果最后一位为1，那么给res乘上这一位的结果
            if (e & 1 == 1):
                res =res * tmp
            e = e >> 1
            tmp = tmp * tmp
        return res if exponent > 0 else 1/res
 
11
小魏子
double Power(double base, int exponent) {
    double res = 1.0;
    if (base == 0)
        return 0;
    if (exponent == 0)
        return 1;
    if (exponent < 0)
        base = 1.0 / base;
    while (exponent){
        res *= base;
        exponent = (exponent>0) ? (--exponent) : (++exponent);
    }
    return res;
}
 
16
Java
FantasyLin
【分析】
  第一种方法：使用递归，时间复杂度O(logn) 
当n为偶数，a^n =（a^n/2）*（a^n/2）
当n为奇数，a^n = a^[(n-1)/2] * a^[(n-1)/2] * a
  举例： 
2^11 = 2^1 * 2^2 * 2^8
2^1011 = 2^0001 * 2^0010 * 2^1000
  第二种方法：累乘，时间复杂度为O(n) 
【参考代码】
package javaTest;
public class JavaTest {
    public static void main(String[] args) {
    	System.out.println(power(3, 3));
    	System.out.println(powerAnother(3, 3));
    }
    // 使用递归
    public static double power(double base, int exponent) {
    	int n = Math.abs(exponent);
    	double result = 0.0;
    	if (n == 0)
    		return 1.0;
    	if (n == 1)
    		return base;
    	
    	result = power(base, n >> 1);
    	result *= result;
    	if ((n & 1) == 1) // 如果指数n为奇数，则要再乘一次底数base
    		result *= base;
    	if (exponent < 0) // 如果指数为负数，则应该求result的倒数
    		result = 1 / result;
    	
    	return result;
    }
    // 使用累乘
    public static double powerAnother(double base, int exponent) {
    	double result = 1.0;
    	for (int i = 0; i < Math.abs(exponent); i++) {
    		result *= base;
    	}
    	if (exponent >= 0)
    		return result;
    	else
    		return 1 / result;
    }
    
}
16
吾生有你
public class Solution {
    public double Power(double base, int exponent) {
        return Math.pow(base, exponent);
  } 
}
 我是众大神中一颗随风飘扬的小草
6
offer给我，我要回家
  两种解法：1.快速幂 2. 递归  //    1.快速幂
   public double Power(double base, int exponent) {
        if (exponent == 0) {
            return 1.0;
        }
        if (base - 0.0 == 0.00001 || base - 0.0 == -0.00001)  {
            if (exponent < 0) {
                throw new RuntimeException("除0异常"); 
            }else{
                return 0.0;
            }
        }
        int e = exponent > 0 ? exponent: -exponent;
        double res = 1;
        while (e != 0) {
            res = (e & 1) != 0 ? res * base : res;
            base *= base;
            e = e >> 1;
        }
        return exponent > 0 ? res : 1/res;
  }
//    2.递归
    public double Power(double base, int exponent) {
        if (exponent == 0) {
            return 1.0;
        }
        if (base - 0.0 == 0.00001 || base - 0.0 == -0.00001)  {
            if (exponent < 0) {
                throw new RuntimeException("除0异常"); 
            }else{
                return 0.0;
            }
        }
        return exponent > 0 ? getPower(base, exponent) : 1/getPower(base, -exponent);
    }
    
    public static double getPower(double base, int e) {
        if (e == 1) {
            return base;
        }
        double halfPower = getPower(base, e >> 1);
        return (e & 1) != 0 ? base * halfPower * halfPower : halfPower * halfPower;
    }
 
6
lijian430421
  0^0 和 0^(-4) 在到底是如何定义的？ wiki百科：0的0次幂和0的负次幂在数学是都是没有定义的。 已无力吐槽……
8
datong
class Solution {
public:
    double Power(double base, int exponent) {
        
        if(exponent == 0) return 1;
        if(base == 0) return 0;
        if(exponent == 1) 
    		return base;
        else if(exponent == -1)
            return 1/base;
        return Power(base,exponent/2) * Power(base,exponent/2) * Power(base,exponent%2);
    }
};
 exponent == 0 而 base 也 == 0 时竟然返回1，醉了
9
桩白墨
# -*- coding:utf-8 -*-
class Solution:
    def Power(self, base, exponent):
        # write code here
        return base ** exponent
3
『FinalFantasy〗
用递归来处理很简单，主要注意的是分为两种情况来讨论，一种是指数exponent>=0的情况，一种是exponent<0的情况，后者只需要简单的处理下，让其变为倒数就可以了，代码如下： class Solution{
    public double Power(double base, int exponent) {
        double res=0;
        if (exponent>=0)
        res=way(base,exponent);
        else {
            res=way(base,-exponent);
            res=1/res;
        }
        return res;
    }
    private double way(double base,int n){
        if (n==0)
            return 1;
        else
            return base*way(base,n-1);
    }
}
3
ShiLongfei
难道只有我一个是Math.pow()吗？
3
专业维修电脑
public class Solution {
    public double Power(double base, int exponent) {
        
       //  return Math.pow(base,exponent);
        
      double result=0.0; 
    	
        if(base==0&&exponent<0){
            return 0.0;
        }
        if(exponent>=0){
           result = zhengshu(base,exponent);
        }else{
        	result = 1.0/zhengshu(base,-exponent);
        }     
         return result;  
  }
    
    
       public static double zhengshu(double base, int exponent){
    	
        if(exponent==0){
            return 1;
        }
        if(exponent==1){
            return base;
        }
        
        double r=zhengshu(base,exponent>>1);
        r*=r;
        if((exponent&1)==1){
            r*=base;
        } 
        
    	return r;
    }
}
13
root0
  不知道这样对不对？ 
  public class Solution {     public double Power(double base,
  int exponent) {         return Math.pow(base,exponent);  
  } } 
13
CF_浩哥
return Math.pow(base,exponent);
24
菩提旭光
最佳答案，没有之一。java代码，已经运行通过所有测试用例。思路如下：还是那句老话，算法的本质就是模拟数学规律，我们可以先模拟一下幂运算就是乘法的连乘，那么用算法写出来，然后再考虑几个测试用例的极端情况，如exponent==0或者exponent<0的情况，然后按逻辑写出你的代码就好了，不要把他想的有多难，羞愧是负能量最高的能量场。
   public class Solution {  
       public double Power(double base, int exponent) {  
           if(exponent == 0){  
               return 1;  
           }else if(exponent > 0){  
               double num = base;  
               for(int i = 1; i < exponent; i++){  
                   num = num * base;  
               }  
               return num;  
           }else {  
               double nums = base;  
               int flag = -exponent;  
               for(int i = 1; i < flag; i++){  
                   nums = nums * base;  
               }  
               return 1/nums;  
           }  
     }  
   }  
2
毛爷爷👴
  主要考查两个基础点：    1、分类讨论的思想；    2、基本数据类型取值范围。 
