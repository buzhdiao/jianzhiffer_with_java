### 题目    旋转数组的最小数字

考点    查找和排序	热点指数    89987	通过率    31.97%

#### 具体题目 

   把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。  输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。  NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。


 
  /*把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。*/ 
  根据题意说明是一个递增数组的旋转，所以如题所示【3,4,5】，【1,2】还是局部递增的，在这种的数组中查找，一般选择二分的方法；基本模型有了，下面试着分析： 
  1.先取出中间的数值，和最后一个比较5>2 说明mid之前的某些部分旋转到了后面，所以下次寻找 low = mid+1
  开始； 
  2.取出的中间值要是小于high，说明mid-high之间都应为被旋转的部分，所以最小应该在mid的前面，但是也有可能当前的mid
  就是最小的值 所以下次需找的应该 从mid开始，也即high = mid 开始 
  3.当*mid == *high的时候，说明数组中存在着相等的数值，可能是这样的形式
  【2,2,2,2,1,2】所以应该选择的high 应该递减1 作为下次寻找的上界。 
参考代码如下：
  int minNumberInRotateArray(vector<int> rotateArray) {  
    size_t len = rotateArray.size();
    if(len == 0)
        return 0;
    if(len == 1)
        return rotateArray[0];
    vector<int>::iterator low = rotateArray.begin();
    vector<int>::iterator mid;
    vector<int>::iterator high = rotateArray.end()-1;
    while(low <= high)
    {
        //防止迭代器失效
        mid = low + (high - low)/2;
        if(*mid >*high)
        {
            low = mid + 1;
        }
        else if(*mid < *high)
        {
            high = mid;
        }
        else
        {
            high = high-1;
        }
        if(low >= high)
        {
            break;
        }
    }
        return *low;
    }  
11
writezen
public class Solution {
 /*
 * 传进去旋转数组，注意旋转数组的特性：
 * 1.包含两个有序序列
 * 2.最小数一定位于第二个序列的开头
 * 3.前序列的值都>=后序列的值
 * 定义把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
 * ^_^这个旋转思想是很经典的
 * 旋转数组实例：
 * {123456}旋转后{456123}
 */

 //用到了快速排序的快速定位范围的思想，
 public int minNumberInRotateArray(int [] array) {
 if(array==null||array.length==0){  return 0;
 }
 int low=0;
 int up=array.length-1;
 int mid=low;

 // 当low和up两个指针相邻时候，就找到了最小值，也就是
 //右边序列的第一个值

 while(array[low]>=array[up]){
 if(up-low==1){
 mid=up;
 break;
 }
 //如果low、up、mid下标所指的值恰巧相等
 //如：{0,1,1,1,1}的旋转数组{1,1,1,0,1}
 if(array[low]==array[up]&&array[mid]==array[low])
 return MinInOrder(array);
    mid=(low+up)/2;
 //这种情况，array[mid]仍然在左边序列中
 if(array[mid]>=array[low])
 low=mid;//注意，不能写成low=mid+1；
 //要是这种情况，array[mid]仍然在右边序列中
 else if(array[mid]<=array[up])
 up=mid;
 }

 return array[mid];
    
    }
 private int MinInOrder(int[] array) {
 // TODO Auto-generated method stub
 int min =array[0];
 for(int i=1;i<array.length;i++){
 if(array[i]<min){
 min=array[i];

 }
 }
 return min;
 }
 public static void main(String[] args) {

 }
}
16
Python
华科平凡
python solution: # -*- coding:utf-8 -*-
class Solution:
    def minNumberInRotateArray(self, rotateArray):
        # write code here
        return min(rotateArray)
9
fuyufjh
  前方大坑！！ 
  rotateArray.size() == 0时候返回一个0 
  这个设定极其不合理，无法区分是min=0还是出错了 
  递归代码： 
class Solution {
    int findMin(vector<int> a, int first, int last) {
        if (first >= last) return a[last];
        int mid = (first + last) / 2;
        if (a[first] == a[last] && a[mid] == a[first]) {
            // linear search
            int min = a[first];
            for (int i = first + 1; i <= last; i++)
                min = a[i]<min ? a[i] : min;
            return min;
        }
        if (a[first] < a[last]) {
            return a[first];
        } else {
            if (a[mid] >= a[first]) {
                return findMin(a, mid + 1, last);
            } else {
                return findMin(a, first, mid);
            }
        }
    }

public:
    int minNumberInRotateArray(vector<int> rotateArray) {
        int n = rotateArray.size();
        if (n == 0) return 0;
        return findMin(rotateArray, 0, n - 1);
    }
};
  循环代码： 
class Solution {  
public:
    int minNumberInRotateArray(vector<int> array) {
        if (array.size() == 0) return 0;
        int first = 0, last = array.size() - 1;
        int mid = (first + last) / 2;
        while (array[first] >= array[last]) {
            if (last - first == 1) return array[last];
            if (array[first] == array[mid] && array[mid] == array[last]) {
                // linear search
                int min = array[first];
                for (int i = first + 1; i <= last; i++)
                    min = array[i]<min ? array[i] : min;
                return min;
            }
             
            if (array[first] <= array[mid]) first = mid;
            else last = mid;
            mid = (first + last) / 2;
        }
        return array[first];
    }
};
3
JacobGo！
package go.jacob.day0827.剑指offer系列;
public class 旋转数组的最小数字 {
    public int minNumberInRotateArray(int[] array) {
        if (array == null || array.length == 0) {
            return -1;
        }
        int len = array.length;
        int index1 = 0;
        int index2 = len - 1;
        int indexMid = index1;
        while (array[index1] >= array[index2]) {
            if (index1 == index2 - 1) {
                indexMid = index2;
                break;
            }
            indexMid = index1 + (index2 - index1) / 2;
            if (array[index1] <= array[indexMid]) {
                index1 = indexMid;
            } else if (array[indexMid] <= array[index2]) {
                index2 = indexMid;
            }
        }
        return array[indexMid];
    }
}
	

3
fengvs
  其实就是二分查找，查找时分两种情况：    1、array[m] > array[r]：说明旋转后最小值在右区间   2、array[m] < array[r]：说明旋转后最小值在左区间   （l、r是待查找区间边界，m是区间中间位置）        class Solution {  public:     int minNumberInRotateArray(vector<int> array) {         //二分查找         if(array.size()==0){             return 0;         }         int l=0, r=array.size()-1;         while(l<r){             int m = (l+r)>>1;             if(array[m] > array[r]){                 l = m+1;             }else{                 r = m;             }         }         return array[l];     } };
5
fleeorfight
# -*- coding:utf-8 -*-
class Solution:
    def minNumberInRotateArray(self, rotateArray):
        # write code here
        for i in range(len(rotateArray)):
            if rotateArray[i+1] < rotateArray[i]:
                return rotateArray[i+1]
        return 0

5
碗碗
我这个代码感觉挺简单的，测试通过。求大家挑挑毛病
class Solution {
public:
    int minNumberInRotateArray(vector<int> rotateArray) {
        if(rotateArray.size()==0){
            return 0;
        }
        int min = rotateArray[0];
        for(int i=1;i<rotateArray.size();i++){
            if(rotateArray[i]<min){
                min = rotateArray[i];
                break;
            }
        }
        return min;
    }
};
4
董可伦
import java.util.ArrayList;
public class Solution {
    public int minNumberInRotateArray(int [] array) {
        if(array.length == 0)
			return 0;
        int i = 0;
		while (i < array.length - 1 && array[i] <= array[++i])
			;
		return i == array.length - 1 ? array[0] : array[i];
    }
}
我的思路是：首先数组长度为零时，返回零，因为测试要求这样。然后有一个特殊情况是没有旋转，那么返回array[0],其次一般情况while一直循环，知道后面的数 < 前面的数停止，这个数就是我们要找的。
4
闭关写代码
  import java.util.ArrayList; 
  public class Solution { 
      public int minNumberInRotateArray(int [] array) { 
      if (array != null && array.length >
  0) { 
int index1 = 0; 
int index2 = array.length - 1; 
int indexMid = index1; 
while (index1 <= index2) { 
indexMid = (index1 + index2) / 2; 
if (array[indexMid] == array[index2] 
&& array[index1] == array[index2]) { 
int min = array[0]; 
for (int i = 1; i < array.length; i++) { 
if (min > array[i]) { 
min = array[i]; 
} 
} 
return min; 
} 
else if (array[indexMid] > array[index1]) { 
index1 = indexMid; 
} else { 
index2 = indexMid; 
} 
} 
return indexMid; 
} else { 
return 0; 
} 
      } 
----------------------------------
import java.util.ArrayList;
public class Solution {
    public int minNumberInRotateArray(int [] array) {
        if(array.length==0)
            return 0;
        else 
            return partition(array,0,array.length-1);
    }
    //递归的目的是寻找乱序的子数组
    private int partition(int [] array,int start,int end){
        if( array[start] < array[end] || start == end )  //如果第一个元素小于最后一个元素，说明数组从头到尾都是非减的；如果只剩下一个元素，则直接返回
            return array[start];
        else {
            int mid=start+(end-start)/2;
            if( array[mid] < array[end]){    //如果中间值下于最后的值，说明后半部分为非减序列，所以在前半部分继续寻找；
                               //另外，之所以是mid而不是mid-1，是为了防止出现越界的情况,例如，array=[3,4],那么start=0，mid=0,end=1; (mid-1)等于-1,不可行
                return partition(array,start,mid);
            }else if(array[mid] == array[end]){    // 如果array=[1,0,1,1,1]或者[1,1,1,0,1]，那没办法判断乱序子数组的位置，所以只能削减一步
                return partition(array,start,end-1);
            }else{                //如果中间值大于最后值，那么说明乱序的部分在后半段，所以在后半段寻找。可以使用mid+1是因为，中间值都比最后值大了，那还要它干嘛？
                return partition(array,mid+1,end);
            }
        }
    }
}
