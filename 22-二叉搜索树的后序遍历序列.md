#### 题目    二叉搜索树的后序遍历序列

考点    举例让抽象具体化	热点指数    54280	通过率    23.53%

#### 具体题目    

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。


  采用分治法的思想，找到根结点、左子树的序列、右子树的序列，分别判断左右子序列是否为二叉树的后序序列。 
  由题意可得： 
  1. 后序遍历序列的最后一个元素为二叉树的根节点； 
  2. 二叉搜索树左子树上所有的结点均小于根结点、右子树所有的结点均大于根结点。 
    算法步骤如下： 
  1. 找到根结点； 
  2. 遍历序列，找到第一个大于等于根结点的元素i，则i左侧为左子树、i右侧为右子树； 
    3.
    我们已经知道i左侧所有元素均小于根结点，那么再依次遍历右侧，看是否所有元素均大于根结点；若出现小于根结点的元素，则直接返回false；若右侧全都大于根结点，则： 
  4. 分别递归判断左/右子序列是否为后序序列； 
public boolean VerifySquenceOfBST(int [] sequence) {
    if ( sequence==null || sequence.length<=0 ) return false;
    return VerifySquenceOfBST(sequence, 0, sequence.length-1);
}
private boolean VerifySquenceOfBST(int [] sequence, int start, int end){
    if ( start>=end ) 
        return true;
    
    int root = sequence[end];
    
    int i=start;
    while( sequence[i] < root ){
        i++;
    }
    
    int j=i;
    while( j<end ){
        if ( sequence[j]<root ) {
            return false;
        }
        j++;
    }
    
    boolean left = VerifySquenceOfBST(sequence, start, i-1);
    boolean right = VerifySquenceOfBST(sequence, i, end-1);
    return left && right;
}

/**
 * T: 二叉搜索树的后序遍历序列
 * 
 * 题目描述 
 * 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。
 * 如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。
 * 
 * date: 2015.11.28  10:43
 * @author SSS
 *
 */
public class Solution {
    public boolean VerifySquenceOfBST(int [] sequence) {
		if (sequence == null || sequence.length == 0) {
			return false;
		}
		
        boolean flag = this.isBST(sequence, 0, sequence.length - 1);
        
        return flag;
    }
	
	/**
	 * 递归实现检测
	 * 
	 * 对于后序遍历来说，序列数组的最后一个元素一定是根节点,
	 * 则根据这个元素，将前面的数组分为左、右两个部分，左侧部分都小，右侧部分都大，
	 * 如果右侧部分有比该根节点小的元素，那么就不是后序遍历,如此递归进行
	 * @param arr
	 * @param start
	 * @param end
	 * @return
	 */
	public boolean isBST(int []arr, int start, int end) {
		if (start >= end) {
			return true;
		}
		
		// 当前数组(从start到end部分)的根节点
		int curElement = arr[end];
		int splitIndex;
		// 找到比curElement大和比curElement小的分界点,分成左侧、右侧两组数据
		for(splitIndex = start; splitIndex < end && arr[splitIndex] < curElement;splitIndex ++);
		
		// 只需要看右侧即可，因为前面的for循环，已经确保左侧部分全部都小于curElement
		for (int i = splitIndex; i < end; i++) {
			if (arr[i] < curElement) {
				return false;
			}
		}
		
		return isBST(arr, start, splitIndex - 1) && isBST(arr, splitIndex, end - 1);
	}
}

  以[4, 8, 6, 12, 16, 14, 10]为例，首先最右边的元素10为根，然后从后往前找到大于根的一个连续序列[12, 16, 14]（即右子树），为了区分左右子树，这个查找过程是必须的。但没必要遍历左子树，因为我们可以在递归函数中加一个参数来记录根的值，以限制左子树部分的上限，这样每次可以减少一半的遍历。为什么不用限制它的右子树的下限呢？因为我们在上述找右子树的过程中已经保证了右子树中的结点都大于根。   public class Solution {
    public boolean VerifySquenceOfBST(int [] sequence) {
        if (sequence == null || sequence.length == 0) {
            return false;
        }
        return valid(sequence, 0, sequence.length-1, 0x7fffffff);
    }
    
    private boolean valid(int[] sequence, int start, int end, int max) {
        if (start > end) {
            return true;
        }
        int root = sequence[end];
        if (root > max) {
            return false;
        }
        int i = end;
        for (; i - 1 >= start && sequence[i - 1] > root; i--);
        return valid(sequence, start, i-1, root) && valid(sequence, i, end-1, max);
    }
}  
