è€ƒç‚¹    

ä»£ç çš„é²æ£’æ€§

çƒ­ç‚¹æŒ‡æ•°    64057
é€šè¿‡ç‡    23.05%
é¢˜ç›®    

æ ‘çš„å­ç»“æ„


å…·ä½“é¢˜ç›®    è¾“å…¥ä¸¤æ£µäºŒå‰æ ‘Aï¼ŒBï¼Œåˆ¤æ–­Bæ˜¯ä¸æ˜¯Açš„å­ç»“æ„ã€‚ï¼ˆpsï¼šæˆ‘ä»¬çº¦å®šç©ºæ ‘ä¸æ˜¯ä»»æ„ä¸€ä¸ªæ ‘çš„å­ç»“æ„ï¼‰
è®¨è®º    385
Boooobby
public class Solution {
    public static boolean HasSubtree(TreeNode root1, TreeNode root2) {
		boolean result = false;
		//å½“Tree1å’ŒTree2éƒ½ä¸ä¸ºé›¶çš„æ—¶å€™ï¼Œæ‰è¿›è¡Œæ¯”è¾ƒã€‚å¦åˆ™ç›´æ¥è¿”å›false
		if (root2 != null && root1 != null) {
			//å¦‚æœæ‰¾åˆ°äº†å¯¹åº”Tree2çš„æ ¹èŠ‚ç‚¹çš„ç‚¹
			if(root1.val == root2.val){
				//ä»¥è¿™ä¸ªæ ¹èŠ‚ç‚¹ä¸ºä¸ºèµ·ç‚¹åˆ¤æ–­æ˜¯å¦åŒ…å«Tree2
				result = doesTree1HaveTree2(root1,root2);
			}
			//å¦‚æœæ‰¾ä¸åˆ°ï¼Œé‚£ä¹ˆå°±å†å»rootçš„å·¦å„¿å­å½“ä½œèµ·ç‚¹ï¼Œå»åˆ¤æ–­æ—¶å€™åŒ…å«Tree2
			if (!result) {
				result = HasSubtree(root1.left,root2);
			}
			
			//å¦‚æœè¿˜æ‰¾ä¸åˆ°ï¼Œé‚£ä¹ˆå°±å†å»rootçš„å³å„¿å­å½“ä½œèµ·ç‚¹ï¼Œå»åˆ¤æ–­æ—¶å€™åŒ…å«Tree2
			if (!result) {
				result = HasSubtree(root1.right,root2);
			   }
			}
		    //è¿”å›ç»“æœ
		return result;
	}
	public static boolean doesTree1HaveTree2(TreeNode node1, TreeNode node2) {
		//å¦‚æœTree2å·²ç»éå†å®Œäº†éƒ½èƒ½å¯¹åº”çš„ä¸Šï¼Œè¿”å›true
		if (node2 == null) {
			return true;
		}
		//å¦‚æœTree2è¿˜æ²¡æœ‰éå†å®Œï¼ŒTree1å´éå†å®Œäº†ã€‚è¿”å›false
		if (node1 == null) {
			return false;
		}
		//å¦‚æœå…¶ä¸­æœ‰ä¸€ä¸ªç‚¹æ²¡æœ‰å¯¹åº”ä¸Šï¼Œè¿”å›false
    	if (node1.val != node2.val) {	
				return false;
		}
    	
    	//å¦‚æœæ ¹èŠ‚ç‚¹å¯¹åº”çš„ä¸Šï¼Œé‚£ä¹ˆå°±åˆ†åˆ«å»å­èŠ‚ç‚¹é‡Œé¢åŒ¹é…
    	return doesTree1HaveTree2(node1.left,node2.left) && doesTree1HaveTree2(node1.right,node2.right);
    }
420
fuyufjh
  åˆ©ç”¨å¥½çŸ­è·¯ç‰¹æ€§ï¼Œå®Œå…¨ä¸ç”¨é‚£ä¹ˆå¤šflag 
class Solution {
    bool isSubtree(TreeNode* pRootA, TreeNode* pRootB) {
        if (pRootB == NULL) return true;
        if (pRootA == NULL) return false;
        if (pRootB->val == pRootA->val) {
            return isSubtree(pRootA->left, pRootB->left)
                && isSubtree(pRootA->right, pRootB->right);
        } else return false;
    }
public:
    bool HasSubtree(TreeNode* pRootA, TreeNode* pRootB)
    {
        if (pRootA == NULL || pRootB == NULL) return false;
        return isSubtree(pRootA, pRootB) ||
            HasSubtree(pRootA->left, pRootB) ||
            HasSubtree(pRootA->right, pRootB);
    }
};
38
Python
è°è¯´å·¥ä½œäº†å°±ä¸è¦åˆ·é¢˜
  å…ˆè¯´ä¸‹ç®—æ³•å®ç°æ€è·¯ï¼šå¯¹äºä¸¤æ£µäºŒå‰æ ‘æ¥è¯´ï¼Œè¦åˆ¤æ–­Bæ˜¯ä¸æ˜¯Açš„å­ç»“æ„ï¼Œé¦–å…ˆç¬¬ä¸€æ­¥åœ¨æ ‘Aä¸­æŸ¥æ‰¾ä¸Bæ ¹èŠ‚ç‚¹çš„å€¼ä¸€æ ·çš„èŠ‚ç‚¹ã€‚ 
  é€šå¸¸å¯¹äºæŸ¥æ‰¾æ ‘ä¸­æŸä¸€ä¸ªèŠ‚ç‚¹ï¼Œæˆ‘ä»¬éƒ½æ˜¯é‡‡ç”¨é€’å½’çš„æ–¹æ³•æ¥éå†æ•´æ£µæ ‘ã€‚ 
  ç¬¬äºŒæ­¥å°±æ˜¯åˆ¤æ–­æ ‘Aä¸­ä»¥Rä¸ºæ ¹èŠ‚ç‚¹çš„å­æ ‘æ˜¯ä¸æ˜¯å’Œæ ‘Bå…·æœ‰ç›¸åŒçš„ç»“æ„ã€‚ 
  è¿™é‡ŒåŒæ ·åˆ©ç”¨åˆ°äº†é€’å½’çš„æ–¹æ³•ï¼Œå¦‚æœèŠ‚ç‚¹Rçš„å€¼å’Œæ ‘çš„æ ¹èŠ‚ç‚¹ä¸ç›¸åŒï¼Œåˆ™ä»¥Rä¸ºæ ¹èŠ‚ç‚¹çš„å­æ ‘å’Œæ ‘Bè‚¯å®šä¸å…·æœ‰ç›¸åŒçš„èŠ‚ç‚¹ï¼› 
  å¦‚æœå®ƒä»¬å€¼æ˜¯ç›¸åŒçš„ï¼Œåˆ™é€’å½’çš„åˆ¤æ–­å„è‡ªçš„å·¦å³èŠ‚ç‚¹çš„å€¼æ˜¯ä¸æ˜¯ç›¸åŒã€‚ 
  é€’å½’çš„ç»ˆæ­¢æ¡ä»¶æ˜¯æˆ‘ä»¬è¾¾åˆ°äº†æ ‘Aæˆ–è€…æ ‘Bçš„å¶èŠ‚ç‚¹ã€‚ 
  æœ‰åœ°æ–¹è¦é‡ç‚¹æ³¨æ„ï¼ŒDoesTree1haveTree2()å‡½æ•°ä¸­çš„ä¸¤ä¸ª if åˆ¤æ–­è¯­å¥
ä¸èƒ½é¢ å€’é¡ºåº
ã€‚ 
  å› ä¸ºå¦‚æœé¢ å€’äº†é¡ºåºï¼Œä¼šå…ˆåˆ¤æ–­pRoot1 æ˜¯å¦ä¸ºNone, å…¶å®è¿™ä¸ªæ—¶å€™ï¼ŒpRoot1
  çš„èŠ‚ç‚¹å·²ç»éå†å®Œæˆç¡®è®¤ç›¸ç­‰äº†ï¼Œä½†æ˜¯è¿™ä¸ªæ—¶å€™ä¼šè¿”å› Falseï¼Œåˆ¤æ–­é”™è¯¯ã€‚ 
  æœ‰åŒå­¦ä¸ç›¸ä¿¡çš„ï¼Œå¯ä»¥å»è¯•è¯•æ¢ä¸ªé¡ºåºï¼Œè‚¯å®šä¸èƒ½ACã€‚åŒæ—¶è¿™ä¸ªä¹Ÿæ˜¯ã€Šå‰‘æŒ‡offerã€‹ä¹¦ä¸Šæ²¡æœ‰å†™çš„ï¼Œå¸Œæœ›èƒ½å¼•èµ·å¤§å®¶çš„æ³¨æ„ã€‚ 
# -*- coding:utf-8 -*-
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    def HasSubtree(self, pRoot1, pRoot2):
        # write code here
        result = False
        if pRoot1 != None and pRoot2 != None:
            if pRoot1.val == pRoot2.val:
                result = self.DoesTree1haveTree2(pRoot1, pRoot2)
            if not result:
                result = self.HasSubtree(pRoot1.left, pRoot2)
            if not result:
                result = self.HasSubtree(pRoot1.right, pRoot2)
        return result
    # ç”¨äºé€’å½’åˆ¤æ–­æ ‘çš„æ¯ä¸ªèŠ‚ç‚¹æ˜¯å¦ç›¸åŒ
    # éœ€è¦æ³¨æ„çš„åœ°æ–¹æ˜¯: å‰ä¸¤ä¸ªifè¯­å¥ä¸å¯ä»¥é¢ å€’é¡ºåº
    # å¦‚æœé¢ å€’é¡ºåº, ä¼šå…ˆåˆ¤æ–­pRoot1æ˜¯å¦ä¸ºNone, å…¶å®è¿™ä¸ªæ—¶å€™pRoot2çš„ç»“ç‚¹å·²ç»éå†å®Œæˆç¡®å®šç›¸ç­‰äº†, ä½†æ˜¯è¿”å›äº†False, åˆ¤æ–­é”™è¯¯
    def DoesTree1haveTree2(self, pRoot1, pRoot2):
        if pRoot2 == None:
            return True
        if pRoot1 == None:
            return False
        if pRoot1.val != pRoot2.val:
            return False
        return self.DoesTree1haveTree2(pRoot1.left, pRoot2.left) and self.DoesTree1haveTree2(pRoot1.right, pRoot2.right)
112
v54vYoung
/*æ€è·¯ï¼šå‚è€ƒå‰‘æŒ‡offer
1ã€é¦–å…ˆè®¾ç½®æ ‡å¿—ä½result = falseï¼Œå› ä¸ºä¸€æ—¦åŒ¹é…æˆåŠŸresultå°±è®¾ä¸ºtrueï¼Œ
å‰©ä¸‹çš„ä»£ç ä¸ä¼šæ‰§è¡Œï¼Œå¦‚æœåŒ¹é…ä¸æˆåŠŸï¼Œé»˜è®¤è¿”å›false
2ã€é€’å½’æ€æƒ³ï¼Œå¦‚æœæ ¹èŠ‚ç‚¹ç›¸åŒåˆ™é€’å½’è°ƒç”¨DoesTree1HaveTree2ï¼ˆï¼‰ï¼Œ
å¦‚æœæ ¹èŠ‚ç‚¹ä¸ç›¸åŒï¼Œåˆ™åˆ¤æ–­tree1çš„å·¦å­æ ‘å’Œtree2æ˜¯å¦ç›¸åŒï¼Œ
å†åˆ¤æ–­å³å­æ ‘å’Œtree2æ˜¯å¦ç›¸åŒ
3ã€æ³¨æ„nullçš„æ¡ä»¶ï¼ŒHasSubTreeä¸­ï¼Œå¦‚æœä¸¤æ£µæ ‘éƒ½ä¸ä¸ºç©ºæ‰è¿›è¡Œåˆ¤æ–­ï¼Œ
DoesTree1HasTree2ä¸­ï¼Œå¦‚æœTree2ä¸ºç©ºï¼Œåˆ™è¯´æ˜ç¬¬äºŒæ£µæ ‘éå†å®Œäº†ï¼Œå³åŒ¹é…æˆåŠŸï¼Œ
tree1ä¸ºç©ºæœ‰ä¸¤ç§æƒ…å†µï¼ˆ1ï¼‰å¦‚æœtree1ä¸ºç©º&&tree2ä¸ä¸ºç©ºè¯´æ˜ä¸åŒ¹é…ï¼Œ
ï¼ˆ2ï¼‰å¦‚æœtree1ä¸ºç©ºï¼Œtree2ä¸ºç©ºï¼Œè¯´æ˜åŒ¹é…ã€‚
*/
public class Solution {
    public boolean HasSubtree(TreeNode root1,TreeNode root2) {
        boolean result = false;
	        if(root1 != null && root2 != null){
	        	if(root1.val == root2.val){
	        		result = DoesTree1HaveTree2(root1,root2);
	        	}
	        	if(!result){result = HasSubtree(root1.left, root2);}
	        	if(!result){result = HasSubtree(root1.right, root2);}
	        }
	        return result;
    }
    public boolean DoesTree1HaveTree2(TreeNode root1,TreeNode root2){
	    	if(root1 == null && root2 != null) return false;
	    	if(root2 == null) return true;
	    	if(root1.val != root2.val) return false;
	    	return DoesTree1HaveTree2(root1.left, root2.left) && DoesTree1HaveTree2(root1.right, root2.right);
	    }
}
36
lizo
class Solution {
public:
    bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2)
    {
        if(pRoot2 == NULL || pRoot1 == NULL )
            return false;
        return isSubtree(pRoot1, pRoot2)|| HasSubtree(pRoot1->left,pRoot2) || HasSubtree(pRoot1->right,pRoot2);
    }
     
    bool isSubtree(TreeNode* pRoot1 , TreeNode* pRoot2){
        if(pRoot2 == NULL)
            return true;
        if(pRoot1 == NULL)
            return false;
        return pRoot1->val == pRoot2->val && isSubtree(pRoot1->left,pRoot2->left) && isSubtree(pRoot1->right,pRoot2->right);
    }
};
48
Python
åç§‘å¹³å‡¡
  python solution:  class Solution:
    def HasSubtree(self, pRoot1, pRoot2):
        
        def convert(p):
            if p:
                return str(p.val) +  convert(p.left) + convert(p.right)
            else:
                return ""
        return convert(pRoot2) in convert(pRoot1) if pRoot2 else False
15
txlstars
  æ€è·¯ï¼šå¯¹Aæ ‘DFSï¼Œå¦‚æœBçš„æ ¹èŠ‚ç‚¹ä¸Aä¸­æŸä¸ªèŠ‚ç‚¹å€¼ç›¸åŒï¼Œé‚£ä¹ˆä»¥Bä¸ºæ ‘æ ¹è¿›è¡ŒDFSï¼Œåˆ¤æ–­å³å¯ 
  æ—¶é—´å¤æ‚åº¦ä¸ºO(n * m) 
  psï¼š 
  çœ‹åˆ°æœ‰äººæå‡ºäº†KMPçš„æƒ³æ³•ï¼Œå³å…ˆåºéå†ç„¶åæ¯”è¾ƒBçš„å…ˆåºåºåˆ—æ˜¯å¦æ˜¯Açš„å…ˆåºåºåˆ—çš„å­åºåˆ— 
  æ—¶é—´å¤æ‚åº¦O(n + m)ï¼Œæƒ³æ³•æŒºå¥½çš„ï¼Œä½†æ˜¯è¦è€ƒè™‘ä¸‹é¢è¿™ç§æƒ…å†µæ˜¯å¦æ»¡è¶³é¢˜æ„ã€‚å¦‚æœä¸‹åˆ—æ»¡è¶³ 
  é¢˜æ„ï¼Œé‚£ä¹ˆä½¿ç”¨è¿™ç§æ–¹æ³•æ˜¯ä¸å¯¹çš„ã€‚ 
13
crazychen
/*public class TreeNode {
Â Â Â  int val = 0;
Â Â Â  TreeNode left = null;
Â Â Â  TreeNode right = null;
Â Â Â  public TreeNode(int val) {
Â Â Â Â Â Â Â  this.val = val;
Â Â Â  }
}*/
public class Solution {
Â Â  public boolean HasSubtree(TreeNode root1,TreeNode root2) {
Â Â  Â Â Â  Â if(root2==null) return false;
Â Â  Â Â Â  Â if(root1==null && root2!=null) return false;Â Â  Â Â Â  Â 
Â Â  Â Â Â  Â boolean flag = false;
Â Â  Â Â Â  Â if(root1.val==root2.val){
Â Â  Â Â Â  Â Â Â  Â flag = isSubTree(root1,root2);
Â Â  Â Â Â  Â }
Â Â  Â Â Â  Â if(!flag){
Â Â  Â Â Â  Â Â Â  Â flag = HasSubtree(root1.left, root2);
Â Â  Â Â Â  Â Â Â  Â if(!flag){
Â Â  Â Â Â  Â Â Â  Â Â Â  Â flag = HasSubtree(root1.right, root2);
Â Â  Â Â Â  Â Â Â  Â }
Â Â  Â Â Â  Â }
Â Â  Â Â Â  Â return flag;
Â Â Â  }
Â Â  Â 
Â Â  Â private boolean isSubTree(TreeNode root1, TreeNode root2) {
Â Â  Â Â Â  Â if(root2==null) return true;
Â Â  Â Â Â  Â if(root1==null && root2!=null) return false;Â Â  Â Â Â  Â 
Â Â  Â Â Â  Â if(root1.val==root2.val){
Â Â  Â Â Â  Â Â Â  Â return isSubTree(root1.left, root2.left) && isSubTree(root1.right, root2.right);
Â Â  Â Â Â  Â }
Â Â  Â Â Â  Â return false;
Â Â  Â }
}
24
è¶…å°ç™½
é‡æ–°æ•´ç†äº†ä»£ç ï¼Œæ³¨é‡Šå†™çš„éå¸¸æ¸…æ¥šäº†ï¼Œæ¬¢è¿è®¨è®ºå’Œä»£ç ç»™å‡ºæ„è§
 æ€è€ƒï¼š 1.é¦–å…ˆéœ€è¦é€’å½’pRoot1æ ‘ï¼Œæ‰¾åˆ°ä¸pRoot2æ ¹ä¸€æ ·çš„èŠ‚ç‚¹ï¼Œè¿™éœ€è¦ä¸€ä¸ªéå†
  2.æ‰¾åˆ°ç›¸åŒçš„æ ¹èŠ‚ç‚¹åï¼Œè¦åˆ¤æ–­æ˜¯å¦å­æ ‘ï¼Œä»éœ€è¦ä¸€ä¸ªä¸€ä¸ªéå†å¯¹æ¯” æ ‘çš„éå†æˆ‘ä»¬ä¸€èˆ¬å°±ç”¨é€’å½’æ¥åšï¼Œé‚£ä¹ˆæ ¹æ®åˆ†æéœ€è¦ä¸¤ä¸ªé€’å½’å‡½æ•°å¦‚ä¸‹ï¼š
bool IsSubtree(TreeNode*p1, TreeNode *p2)
{
    if (!p2)
 	//æ­¤å¤„ä¸ºp2 == null æ˜¯åŒ¹é…å®Œæˆçš„æ¡ä»¶
    //æœ€å¼€å§‹p2è‚¯å®šä¸ä¸ºNULL,è¿™æ˜¯åœ¨ä¸»ç¨‹åºHasSubtreeä¸­åˆ¤æ–­è¿‡çš„ã€‚
    //é€’å½’ä¸­ï¼Œå¦‚æœp2ä¸ºç©ºäº†ï¼Œåˆ™è¡¨ç¤ºä¸Šä¸€å±‚çš„é€’å½’ä¸­çš„p2å·²ç»åŒ¹é…å®Œäº†
		return true;
	if (!p1)
		return false;
	if (p1->val != p2->val)
		return false;
	return IsSubtree(p1->left, p2->left) && IsSubtree(p1->right, p2->right);
}
bool HasSubtree(TreeNode *pRoot1, TreeNode *pRoot2)
{
	if(pRoot2 == nullptr)
        return false;//é¢˜ç›®è¦æ±‚ï¼Œç©ºæ ‘ä¸æ˜¯ä»»ä½•æ ‘çš„å­ç»“æ„
	if(pRoot1 == nullptr)
        return false; //æ˜¾ç„¶
	
    //return IsSubtree(pRoot1, pRoot2)||HasSubtree(pRoot1->left, pRoot2)|| HasSubtree(pRoot1->right, pRoot2);
    //ä¸ºäº†æ€è·¯æ¸…æ¥šï¼Œåˆ†å¼€è°¢äº†,å¯ä»¥åˆ©ç”¨||æˆ–è¿ç®—ç›´æ¥return
    
	bool flag = IsSubtree(pRoot1, pRoot2);//çœ‹çœ‹Bæ˜¯ä¸æ˜¯ä»¥Açš„æ ¹ä¸ºæ ¹çš„å­ç»“æ„
	if (!flag)//é€’å½’Açš„å·¦å­æ ‘ï¼Œçœ‹çœ‹åšå­æ ‘ä¸­æœ‰æ²¡æœ‰Bå­ç»“æ„
		flag = HasSubtree(pRoot1->left, pRoot2);
	if (!flag)//åŒä¸Šï¼Œé€’å½’Açš„å³å­æ ‘
		flag = HasSubtree(pRoot1->right, pRoot2);
	return flag;
}
å…¶ä¸­éœ€è¦æ³¨æ„çš„æ˜¯ï¼š
1. æµ‹è¯•ç”¨ä¾‹å¦‚æœpRoot2ä¸ºç©ºçš„è¯ï¼Œè¿”å›çš„falseè€Œä¸æ˜¯æˆ‘ä»¬è®¤ä¸ºçš„ç©ºæ ‘åº”è¯¥æ˜¯æ‰€æœ‰æ ‘çš„å­æ ‘
2. å†åˆ¤æ–­æ˜¯å¦å­æ ‘çš„è¿‡ç¨‹ä¸­ï¼Œåº”è¯¥å…ˆåˆ¤æ–­pRoot2æ˜¯å¦ä¸ºç©ºï¼Œä¸ºç©ºåˆ™è¡¨æ˜å­æ ‘çš„æ‰€æœ‰èŠ‚ç‚¹éƒ½æ¯”è¾ƒå®Œäº†ï¼Œåº”è¯¥æ˜¯å­æ ‘è¿”å›True
3. è¦å…»æˆä¸€ä¸ªä¹ æƒ¯ï¼Œå¯¹ä»»ä½•ä¸€ä¸ªæ ‘èŠ‚ç‚¹è¿›è¡Œè®¿é—®æ—¶ï¼Œä¸€å®šè¦æå‰æ£€æµ‹è¯¥èŠ‚ç‚¹æ˜¯å¦ä¸ºç©º
7
åŠªåŠ›ç¼–ç¨‹
public boolean IsSubtree(TreeNode root1, TreeNode root2){
		if(root2 == null)
			return true;
		if(root1 == null)
			return false;
		if(root1.val == root2.val)
		return IsSubtree(root1.left,root2.left) && IsSubtree(root1.right, root2.right);
		else return false;
	}
    public boolean HasSubtree(TreeNode root1,TreeNode root2) {
        if(root1 == null || root2 == null)
        	return false;
        return IsSubtree(root1, root2) || HasSubtree(root1.left, root2) || HasSubtree(root1.right, root2);
    }
5
åä»”è¦é•¿èƒ–
 Javaç‰ˆæœ¬  public boolean HasSubtree(TreeNode root1,TreeNode root2) {
Â  Â  if(root1==null || root2==null)Â  return false;
Â  Â  return doesTree1HasTree2(root1, root2)|| HasSubtree(root1.left, root2)
Â  Â  Â  Â  Â  Â  ||HasSubtree(root1.right, root2);
}
private boolean doesTree1HasTree2(TreeNode root1,TreeNode root2) {
Â  Â  if(root2==null)Â  return true;
Â  Â  if(root1==null)Â  return false;
Â  Â  return root1.val==root2.val && doesTree1HasTree2(root1.left, root2.left)
Â  Â  Â  Â  Â  Â  && doesTree1HasTree2(root1.right, root2.right);
}   
3
Mr..
  è§£é¢˜æ€è·¯ï¼š    1.æ‰¾åˆ°Aä¸­å’ŒBçš„æ ¹èŠ‚ç‚¹ç›¸åŒçš„èŠ‚ç‚¹ï¼Œç„¶åè¿›è¡Œåˆ¤æ–­æ˜¯å¦ç›¸åŒã€‚    2.å¦‚æœä¸åŒå†æ‹¿Açš„å·¦å­æ ‘å’ŒBè¿›è¡Œæ¯”è¾ƒã€‚    3.å¦‚æœä»ä¸åŒå†æ‹¿Açš„å³å­æ ‘ä¸Bè¿›è¡Œæ¯”è¾ƒã€‚    4.å¦‚æœä»æœªæ‰¾åˆ°ï¼Œåˆ™Aä¸­ä¸åŒ…å«Bã€‚    åˆ¤æ–­ä¸¤ä¸ªæ ¹èŠ‚ç‚¹ç›¸åŒçš„ä¸¤ä¸ªæ ‘æ˜¯å¦åŒ…å«ï¼š    1.å…ˆåˆ¤æ–­B,å¦‚æœBä¸ºç©ºè¯´æ˜åŒ…å«ã€‚    2.å†åˆ¤æ–­Aï¼Œå¦‚æœAä¸ºç©ºå°±è¯´æ˜ä¸åŒ…å«ã€‚    3.å¦‚æœAçš„å€¼ä¸Bçš„å€¼ç›¸åŒï¼Œç„¶åç»§ç»­è¿›è¡Œæ­¤åˆ¤æ–­ã€‚ 
3
Python
è¿œç›®
  å…ˆæŠŠä¸¤ä¸ªæ ‘è½¬åŒ–æˆå…ˆåºéå†çš„å­—ç¬¦ä¸²ï¼Œç„¶ååˆ¤æ–­ç¬¬äºŒä¸ªå­—ç¬¦ä¸²æ˜¯ä¸æ˜¯ç¬¬ä¸€ä¸ªçš„å­å­—ç¬¦ä¸²      # -*- coding:utf-8 -*-      # class TreeNode:      # Â  Â  def __init__(self, x):      # Â  Â  Â  Â  self.val = x      # Â  Â  Â  Â  self.left = None      # Â  Â  Â  Â  self.right = None      class Solution:      Â  Â  def tree2str(self,root):      Â  Â  Â  Â  if not root:      Â  Â  Â  Â  Â  Â  return ''      Â  Â  Â  Â  re = ''      Â  Â  Â  Â  re+=str(root.val)      Â  Â  Â  Â  if root.left or Â root.right:      Â  Â  Â  Â  Â  Â  re += self.tree2str(root.left) + self.tree2str(root.right)      Â  Â  Â  Â  return re         Â  Â  def HasSubtree(self, pRoot1, pRoot2):      Â  Â  Â  Â  if not pRoot2:      Â  Â  Â  Â  Â  Â  return False      Â  Â  Â  Â  str1 = self.tree2str(pRoot1)      Â  Â  Â  Â  str2 = self.tree2str(pRoot2)      Â  Â  Â  Â  if str1.find(str2) == -1:      Â  Â  Â  Â  Â  Â  return False      Â  Â  Â  Â  else:      Â  Â  Â  Â  Â  Â  return True      
3
drdr
class Solution {
public:
	bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2)
	{
		if (pRoot2 == NULL || pRoot1 == NULL) return false; 
		return dfs(pRoot1, pRoot2) || HasSubtree(pRoot1->left, pRoot2)
			|| HasSubtree(pRoot1->right, pRoot2);
	}
	bool dfs(TreeNode* node, TreeNode* pRoot2) {
		if (pRoot2 == NULL) return true;
		else if (node != NULL) {
			return (node->val == pRoot2->val) && dfs(node->left, pRoot2->left)
				&& dfs(node->right, pRoot2->right);
		}
		else return false;
	}
};
7
nailperry
    /* æ”¹è¿›ç®—æ³•ï¼Œæ—¶é—´å¤æ‚åº¦Oï¼ˆm+nï¼‰
     * 1.å°†root1å’Œroot2åˆ†åˆ«æŒ‰å…ˆåºéå†åºåˆ—åŒ–ã€‚
     * 2.è¿ç”¨KMPç®—æ³•åŒ¹é…åºåˆ—åŒ–ç»“æœã€‚
     */
    public boolean HasSubtree(TreeNode root1,TreeNode root2) {
    	if(root2==null)
    		return false;// ç©ºæ ‘æœ¬åº”æ˜¯ä»»æ„æ ‘çš„å­ç»“æ„ï¼Œä½†ä»æµ‹è¯•é›†æ¥çœ‹ï¼Œåº”è§†ä¸ºfalse
    	if(root1==null)
    		return false;
    	char[] str = Serialize(root1).toCharArray();
    	char[] pattern = Serialize(root2).toCharArray();
    	int[] next = new int[pattern.length];
    	System.out.println(String.valueOf(str));
    	System.out.println(String.valueOf(pattern));
    	getNext(pattern,next);
		return KMP(str,pattern,next);
        
    }
	private boolean KMP(char[] str, char[] pattern, int[] next) {
		if(str==null||pattern==null)
			return false;
		if(str.length<pattern.length)
			return false;
		int i=0,j=0,len = str.length;
		while(i<len&&j<pattern.length){
			if(j==-1||str[i]==pattern[j]){
				i++;j++;
			}else{
				j = next[j];
			}
		}
		if(j==pattern.length)// è¡¨ç¤ºæœ€åä¸€ä¸ªå­—ç¬¦ä¹Ÿç›¸ç­‰ï¼ŒåŒ¹é…æˆåŠŸ
			return true;
		return false;
	}
	private void getNext(char[] pattern, int[] next) {
		if(pattern==null||pattern.length==0)
			return;
		int i=0,j=-1;
		next[0] = -1;
		while(i<pattern.length-1){
			if(j==-1||pattern[i]==pattern[j]){
				++i;++j;				
				if(pattern[i]==pattern[j]){
					next[i] = next[j];
				}else{
					next[i] = j;
				}
			}else{
				j = next[j];
			}
		}
	}
	public String Serialize(TreeNode root) {
		if(root==null)
			return "";
		this.buffer = new StringBuffer();
		SerializeF(root);
		int i;
		// åˆ é™¤åºåˆ—å°¾éƒ¨çš„$
		for(i = buffer.length()-1;i>=0;i--){
			if(buffer.charAt(i)==','||buffer.charAt(i)=='$'){
				continue;
			}else
				break;
		}
		buffer.delete(i+1,buffer.length());
		return buffer.toString();
	}
2
åå­—é•¿ä½ ä¸ä¸€å®šèƒ½è®°ä½å‘¢
  python solution  -*- coding:utf-8 -*-
# class TreeNode:
#Â  Â  Â def __init__(self, x):
#Â  Â  Â  Â  Â self.val = x
#Â  Â  Â  Â  Â self.left = None
#Â  Â  Â  Â  Â self.right = None
class Solution:
Â  Â  def HasSubtree(self, pRoot1, pRoot2):
Â  Â  Â  Â  # write code here
Â  Â  Â  Â  result = False
Â  Â  Â  Â  ifÂ  pRoot1 andÂ  pRoot2:
Â  Â  Â  Â  Â  Â  if pRoot1.val==pRoot2.val:
Â  Â  Â  Â  Â  Â  Â  Â  result = self.DoesTree1HaveTree2(pRoot1,pRoot2)
Â  Â  Â  Â  Â  Â  if not result:
Â  Â  Â  Â  Â  Â  Â  Â  result = self.HasSubtree(pRoot1.left,pRoot2)
Â  Â  Â  Â  Â  Â  if not result:
Â  Â  Â  Â  Â  Â  Â  Â  result = self.HasSubtree(pRoot1.right,pRoot2)
Â  Â  Â  Â  return result
Â  Â Â 
Â  Â  def DoesTree1HaveTree2(self,pRoot_A,pRoot_B):
Â  Â  Â  Â  if not pRoot_B:
Â  Â  Â  Â  Â  Â  return True
Â  Â  Â  Â  if not pRoot_A:
Â  Â  Â  Â  Â  Â  return False
Â  Â  Â  Â  if pRoot_A.val != pRoot_B.val:
Â  Â  Â  Â  Â  Â  return False
Â  Â  Â  Â Â 
Â  Â  Â  Â  return self.DoesTree1HaveTree2(pRoot_A.left,pRoot_B.left) and self.DoesTree1HaveTree2(pRoot_A.right,pRoot_B.right)
  å‚è€ƒå‰‘æŒ‡Offerä¹¦ä¸­æ€è·¯ï¼Œç”¨Pythonå†™çš„    åœ¨ä¸Šè¿°ä»£ç ä¸­ï¼Œæˆ‘ä»¬é€’å½’è°ƒç”¨HasSubtreeéå†äºŒå‰æ ‘Aã€‚å¦‚æœå‘ç°æŸä¸€èŠ‚ç‚¹çš„å€¼å’Œæ ‘Bçš„æ ¹ç»“ç‚¹çš„å€¼ç›¸ç­‰ï¼Œåˆ™è°ƒç”¨DoesTree1HaveTree2,è¿›è¡Œç¬¬äºŒæ­¥åˆ¤æ–­ã€‚    ç¬¬äºŒæ­¥æ˜¯åˆ¤æ–­æ ‘Aä¸­ä»¥Rä¸ºè·Ÿç»“ç‚¹çš„å­æ ‘æ˜¯ä¸æ˜¯å’Œæ ‘Bå…·æœ‰ç›¸åŒçš„ç»“æ„ã€‚åŒæ ·ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥ç”¨é€’å½’çš„æ€è·¯æ¥è€ƒè™‘ï¼šå¦‚æœèŠ‚ç‚¹Rçš„å€¼å’Œæ ‘Bçš„æ ¹èŠ‚ç‚¹ä¸åŒï¼Œé‚£ä¹ˆä»¥Rä¸ºæ ¹èŠ‚ç‚¹çš„å­æ ‘å’Œæ ‘Bè‚¯å®šä¸å…·æœ‰ç›¸åŒçš„èŠ‚ç‚¹ï¼›å¦‚æœå®ƒä»¬çš„å€¼ç›¸åŒï¼Œé‚£ä¹ˆé€’å½’åœ°åˆ¤æ–­å®ƒä»¬å„è‡ªçš„å·¦å³èŠ‚ç‚¹çš„å€¼æ˜¯ä¸æ˜¯ç›¸åŒã€‚é€’å½’çš„ç»ˆæ­¢æ¡ä»¶æ˜¯åˆ°è¾¾äº†æ ‘Aæˆ–è€…æ ‘Bçš„å¶å­èŠ‚ç‚¹ã€‚    Â  éœ€è¦æ³¨æ„çš„æ˜¯Â  DoesTree1HasTree2å‡½æ•°ä¸­ï¼Œå¦‚æœTree2ä¸ºç©ºï¼Œåˆ™è¯´æ˜ç¬¬äºŒæ£µæ ‘éå†å®Œäº†ï¼Œå³æ˜¯ç¬¬ä¸€é¢—æ ‘çš„å­æ ‘ï¼Œè¿”å›TRUE     Â  Â å¦‚æœtree1ä¸ºç©ºè€Œtree2ä¸ä¸ºç©ºè¯´æ˜tree2ç»“æ„è¶…å¤§ï¼Œtree1ä¸­ä¸å­˜åœ¨            
2
imwtr
function HasSubtree(pRoot1, pRoot2)
{
Â  Â  if (!pRoot2) {
Â  Â  Â  Â  return false;
Â  Â  }
Â  Â Â 
Â  Â  return preOrder(pRoot1).includes(preOrder(pRoot2));
}
function preOrder(root) {
Â  Â  let val = [];
Â  Â  (function handle(root) {
Â  Â  Â  Â  if (root) {
Â  Â  Â  Â  Â  Â  val.push(root.val);
Â  Â  Â  Â  Â  Â  handle(root.left);
Â  Â  Â  Â  Â  Â  handle(root.right);
Â  Â  Â  Â  }
Â  Â  })(root);
Â  Â Â 
Â  Â  return val.join(',');
}
 é€šè¿‡å…ˆåºéå†åˆ¤æ–­å­é›†
2
JavaScript
Zfirsty
//Javascript æè¿°ï¼Œç”¨flagè¡¨ç¤ºå‡½æ•°çŠ¶æ€ã€‚
function HasSubtree(p1, p2,flag)
{
    var f=HasSubtree;
    if(flag && !p2) return true;
    if(!p1 || !p2) return false;
    if(p1 && p2 && p1.val == p2.val) 
        return f(p1.left,p2.left,true) && f(p1.right,p2.right,true) || f(p1.left,p2)||f(p1.right,p2);
    return  f(p1.left,p2) || f(p1.right,p2);
} 
2
å‰çƒ§ä¸¤ä»½
  å¯¹æ¯ä¸€ä¸ªç»“ç‚¹åˆ¤æ–­æ˜¯å¦æ˜¯å­ğŸŒ²ï¼Œ å…¶ä¸­isSubtreeç”¨æ¥åˆ¤æ–­t1å’Œt2æ˜¯å¦æ˜¯ç›¸åŒå­æ ‘ã€‚
å½“t2==NULLæ—¶è¯´æ˜èƒ½å¤Ÿéå†åˆ°å¶å­ï¼Œåˆ™t2æ˜¯t1å­æ ‘ã€‚
å½“t1==NULL&&t2!=NULLåˆ™t2è¿˜æ²¡éå†å®Œï¼Œt1å°±ç»“æŸäº†ï¼Œé‚£ä¹ˆè‚¯å®šä¸æ˜¯å­æ ‘ã€‚
å¦‚æœè¿™ä¸¤ä¸ªç»“ç‚¹t1 t2çš„å€¼ç›¸åŒï¼Œåˆ™è¦æ¯”è¾ƒä»–ä»¬çš„å·¦å³å­æ ‘ï¼Œåªè¦æœ‰ä¸€ä¸ªå­æ ‘ä¸åŒé‚£ä¹ˆå°±æ²¡æœ‰çˆ¶å­å…³ç³»ã€‚
å¦‚æœå€¼ä¸ç›¸åŒç›´æ¥è¿”å›FALSEï¼›
ç”¨HasSubtreeæ¥é€‰æ‹©å“ªä¸¤ä¸ªç»“ç‚¹æ¥è¿›è¡Œé€‰æ‹©ã€‚
åªè¦ä¸¤ä¸ªç»“ç‚¹æœ‰ä¸€ä¸ªæ˜¯ç©ºç»“ç‚¹ï¼Œä¸éœ€è¦æ¯”è¾ƒï¼Œè¿”å›NULLã€‚
      è¿™ä¸ªç»“ç‚¹æˆ–è€…è¿™ä¸ªç»“ç‚¹çš„å·¦å³å­æ ‘ï¼Œåªè¦æœ‰ä¸€ä¸ªæ»¡è¶³ä¸è¢«æ¯”è¾ƒç»“ç‚¹æ˜¯æœ‰ç›¸åŒçš„å­æ ‘ï¼ˆä¹Ÿå°±æ˜¯è¿”å›trueï¼‰é‚£ä¹ˆå°±åº”è¯¥è¿”å›trueä½œä¸ºç»“æœã€‚
  
class Solution {
public:
    bool isSubtree(TreeNode *t1, TreeNode *t2){
        if(t2==NULL) return true;
        if(t1==NULL && t2!=NULL) return false;
        if(t1->val == t2->val){
            bool lTree = isSubtree(t1->left, t2->left);
            bool rTree = isSubtree(t1->right, t2->right);
            return lTree && rTree;
        }else return false;
    }
    bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2)
    {
		if(pRoot1 == NULL || pRoot2 == NULL) return false;
        return isSubtree(pRoot1, pRoot2) || HasSubtree(pRoot1->left, pRoot2)
            || HasSubtree(pRoot1->right, pRoot2);
    }
};
2
Bye2016
public boolean HasSubtree(TreeNode root1, TreeNode root2) {
		if(root2 == null) {
			return false;
		}
		List<TreeNode> list1 = new ArrayList<>();
		List<TreeNode> list2 = new ArrayList<>();
		preOrderTraversal(root1, list1);
		preOrderTraversal(root2, list2);
		StringBuffer sb1 = new StringBuffer();
		for (int i = 0; i < list1.size(); i++) {
			sb1.append(list1.get(i).val);
		}
		StringBuffer sb2 = new StringBuffer();
		for(int i = 0; i < list2.size(); i++) {
			sb2.append(list2.get(i).val);
		}
		return sb1.toString().indexOf(sb2.toString()) >= 0 ? true : false;
//		return !list1.contains(list2);	//æ˜¯é”™è¯¯çš„åšæ³•ï¼Œcontainsåªèƒ½æ£€æµ‹ä¸€ä¸ªlisté’Ÿæ˜¯å¦åŒ…å«æŸå…ƒç´ 
	}
	
	public void preOrderTraversal(TreeNode root, List<TreeNode> list) {
		if(root == null) {
			return;
		}
		list.add(root);
		preOrderTraversal(root.left, list);
		preOrderTraversal(root.right, list);
	}
