考点    

链表

热点指数    118871
通过率    24.44%
题目    

从尾到头打印链表


具体题目    输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。
讨论    252
徘徊的路人甲
  方法一：链表从尾到头输出，利
  
查看全部
666
grass_stars
java 递归超简洁版本
public class Solution {
    ArrayList<Integer> arrayList=new ArrayList<Integer>();
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
		if(listNode!=null){
			this.printListFromTailToHead(listNode.next);
			arrayList.add(listNode.val);
		}
		return arrayList;
    }
}	
58
Python
hgleagle
  python版递归法，只有3行代码  # -*- coding:utf-8 -*-
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
class Solution:  
# 返回从尾部到头部的列表值序列，例如[1,2,3]  
    def printListFromTailToHead(self, listNode):  
    # write code here  
    if listNode is None:  
        return []  
    return self.printListFromTailToHead(listNode.next) + [listNode.val]
128
peter7788
  方法一：借助堆栈的“后进先出”实现 
  /** *    public class ListNode { *        int val; *
         ListNode next = null; * *        ListNode(int val)
  { *            this.val = val; *        } *    } *
  */ import java.util.ArrayList; import java.util.Stack;
  public class Solution {     public ArrayList<Integer>
  printListFromTailToHead(ListNode listNode) {        
  Stack<Integer> stack=new Stack<Integer>();        
  while(listNode!=null){             stack.push(listNode.val);  
            listNode=listNode.next;              }         
          ArrayList<Integer> list=new
  ArrayList<Integer>();         while(!stack.isEmpty()){  
            list.add(stack.pop());         }         return
  list;     } }
  方法二：借助递归实现（递归的本质还是使用了堆栈结构） 
  import java.util.ArrayList; import java.util.Stack;
  public class Solution {     public ArrayList<Integer>
  printListFromTailToHead(ListNode listNode) {        
  ArrayList<Integer> list=new ArrayList<Integer>();    
               ListNode pNode=listNode;        
  if(pNode!=null){             if(pNode.next!=null){            
      list=printListFromTailToHead(pNode.next);             }  
            list.add(pNode.val);         }                 
  return list;     } }
41
C/C++
Invoker_em
有三种思路，第一就是利用栈先入后出的特性完成，第二就是存下来然后进行数组翻转。
第三是利用递归。
栈思路：
class Solution {
public:
    vector<int> printListFromTailToHead(ListNode* head) {
        vector<int> value;
        ListNode *p=NULL;
        p=head;
        stack<int> stk;
        while(p!=NULL){
            stk.push(p->val);
            p=p->next;
        }
        while(!stk.empty()){
            value.push_back(stk.top());
            stk.pop();
        }
        return value;
    }
};
数组翻转：数组翻转可以用C++自带的函数，也可以自己实现
class Solution {
public:
    vector<int> printListFromTailToHead(ListNode* head) {
        vector<int> value;
        ListNode *p=NULL;
        p=head;
        while(p!=NULL){
            value.push_back(p->val);
            p=p->next;
        }
        //reverse(value.begin(),value.end()); //C++自带的翻转函数
        int temp=0;
        int i=0,j=value.size()-1;
        while(i<j){
            temp=value[i];    //也可以用swap函数，swap(value[i],value[j]);
            value[i]=value[j];
            value[j]=temp;
            i++;
            j--;
        }
        return value;
    }
};
递归思路：
class Solution {
public:
    vector<int> value;
    vector<int> printListFromTailToHead(ListNode* head) {
        ListNode *p=NULL;
        p=head;
        if(p!=NULL){
            if(p->next!=NULL){
                printListFromTailToHead(p->next);
            }
            value.push_back(p->val);
        }
        return value;
    }
};
 
74
枪骑兵叔叔
  C++版，递归
class Solution {
 public:
  vector<int> dev;
  vector<int>& printListFromTailToHead(struct ListNode* head) {
    if(head!=NULL) {
      if(head->next!=NULL) {
        dev=printListFromTailToHead(head->next);
      }
      dev.push_back(head->val);
    }
    return dev;
  }
};
38
JavaScript
郑耀钧
  啊， Javascript 没人权啦  /*function ListNode(x) {
    this.val = x;
    this.next = null;
}*/
function printListFromTailToHead(head) {
    // write code here
    var res = [], pNode = head;
    while (pNode != null) {
        res.unshift(pNode.val);
        pNode = pNode.next;
    }
    return res;
}
34
Java
天使之翼
import java.util.ArrayList;
import java.util.Collections;
public class Solution {
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        ArrayList<Integer> list = new ArrayList<Integer>();
        
        while(listNode != null){
            list.add(listNode.val);
            listNode = listNode.next;
        }
        
        Collections.reverse(list);//使用Collections的reverse方法，直接将list反转
        return list;
    }
}
41
RollingX
  用反向迭代器就好了
class Solution {
public:
    vector<int> printListFromTailToHead(struct ListNode* head) {
        vector<int> v;
                       
        ListNode *p = head;
        while (p != nullptr) {
           v.push_back(p->val);
           p = p->next;
        }
        //反向迭代器创建临时对象
        return vector<int>(v.rbegin(), v.rend());
    }
};
33
就多贡献python代码吧
	# -*- coding:utf-8-*-
	# classListNode:
	#     def __init__(self, x):
	#         self.val = x
	#         self.next = None
	 
	classSolution:
	    # 返回从尾部到头部的列表值序列，例如[1,2,3]
	    def printListFromTailToHead(self, listNode):
	        # write code here
	        result = []
	        iflistNode is None:
	            returnresult
	             
	        whilelistNode.next is not None:
	            result.extend([listNode.val])
	            listNode=listNode.next
	        result.extend([listNode.val])
	         
	        returnresult[::-1]
26
菩提旭光
最佳代码：代码思路借助栈，遍历的时候入栈，由于数据结构中栈的特点是先进后出，所以遍历的过程中压栈，推栈，完了弹栈加到ArrayList中。有两个容易出错的地方：第一，第一次测试用例，{}返回[
    ],null是null，而[ ]是new ArrayList（）但是没有数据。第二，遍历stack用的方法是！stak.isEmpty()方法，而不是for循环size遍历。。
/**
*    public class ListNode {
*        int val;
*        ListNode next = null;
*
*        ListNode(int val) {
*            this.val = val;
*        }
*    }
*
*/
import java.util.Stack;
import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer>
    printListFromTailToHead(ListNode listNode) {
        if(listNode == null){
            ArrayList list = new ArrayList();
            return list;
        }
        Stack<Integer> stk = new Stack<Integer>();
        while(listNode != null){
            stk.push(listNode.val);
            listNode = listNode.next;
        }
        ArrayList<Integer> arr = new ArrayList<Integer>();
        while(!stk.isEmpty()){
            arr.add(stk.pop());
        }
        return arr;
    }
}
17
fcq1129
/**
*  struct ListNode {
*        int val;
*        struct ListNode *next;
*        ListNode(int x) :
*              val(x), next(NULL) {
*        }
*  };
*/
class Solution {
public:
    vector<int> printListFromTailToHead(struct ListNode* head) {
//利用栈的逆序输出特性    	
        stack<int> stack;
        vector<int> vector;
        struct ListNode *p = head;
        if (head != NULL) {
        	stack.push(p->val);
            while((p=p->next) != NULL) {
            	stack.push(p->val);
        	}
            while(!stack.empty()) {
                vector.push_back(stack.top());
                stack.pop();
        	}
        }
        return vector;
    }
        
};
33
liuwu265
  感觉大家的代码都有点长，我就直接一个循环解决！ 
vector<int> printListFromTailToHead(struct ListNode* head) {
        vector<int> v;
        while(head != NULL)
        {
            v.insert(v.begin(),head->val);
            head = head->next;
        }
        return v;
    }
14
GEZOX__
# python的实现这么少， 我来添砖加瓦
# 1.先遍历链表元素到栈
# 2.栈再弹出
# -*- coding:utf-8 -*-
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
class Solution:
    # 返回从尾部到头部的列表值序列，例如[1,2,3]
    def printListFromTailToHead(self, listNode):
        # write code here
        lst,lst_bak = [],[]
        if not listNode:
            return lst
        while listNode:
            lst.append(listNode.val)
            listNode = listNode.next
        while lst:
            lst_bak.append(lst.pop())
        return lst_bak
 
9
老石基
import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        ArrayList<Integer> list = new ArrayList<Integer>();
        if(listNode==null)
            return list;
        get(listNode, list);
        return list;
    }
	public void get(ListNode listNode,ArrayList<Integer> list){
		if(listNode.next==null){
			list.add(listNode.val);
			return;
		}
		get(listNode.next, list);
		list.add(listNode.val);
	}
}
8
JavaScript
dayday_up
/*function ListNode(x){
    this.val = x;        // 节点的数据域
    this.next = null;    // 节点指针域，通过this.next使指针后移
}*/
function printListFromTailToHead(head)
{
    var arr = [];    // 创建一个空数组，将每个节点存放哎数组中
    if(!head) {        // 判断链表是否为空
        return arr;
    }
    while(head) {
        arr.unshift(head.val);    // 使用unshift()方法，将当前节点放到数组的开头
        head = head.next;    // 指针后移
    }
    return arr;    
}
10
Exe
  利用头插arraylist实现栈的功能 
   public ArrayList<Integer> printListFromTailToHead(ListNode
  listNode) { 
          ArrayList<Integer> list = new
  ArrayList<Integer>(); 
    if(listNode == null) 
    return list; 
    while(listNode.next != null){ 
list.add(0,listNode.val); 
listNode = listNode.next; 
} 
list.add(0,listNode.val);
return list; 
    }
6
VincentL
public class LinkedList {
	public static ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        ListNode list = new ListNode(0);
        
        ListNode cursor = listNode;
        ListNode top = list;
       
        
        ArrayList<Integer> result = new ArrayList<Integer>();
        while(cursor!=null){
        	   ListNode temp = new ListNode(cursor.val);
               temp.next = top;
               top = temp;
               cursor = cursor.next;
        }
        
        while(top!=null){
     		result.add(top.val);      
            top = top.next;
        }
        result.remove(result.size()-1);
        
      return result;
     
    }
}
5
writezen
import java.util.ArrayList;
import java.util.Stack;
public class Solution {
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
 Stack<ListNode> stack = new Stack<ListNode>();
 ArrayList<Integer> list=new ArrayList<Integer>();
 ListNode current=listNode;
 while(current!=null){
 stack.push(current);
 current=current.next;
 }
 while(!stack.isEmpty()){
 list.add(new Integer(stack.pop().val));
 }
 
 return list;
 }
}
4
Java
feeeee
  头插法    add()有这个两个参数的方法。  import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        ArrayList<Integer> list = new ArrayList<Integer>();
        while(listNode != null) {
            list.add(0, listNode.val);
            listNode = listNode.next;
        }
        return list;
    }
}
 
6
Java
御坂美琴2604
  有点忘了 链表是啥了。。。      public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {              ArrayList<Integer> list = new ArrayList<>();              for(;listNode != null;) {                  list.add(0, listNode.val);                  listNode = listNode.next;              }              return list;       }  
