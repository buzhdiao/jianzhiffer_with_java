#### 题目    从尾到头打印链表

考点    链表	热点指数    118871	通过率    24.44%

#### 具体题目    

输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。

```
public class Solution {
    ArrayList<Integer> arrayList=new ArrayList<Integer>();
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
		if(listNode!=null){
			this.printListFromTailToHead(listNode.next);
			arrayList.add(listNode.val);
		}
		return arrayList;
    }
}	
```

  方法一：借助堆栈的“后进先出”实现 
  /** *    public class ListNode { *        int val; *
         ListNode next = null; * *        ListNode(int val)
  { *            this.val = val; *        } *    } *
  */ import java.util.ArrayList; import java.util.Stack;
  public class Solution {     public ArrayList<Integer>
  printListFromTailToHead(ListNode listNode) {        
  Stack<Integer> stack=new Stack<Integer>();        
  while(listNode!=null){             stack.push(listNode.val);  
            listNode=listNode.next;              }         
          ArrayList<Integer> list=new
  ArrayList<Integer>();         while(!stack.isEmpty()){  
            list.add(stack.pop());         }         return
  list;     } }
  方法二：借助递归实现（递归的本质还是使用了堆栈结构） 
  import java.util.ArrayList; import java.util.Stack;
  public class Solution {     public ArrayList<Integer>
  printListFromTailToHead(ListNode listNode) {        
  ArrayList<Integer> list=new ArrayList<Integer>();    
               ListNode pNode=listNode;        
  if(pNode!=null){             if(pNode.next!=null){            
      list=printListFromTailToHead(pNode.next);             }  
            list.add(pNode.val);         }                 
  return list;     } }


有三种思路，第一就是利用栈先入后出的特性完成，第二就是存下来然后进行数组翻转。
第三是利用递归。
```
import java.util.ArrayList;
import java.util.Collections;
public class Solution {
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        ArrayList<Integer> list = new ArrayList<Integer>();
        
        while(listNode != null){
            list.add(listNode.val);
            listNode = listNode.next;
        }
        
        Collections.reverse(list);//使用Collections的reverse方法，直接将list反转
        return list;
    }
}
```

最佳代码：代码思路借助栈，遍历的时候入栈，由于数据结构中栈的特点是先进后出，所以遍历的过程中压栈，推栈，完了弹栈加到ArrayList中。有两个容易出错的地方：第一，第一次测试用例，{}返回[
    ],null是null，而[ ]是new ArrayList（）但是没有数据。第二，遍历stack用的方法是！stak.isEmpty()方法，而不是for循环size遍历。。
/**
*    public class ListNode {
*        int val;
*        ListNode next = null;
*
*        ListNode(int val) {
*            this.val = val;
*        }
*    }
*
*/
import java.util.Stack;
import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer>
    printListFromTailToHead(ListNode listNode) {
        if(listNode == null){
            ArrayList list = new ArrayList();
            return list;
        }
        Stack<Integer> stk = new Stack<Integer>();
        while(listNode != null){
            stk.push(listNode.val);
            listNode = listNode.next;
        }
        ArrayList<Integer> arr = new ArrayList<Integer>();
        while(!stk.isEmpty()){
            arr.add(stk.pop());
        }
        return arr;
    }
}
```
import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        ArrayList<Integer> list = new ArrayList<Integer>();
        if(listNode==null)
            return list;
        get(listNode, list);
        return list;
    }
	public void get(ListNode listNode,ArrayList<Integer> list){
		if(listNode.next==null){
			list.add(listNode.val);
			return;
		}
		get(listNode.next, list);
		list.add(listNode.val);
	}
}
```

  利用头插arraylist实现栈的功能 
   public ArrayList<Integer> printListFromTailToHead(ListNode
  listNode) { 
          ArrayList<Integer> list = new
  ArrayList<Integer>(); 
    if(listNode == null) 
    return list; 
    while(listNode.next != null){ 
list.add(0,listNode.val); 
listNode = listNode.next; 
} 
list.add(0,listNode.val);
return list; 
    }
6
VincentL
public class LinkedList {
	public static ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        ListNode list = new ListNode(0);
        

        ListNode cursor = listNode;
        ListNode top = list;


​        
​        ArrayList<Integer> result = new ArrayList<Integer>();
​        while(cursor!=null){
​        	   ListNode temp = new ListNode(cursor.val);
​               temp.next = top;
​               top = temp;
​               cursor = cursor.next;
​        }
​        
​        while(top!=null){
​     		result.add(top.val);      
​            top = top.next;
​        }
​        result.remove(result.size()-1);
​        
​      return result;
​     
    }
}

import java.util.ArrayList;
import java.util.Stack;
public class Solution {
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
 Stack<ListNode> stack = new Stack<ListNode>();
 ArrayList<Integer> list=new ArrayList<Integer>();
 ListNode current=listNode;
 while(current!=null){
 stack.push(current);
 current=current.next;
 }
 while(!stack.isEmpty()){
 list.add(new Integer(stack.pop().val));
 }

 return list;
 }

  头插法    add()有这个两个参数的方法。  import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        ArrayList<Integer> list = new ArrayList<Integer>();
        while(listNode != null) {
            list.add(0, listNode.val);
            listNode = listNode.next;
        }
        return list;
    }
}