考点    

树

热点指数    33239
通过率    29.09%
题目    

二叉树的下一个结点


具体题目    给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。
讨论    117
setsail
  分析二叉树的下一个节点，一共
  
查看全部
189
小河沟大河沟
 思路：首先知道中序遍历的规则是：左根右，然后作图         结合图，我们可发现分成两大类：1、有右子树的，那么下个结点就是右子树最左边的点；（eg：D，B，E，A，C，G）     2、没有右子树的，也可以分成两类，a)是父节点左孩子（eg：N，I，L） ，那么父节点就是下一个节点 ； b)是父节点的右孩子（eg：H，J，K，M）找他的父节点的父节点的父节点...直到当前结点是其父节点的左孩子位置。如果没有eg：M，那么他就是尾节点。      /* struct TreeLinkNode { int val; struct TreeLinkNode *left; struct TreeLinkNode *right; struct TreeLinkNode *next; TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) { } }; */ //分析二叉树的下一个节点，一共有以下情况： //1.二叉树为空，则返回空； //2.节点右孩子存在，则设置一个指针从该节点的右孩子出发，一直沿着指向左子结点的指针找到的叶子节点即为下一个节点； //3.节点不是根节点。如果该节点是其父节点的左孩子，则返回父节点；否则继续向上遍历其父节点的父节点，重复之前的判断，返回结果。 classSolution{ public:     TreeLinkNode* GetNext(TreeLinkNode* pNode)     {         if (pNode == NULL)             returnNULL;         if (pNode->right != NULL)         {             pNode = pNode->right;             while (pNode->left != NULL)                 pNode = pNode->left;             returnpNode;         }         while (pNode->next != NULL)         {             TreeLinkNode *proot = pNode->next;             if (proot->left == pNode)                 returnproot;             pNode = pNode->next;         }         returnNULL;     } };     
201
weizier
public class Solution {
    TreeLinkNode GetNext(TreeLinkNode node)
    {
        if(node==null) return null;
        if(node.right!=null){    //如果有右子树，则找右子树的最左节点
            node = node.right;
            while(node.left!=null) node = node.left;
            return node;
        }
        while(node.next!=null){ //没右子树，则找第一个当前节点是父节点左孩子的节点
            if(node.next.left==node) return node.next;
            node = node.next;
        }
        return null;   //退到了根节点仍没找到，则返回null
    }
}
25
刘豪杰
 思路：  
（1）
若该节点存在右子树：则下一个节点为右子树最左子节点（如图节点
B
）
（2）
若该节点不存在右子树：这时分两种情况：
2.1 
该节点为父节点的左子节点，则下一个节点为其父节点（如图节点
D
）
2.2 
该节点为父节点的右子节点，则沿着父节点向上遍历，知道找到一个节点的父节点的左子节点为该节点，则该节点的父节点下一个节点（如图节点
I
，沿着父节点一直向上查找找到
B
（
B
为其父节点的左子节点），则
B
的父节点
A
为下一个节点）。
public class Solution {
	public TreeLinkNode GetNext(TreeLinkNode pNode) {
		if (pNode == null)
			return pNode;
		if (pNode.right != null) { // 节点有右子树
			pNode = pNode.right;
			while (pNode.left != null) {
				pNode = pNode.left;
			}
			return pNode;
		} else if ( pNode.next != null && pNode.next.left == pNode) { // 节点无右子树且该节点为父节点的左子节点
			return pNode.next;
		} else if (pNode.next != null && pNode.next .right == pNode) { // 节点无右子树且该节点为父节点的右子节点
            while(pNode.next != null && pNode .next .left != pNode){
            	pNode = pNode.next ;
            }
            return pNode.next ;
		}else{
			return pNode.next ;//节点无父节点 ，即节点为根节点
		}
	}
} 
16
Ron
public class Solution {
	TreeLinkNode GetNext(TreeLinkNode pNode)
	{
		if(pNode == null){
			return null;
		}
		if(pNode.right != null){
            pNode = pNode.right;
			while(pNode.left != null){
				pNode = pNode.left;
			}
			return pNode;
		}
		while(pNode.next != null){ //非根节点
			if(pNode == pNode.next.left)
				return pNode.next;
			pNode = pNode.next;
		}
		return null;
	}
}
12
不完整旋律
python大法好 
class Solution:
    def GetNext(self, pNode):
        # write code here
        if pNode.right:#有右子树
            p=pNode.right
            while p.left:
                p=p.left
            return p
        while pNode.next:#无右子树，则找第一个当前节点是父节点左孩子的节点
            if(pNode.next.left==pNode): 
                return pNode.next
            pNode = pNode.next#沿着父节点向上遍历
        return  #到了根节点仍没找到，则返回空
16
Python
华科平凡
    def GetNext(self, pNode):
        # write code here
        dummy = pNode
        while dummy.next:
            dummy = dummy.next
        self.result = []
        self.midTraversal(dummy)
        return self.result[self.result.index(pNode) + 1] if self.result.index(pNode) != len(self.result) - 1 else None
    def midTraversal(self, root):
        if not root: return
        self.midTraversal(root.left)
        self.result.append(root)
        self.midTraversal(root.right)
这个解法肯定不是最优的，但是简单易懂能通过
5
Java
我去个地方啊
    public TreeLinkNode GetNext(TreeLinkNode pNode)
    {
        if(pNode == null){
            return null;
        } 
        //1.判断当前节点是否有右子节点，有则去里面找
        if(pNode.right != null){
            return firstInRightTree(pNode);
        //2.没有右子节点，就需要去父节点找
        }else{
            //3.直到找到符合条件的父节点为止，跳出循环时pNode的父节点符合条件，这个父节点就是我们要的东西
            while(pNode.next != null && pNode.next.left != pNode){
                pNode = pNode.next;
            }
            return pNode.next;
        }
    }
    //到右子树中找符合条件的，显然就是找最最最左边的子节点即可
    private TreeLinkNode firstInRightTree(TreeLinkNode pNode){
        TreeLinkNode curr = pNode.right;
        while(curr.left != null){
            curr = curr.left;
        }
        return curr;
    }
}
4
drdr
class Solution {
public:
    TreeLinkNode* GetNext(TreeLinkNode* pNode)
    {
        TreeLinkNode* ret = NULL;
        if(pNode->right != NULL){//如果当前节点有右子树,则右子树最左边的那个节点就是
            ret = pNode->right;
            while(ret->left != NULL)
                ret = ret->left;
            return ret;
        }
        ret = pNode;
        while(ret->next != NULL && ret == ret->next->right){//如果当前节点没有右子树，并且是其父节点的左子树
			ret = ret->next;
        }
        return ret->next;
    }
}; 
4
老石基
import java.util.*;
public class Solution {
    public TreeLinkNode GetNext(TreeLinkNode pNode){
        if(pNode==null)
            return null;
        //不是从这个pNode开始中序遍历，而是从树根开始
        //所有先找到树根
        TreeLinkNode root = pNode;
        while(root.next!=null)
            root = root.next;
        List<TreeLinkNode> list = new ArrayList<TreeLinkNode>();
        get(root,list);
        list.add(null);
        for(int i = 0;i<list.size()-1;i++){
            if(list.get(i)==pNode)
                return list.get(i+1);
        }
        return null;
    }
    public void get(TreeLinkNode root,List<TreeLinkNode> list){
        if(root==null)
            return;
        get(root.left,list);
        list.add(root);
        get(root.right,list);
    }
}
3
Java
魔王爱吃糖
public class Solution {
    public TreeLinkNode GetNext(TreeLinkNode pNode)
    {
        if (pNode == null) {
			return pNode;
		}
        
        TreeLinkNode pNext = null;
        // 节点有右子树，下个节点应是它右子树中最左的子节点
        if (pNode.right != null) {
			TreeLinkNode pRight = pNode.right;
			// 找最左子节点
			while (pRight.left != null) {
				pRight = pRight.left;
			}
			pNext = pRight;
		} 
        // 节点没有右子树，向上遍历
        else if (pNode.next != null) {
			TreeLinkNode pCur = pNode;
			TreeLinkNode pParent = pNode.next;
			// 当前节点没有右子树，且是它父节点的右子节点
			// 沿着指向父节点的指针向上遍历，直到找到一个节点：它是它的父节点的左子节点
			while (pParent != null && pCur == pParent.right) {
				pCur = pParent;
				pParent = pParent.next;
			}
			pNext = pParent;
		}
		return pNext;
    }
}
2
Python
Krahets
  按照优先级从高到低分2种情况：    1、给定节点有right，就返回right节点子树最左节点；    2、一路向上找，返回子节点为父节点左节点的父节点，如果没有就返回None。  class Solution:
    def GetNext(self, pNode):
        # write code here
        if pNode.right: # 1
            node = pNode.right
            while node.left: node = node.left
            return node
        while pNode.next:  # 3,4
            if pNode == pNode.next.left: return pNode.next
            pNode = pNode.next
        return None # 2
2
Java
ZCL_HIT
/*
public class TreeLinkNode {
    int val;
    TreeLinkNode left = null;
    TreeLinkNode right = null;
    TreeLinkNode next = null;
    TreeLinkNode(int val) {
        this.val = val;
    }
}
*/
public class Solution {
    public TreeLinkNode GetNext(TreeLinkNode pNode)
    {
        if(pNode == null)
            return null;
        
        TreeLinkNode pNext = null;
        //如果当前节点有右叶子节点，我们就寻找当前节点的右子树种最左边的那个点
        if(pNode.right!=null){
            TreeLinkNode pRight = pNode.right;
            while(pRight.left!=null)
                pRight = pRight.left;
            pNext = pRight;
        }
        //如果当前节点没有右叶子节点，则应当向上寻找当前节点的父节点中属于祖父节点的左子节点的那一个
        else if(pNode.next!=null){
            TreeLinkNode pCurrent = pNode;
            TreeLinkNode pParent = pNode.next;
            while(pParent!=null && pCurrent!=pParent.left){
                pCurrent = pParent;
                pParent = pParent.next;
            }
            pNext = pParent;
        }
        //否则返回null-
        return pNext;
    }
} 
2
跪求offer养家糊口
/*
因为中序遍历遵循LVR的顺序，其中L为左子树，V为节点值，R为右子树。
根据所给节点与其他节点的关系，分类讨论：
1>所给节点如果有右孩子，则直接返回右孩子；
2>否则，如果所给节点没有父节点，当前节点为没有右子树的根节点，返回NULL；
3>否则，如果所给节点为父节点的左孩子，直接返回父节点；
4>否则，沿父节点向上，直到找到一个节点x，满足：
    pNode位于x节点的左子树 && pNode位于x左孩子的右子树
    返回x节点。
*/
class Solution {
public:
    TreeLinkNode* GetNext(TreeLinkNode* pNode)
    {
        if (pNode == NULL)  
            return NULL;
        TreeLinkNode *p = pNode;
        TreeLinkNode *ret = NULL;
        if (p->right)  //当前节点存在右孩子
        {
            p = p->right;
            while (p->left)
                p = p->left;
            ret = p;
        }
        else if (p->next == NULL)  //当前节点没有父节点和右孩子
            ret = NULL;
        else 
        {
            if (p == p->next->left)  //当前节点为其父节点的左孩子
                ret = p->next;
            else              //当前节点为父节点的右孩子
            {
                TreeLinkNode *par = p->next;
                while (par)   //沿父节点上溯
                {
                    if (par->next == NULL)
                        break;
                    else if (par == par->next->right)
                        par = par->next;
                    else
                        break;
                }
                ret = par->next;
            }
        }
        return ret;
    }
}; 
2
牛客722730号
  分两种情况：1.该节点存在右子节点，则下一个节点是右子树的最左节点。2.该节点不存在右子节点，则
下一个节点是
该节点的第一个父子关系为左的祖先节点中的父节点。
class Solution {
public:
    TreeLinkNode* GetNext(TreeLinkNode* pNode)
    {
        if(!pNode)
            return NULL;
        if(pNode->right) {
            pNode = pNode->right;
            while(pNode->left)
                pNode = pNode->left;
            return pNode;
        }
        auto p = pNode->next;
        while(p&&pNode==p->right) {
            pNode = p;
            p = pNode->next;
        }
        return p;  
    }
};
1
Java
Rickers
public class Solution {
     public TreeLinkNode GetNext(TreeLinkNode pNode){
        TreeLinkNode nextNode  = null;
        if(pNode != null){
            //按照中序遍历的顺序，如果该节点有右孩子节点，则寻找右孩子节点中的最左的节点
            //如果没有右孩子节点，则寻找 父节点中第一个左孩子为该节点所在子树 的节点
            if(pNode.right != null){ 
                nextNode = findNextChild(pNode.right);
            }else{
                nextNode = findNextParent(pNode);
            }
        }
        return nextNode;
    }
    //寻找父节点中，左子树 为该节点所在的子树
    //有则返回该节点，若无，则返回空
    private TreeLinkNode findNextParent(TreeLinkNode pNode) {
        TreeLinkNode childNode = pNode; 
        TreeLinkNode tmpNode = pNode.next;
        while(tmpNode != null && tmpNode.left != childNode){
            childNode = tmpNode;
            tmpNode = tmpNode.next;
        }
        return tmpNode;
    }
    
    //寻找右孩子子树里，最左的节点
    private TreeLinkNode findNextChild(TreeLinkNode childNode) {
        TreeLinkNode tmpNode = childNode;
        while(tmpNode.left != null){
            tmpNode = tmpNode.left;
        }
        return tmpNode;
    }
}
 
1
梦的蓝天xd
  本题需要分两种情况讨论：    1、存在右结点，直接找到右子树的最左边的孩子即可    2、不存在右结点，此时又要分两种情况讨论：           （1）根节点的左孩子，直接输出直接输出根节点。           （2）根节点的右孩子，此时再次分两种情况讨论：                    （a）中序遍历的最后一个节点，这里判断采用，先找到父节点，如果父节点的右结点是该节点，继续向上查找，如果一直找到了整个数的根节点，说明是中序遍历的最后一个结点。                    （b）不是中序遍历的最后一个节点，输出根节点的根节点。      /*
struct TreeLinkNode {
    int val;
    struct TreeLinkNode *left;
    struct TreeLinkNode *right;
    struct TreeLinkNode *next;
    TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) {
        
    }
};
*/
class Solution {
public:
    TreeLinkNode* GetNext(TreeLinkNode* pNode)
    {
        TreeLinkNode* fdNextNode = NULL;
        if(pNode == NULL)
            return NULL;
        
        if(pNode->right != NULL)
        {
            TreeLinkNode* rtRight = pNode->right;
            while(rtRight->left != NULL)
            {
                rtRight = rtRight->left;
            }
            return rtRight;
        }
        else
        {
            if(pNode->next == NULL)
                return NULL;
            
            TreeLinkNode* pnRoot = pNode->next;
            if(pnRoot->left == pNode)
            {
                return pnRoot;
            }
            else
            {
                TreeLinkNode* tmp = pNode;
                while(tmp->next != NULL && tmp->next->right == tmp)
                {
                    tmp = tmp->next;
                }
                if(tmp->next == NULL)
                    return NULL;
                else
                    return pnRoot->next;
            }
        }
    }
};  
1
forevergorilla
public class Solution {
    TreeLinkNode node=null;
    TreeLinkNode lastNode=null;
    boolean isready=false;
    public TreeLinkNode GetNext(TreeLinkNode pNode)
    {    lastNode=pNode;
        TreeLinkNode root=pNode;//找到根节点
        while(root.next!=null)
        {
            root=root.next;
        }
        mid(root);
        return node;
    }
    public void mid(TreeLinkNode root)
    {    if(root==null)return;
        if(root!=null)
        {
            mid(root.left);
            //to do
            if(isready==true)
            {
             node=root;
             isready=false;
            }
            if(root==lastNode)
            {
                isready=true;
            }
            mid(root.right);
        }
    }
}
   代码写的比较随意直接就过了。那就懒得改了。。。。。。    大致思路就是先通过next找到根节点，然后中序遍历。    把pNode传给共有变量，又设置一个布尔值。一起来做标记    当遍历到pNode 的时候把布尔值改成true 说明一下个遍历的值就是要找的节点了。    找到节点后赋给用来接收的node指针。    并在主函数返回他 
1
Java
chasein
public static TreeNode getNext(TreeNode node){
        if(node == null){
            return null;
        }
        TreeNode temp = node.right;
        TreeNode nextNode;
        //如果一个节点有右子树
        if(temp != null){
            while(temp.left != null){
                temp = temp.left;
            }
            nextNode = temp;
        }
        //如果一个节点没有右子树，且是它父节点的左子节点
        else if(node.right == null && node.next != null && node.next.left == node){
            nextNode = node.next;
        }else { //没有右子树，并且还是其父节点的右子节点
            temp = node.next;
            while(temp != null && temp.next != null && temp.next.left != temp){
                temp = temp.next;
            }
            //注意要判断temp != null,如果只有一个节点时temp=null,直接temp.next会出现NullPointerException
            if(temp != null && temp.next != null){ 
                nextNode = temp.next;
            }else{
                nextNode = null;
            }
        }
        return nextNode;
    }
1
可爱的考拉
class Solution {
public:
    TreeLinkNode* GetNext(TreeLinkNode* pNode)
    {
        if(pNode==nullptr) return nullptr;
        if(pNode->right!=nullptr){//第一种情况，当前节点存在右子树，则下一节点为右子树的最左节点
            TreeLinkNode* current=pNode->right;
            while(current->left!=nullptr){
                current=current->left;
            }
            return current;
        }
        else{
            TreeLinkNode* parent=pNode->next;
            TreeLinkNode* current=pNode;
            /*
            第二三种情况，当前节点无右子树，若当前节点为父节点的左孩子，则下一节点为父节点；
            若当前节点为父节点的右孩子，则向上遍历，直到找到一个节点为其父节点的左孩子，那么下一节点为找到的这个节点的父节点
            */
            if(parent!=nullptr&&current==parent->right){
                while(parent!=nullptr&&current!=parent->left){
                    current=parent;
                    parent=parent->next;
                }
            }
            return parent;
        }
    }
};
 
1
巫山剑
   /*
public class TreeLinkNode {
    int val;
    TreeLinkNode left = null;
    TreeLinkNode right = null;
    TreeLinkNode next = null;
    TreeLinkNode(int val) {
        this.val = val;
    }
}
*/
public class Solution {
    public TreeLinkNode GetNext(TreeLinkNode pNode)
    {
        // 如果是pNode==null那么直接返回null
        if(pNode==null)return null;
        if(pNode.right!=null){
            // 有右子树，有没有左子树无所谓，那么pNode就是子树的根节点，那么下一个就应该是右子树最左边的那个节点
            pNode=pNode.right;
            // 在右子树上一直向左走
            while(pNode.left!=null){
                pNode=pNode.left;
            }
            return pNode;
        }else{
            // 如果没有右子树，有不管有没有左子树，现在下一个节点肯定不是在自己这棵子树上了，肯定在父节点或者说更上一级的树上
            // 总体思路就像图中的一样(next指针没有画出来)，找节点9的下一个节点，应该是节点1，找的方法就是判断父节点的左子树是否是当前节点，
            // 如果是就返回父节点，否则继续找父节点的父节点
            TreeLinkNode father=pNode.next;
            // 如果这个节点就是这整棵树的根节点就直接返回null
            if(father==null)return null;
            while(father.left!=pNode){
                pNode=father;
                father=father.next;
                // 这也是坑，如果这个节点刚好是中序遍历的最后一个节点，那么就直接返回null
                if(father==null)return null;
            }
            return father;
        }
    }
}
 
