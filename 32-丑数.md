#### 题目    丑数

考点    时间空间效率的平衡	热点指数    42642	通过率    21.44%

#### 具体题目

​    把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。

/*
说下思路，如果p是丑数，那么p=2^x * 3^y * 5^z
那么只要赋予x,y,z不同的值就能得到不同的丑数。
如果要顺序找出丑数，要知道下面几个特（fei）点（hua）。
对于任何丑数p：
（一）那么2*p,3*p,5*p都是丑数，并且2*p<3*p<5*p
（二）如果p<q, 那么2*p<2*q,3*p<3*q,5*p<5*q
现在说说算法思想：
    由于1是最小的丑数，那么从1开始，把2*1，3*1，5*1，进行比较，得出最小的就是1
的下一个丑数，也就是2*1，
    这个时候，多了一个丑数‘2’，也就又多了3个可以比较的丑数，2*2，3*2，5*2，
这个时候就把之前‘1’生成的丑数和‘2’生成的丑数加进来也就是
(3*1,5*1,2*2，3*2，5*2)进行比较，找出最小的。。。。如此循环下去就会发现，
每次选进来一个丑数，该丑数又会生成3个新的丑数进行比较。
    上面的暴力方法也应该能解决，但是如果在面试官用这种方法，估计面试官只会摇头吧
。下面说一个O（n）的算法。
    在上面的特（fei）点（hua）中，既然有p<q, 那么2*p<2*q，那么
“我”在前面比你小的数都没被选上，你后面生成新的丑数一定比“我”大吧，那么你乘2
生成的丑数一定比我乘2的大吧，那么在我选上之后你才有机会选上。
其实每次我们只用比较3个数：用于乘2的最小的数、用于乘3的最小的数，用于乘5的最小的
数。也就是比较(2*x , 3*y, 5*z) ，x>=y>=z的，
重点说说下面代码中p的作用：int p[] = new int[] { 0, 0, 0 }; p[0]表示最小用于
乘2比较数在数组a中的【位置】。 */
public class Solution {
  	final int d[] = { 2, 3, 5 };
	public int GetUglyNumber_Solution(int index) {
        if(index == 0) return 0;
		int a[] = new int[index];
		a[0] = 1;
		int p[] = new int[] { 0, 0, 0 };
        int num[] = new int[] { 2, 3, 5 };
		int cur = 1;
		while (cur < index) {
			int m = finMin(num[0], num[1], num[2]);
			if (a[cur - 1] < num[m]) 
				a[cur++] = num[m];
			p[m] += 1;
			num[m] = a[p[m]] * d[m];
		}
		return a[index - 1];
	}
	private int finMin(int num2, int num3, int num5) {
		int min = Math.min(num2, Math.min(num3, num5));
		return min == num2 ? 0 : min == num3 ? 1 : 2;
	}
}

import java.util.*;
public class Solution {
    public int GetUglyNumber_Solution(int index) {
        if(index<=0)
        	return 0;
        ArrayList<Integer> list = new ArrayList<Integer>();
        //add进第一个丑数1
        list.add(1);
        //三个下标用于记录丑数的位置
        int i2=0,i3=0,i5=0;
        while(list.size()<index){
            //三个数都是可能的丑数，取最小的放进丑数数组里面
            int n2=list.get(i2)*2;
            int n3=list.get(i3)*3;
            int n5=list.get(i5)*5;
            int min = Math.min(n2,Math.min(n3,n5));
            list.add(min);
            if(min==n2)
                i2++;
            if(min==n3)
                i3++;
            if(min==n5)
                i5++;
        }
        return list.get(list.size()-1);
    }
} 
5
rs勿忘初心

思路一：逐个判断每个整数是不是丑数的解法，直观但不高效（牛客网测试超时）
       所谓一个数m是另一个数n的因子，是指n能被m整数，也就是n%m==0。根据丑数的定义，丑数只能被2、3和5整数。也就是说如果一个数能被2整除，我们就把它连续除以2；如果能被3整数，就连续除以3；如果能被5整除，就除以连续5。如果最后我们得到的数字是1，那么这个数就是丑数，否则不是。该算法非常直观，代码也非常简洁，但
最大的问题是每个整数都需要计算。即使一个数字不是丑数，我们还是需要对它做求余和除法操作
。因此该算法的时间效率不够高，面试官也不会就此满足。
      
思路二：创建数组保存已找到的丑数，用空间换时间的解法
       前面的算法之所以效率低，很大程度上是因为不管一个数是不是丑数，我们对它都要作计算。接下来我们试着找到一种只要计算丑数的方法，而不在非丑数的整数上浪费时间。根据丑数的定义，
丑数应该是另一个丑数乘以2、3或者5的结果（1除外）
。因此我们可以创建一个数组，里面的数字是排好序的丑数，每一个丑数都是前面的丑数乘以2、3或者5得到的。
       这种思路的关键在于怎样确保数组里面的丑数是排好序的。假设数组中已经有若干个丑数排好序后放在数组中，并且把
已有最大的丑数记做M
，我们接下来分析如何生成下一个丑数。该丑数肯定是前面某一个丑数乘以2、3或者5的结果，所以我们首先考虑把已有的每个丑数乘以2。在乘以2的时候，可以得到多干个小于等于M的结果。由于是按顺序生成的，小于或者等于M肯定已经在数组中了，我们不需要再考虑；还会得到若干个大于M的结果，但我们只需要第一个大于M的结果，因为我们希望丑数是按照从小到大的顺序生成的，其他更大的结果以后再说。我们把得到的第一个乘以2后大于M的丑数记为M2。同样，我们把已有的每一个丑数乘以3和5，能得到第一个大于M的结果M3和M5。那么下一个丑数应该是M2、M3和M5这三个数的最小者了
。
       
前面分析的时候，提到把已有的丑数分别乘以2、3和5。事实上这不是必须的，因为已有的丑数是按照顺序放在数组中的。对乘以2而言，肯定存在某一个丑数T2，排在它之前的每一个乘以2得到的结果都会小于已有最大的丑数，在它之后的每一个丑数乘以2得到的结果都会太大。我们只需要记下这个丑数的位置，同时每次生成新的丑数的时候，取更新这个这个T2.对于乘以3和5而言，也存在着同样的T3和T5。

/**
 *
 * 解题思路：
 * 因为丑数的因子只能是丑数
 * 丑数的组成成可以分成三种情况：（x和y为大于1的变量）
 * 3x,5y或3x*5y的倍数个2；可简化为丑数个2
 * （。。。。。类推）个3；可简化为丑数个3
 * （。。。。。类推）个5；可简化为丑数个5
 */
public class Solution {
    public int GetUglyNumber_Solution(int index) {
        if(index<=6)return index;
        int[] array = new int[index+1];//丑数数组
        array[1]=1;//第一个丑数为1
        int i2=1;//丑数数组下标，指向下一个2的丑数数量
        int i3=1;//丑数数组下标，指向下一个3的丑数数量
        int i5=1;//丑数数组下标，指向下一个5的丑数数量
        for(int i=2;i<=index;i++){
            int nUgly2 = array[i2] * 2;//丑数量个2
            int nUgly3 = array[i3] * 3;
            int nUgly5 = array[i5] * 5;
            array[i] = Integer.min(nUgly2,Integer.min(nUgly3,nUgly5));
            if(array[i2]==array[i]/2){
                i2++;//当前2的丑数数量已经使用，下标加1
            }
            if(array[i3]==array[i]/3){
                i3++;//当前丑数数量已经使用，下标加1
            }
            if(array[i5]==array[i]/5){
                i5++;//当前丑数数量已经使用，下标加1
            }
        }
        return array[index];
    }
}
