考点    

发散思维能力

热点指数    38049
通过率    44.44%
题目    

不用加减乘除做加法


具体题目    写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。
讨论    69
咩咩jiang
  //step1:按位与是查看
  
查看全部
545
箫筱沐羽
public class Solution {
    public int Add(int num1,int num2) {
        while (num2!=0) {
            int temp = num1^num2;
            num2 = (num1&num2)<<1;
            num1 = temp;
        }
        return num1;
    }
} 首先看十进制是如何做的： 5+7=12，三步走
第一步：相加各位的值，不算进位，得到2。
第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。
第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。
同样我们可以用三步走的方式计算二进制值相加： 5-101，7-111 第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。
第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&111)<<1。
第三步重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&1010)<<1。
     继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。
蚂蚁金服2020届校招实习生开始了，我们部门正在火热招聘中https://www.nowcoder.com/discuss/161049
欢迎踊跃投简历
 
134
天空海豚🐬
int add(int a, int b)
{
	_asm
	{
		MOV EAX, a
		MOV ECX, b
		ADD EAX, ECX
	}
}
66
Java
大闲人柴毛毛
思路：位运算
两个数异或：相当于每一位相加，而不考虑进位；
  两个数相与，并左移一位：相当于求得进位；
  将上述两步的结果相加
public int Add(int num1,int num2) {
    while( num2!=0 ){
        int sum = num1 ^ num2;
        int carray = (num1 & num2) << 1;
        num1 = sum;
        num2 = carray;
    }
    return num1;
}
64
彭延
   13+11 = ？; 
  13 的二进制      1 1 0 1                     -----a        13 
  11 的二进制      1 0 1 1                     -----b        11   
 (a&b)
<<1  ->
  1 0 0 1 0
 
    
    
    
    
  -----d         18
            a^b  ->     0 1 1 0               
     -----e          6 
 (d&e)
<<1  ->
  0 0 1 0 0
    
    
    
    
  ------f         4
             d^e  ->  1 0 1 0 0              
       -----g        20
 (f&g)
<<1  ->
  0 1 0 0 0
    
    
    
    
  ------h        8
             f^g  ->  1 0 0 0 0                  
------i
          16
 (h&i)
<<1  ->
  0 0 0 0 0
    
    
    
    
  ------h        0       ----
--------退出循环
             h^i  ->  1 1 0 0 0                 
------i
          24
19
xiaoehaier
class Solution {
public:
    int Add(int num1, int num2)
    {
		char* a = reinterpret_cast<char*>(num1);
        return reinterpret_cast<long>(&(a[num2]));
    }
};
21
Python
尹斗俊喊你去学习
不得不吐槽下Python对位操作简直是深坑一座- - 主要原因还是因为python没有无符号又移操作，所以需要越界检查一波～ 其他思路和大家是一样的 加法是异或，进位是与<<1 # -*- coding:utf-8 -*- 
class Solution:  
    def Add(self, a, b):            
        while(b):  
           a,b = (a^b) & 0xFFFFFFFF,((a&b)<<1) & 0xFFFFFFFF
        return a if a<=0x7FFFFFFF else ~(a^0xFFFFFFFF)
20
zhuma
//看我的递归版本
class Solution {
public:
    int Add(int num1, int num2)
    {
        if(num2==0)
            return num1;
        return Add(num1^num2, (num1&num2)<<1);
    }
};
33
Java
指offer的剑在哪？
  既然不能使用四则，那我用自增自减~~  public class Solution {
    public int Add(int num1,int num2) {
        if(num1>0){
            while(num1--!=0)
                num2++;
        }
        else if(num1<0){
            while(num1++!=0)
                num2--;
        }
        return num2;
    }
}
 
11
Python
GooHub
# -*- coding:utf-8 -*-
class Solution:
    def Add(self, num1, num2):
        # write code here
        # 由于题目要求不能使用四则运算，那么就需要考虑使用位运算
        # 两个数相加可以看成两个数的每个位先相加，但不进位，然后在加上进位的数值
        # 如12+8可以看成1+0=1 2+8=0，由于2+8有进位，所以结果就是10+10=20
        # 二进制中可以表示为1000+1100 先每个位置相加不进位，
        # 则0+0=0 0+1=1 1+0=1 1+1=0这个就是按位异或运算
        # 对于1+1出现进位，我们可以使用按位与运算然后在将结果左移一位
        # 最后将上面两步的结果相加，相加的时候依然要考虑进位的情况，直到不产生进位
        # 注意python没有无符号右移操作，所以需要越界检查
        # 按位与运算：相同位的两个数字都为1，则为1；若有一个不为1，则为0。
        # 按位异或运算：相同位不同则为1，相同则为0。
        while num2:
            result = (num1 ^ num2) & 0xffffffff
            carry = ((num1 & num2) << 1) & 0xffffffff
            num1 = result
            num2 = carry
        if num1 <= 0x7fffffff:
            result = num1
        else:
            result = ~(num1^0xffffffff)
        return result
 
20
Java
koshien
  //答案都是位运算，逻辑运算什么的，思路不错，但是不是有更简单的吗？   
public int Add(int num1, int num2) { 
    return Integer.sum(num1, num2);
 }
     
6
ThinkR
class Solution {
public:
    int Add(int num1, int num2)
    {
	    //相加各位 + 计算进位
        //十进制思想
        //5+7 各位相加：2 进位：10
        //2+10 12 0
        //12+0
        //二进制计算过程
        //5+7 各位相加：101^111=010 进位：101&111=101 (<<1=1010)
        //2+10 各位相加：010^1010=1000 进位：010&1010=010 <<1=0100
        //8+4 1000^0100=1100 1000&0100=0
        //12+0
        if (num2 == 0) return num1;
        return Add(num1^num2, (num1&num2)<<1 );
    }
};
9
Warren
  考虑位运算，分三步： 
  第一步：不进位加 n1 
  第二步：计算进位 n2 
  第三步：n1 和 n2求和（重复第一步，直到进位为0，即n2=0) 
  在第一步中，采用异或 
  第二步中，采用按位与，左移一位 
  public int Add(int num1,int num2) {         int n1;
          int n2;         do{             n1 = num1 ^ num2;
              n2 = (num1 & num2)<<1;                 
          num1 = n1;             num2 = n2;         }while(num2
  !=0);         return n1;     }
6
张佃鹏
  class Solution { public:     int Add(int num1, int
  num2)     {         return
  num2?Add(num1^num2,(num1&num2)<<1):num1;     } }; 
    
  只用一条语句实现之！！！！ 
13
Python
华科平凡
python solution # -*- coding:utf-8 -*-
class Solution:
    def Add(self, num1, num2):
        # write code here
        return sum([num1,num2])
3
请别叫我河神
3
赛罗奥特曼~
class Solution {
public:
    int Add(int num1, int num2)
    {
    int result=0;
	__asm__(  
    "add %1,%2\n\t"         //%1表示num2 %2表示num1,这个表示num2的值加到num1上 
    "mov %2,%0\n\t"         //%0表示目的寄存器,把num1复制到result上
    :"=r"(result)           //%0,占用符号  
    :"r"(num2),"r"(num1)  //这一行是将C代码中的数据输入到汇编的代码中  
    );   
      return result;    
    }
};
3
Joe_liu
class Solution {
public:
	int Add(int num1, int num2)
	{
		int Sum, Carry;
		do 
		{
			Sum = num2 ^ num1;
			Carry = (num1 & num2) << 1;
			num2 = Carry;
			num1 = Sum;
		} while (num2 != 0);
		return num1;
	}
};
4
漩涡老逵
  import java.math.*; 
  public class Solution { 
      public int Add(int num1,int num2) { 
          BigInteger sum1=new BigInteger(String.valueOf(num1)); 
          BigInteger sum2=new BigInteger(String.valueOf(num2)); 
          BigInteger res=sum1.add(sum2); 
          String a=res.toString(); 
          int solution=Integer.valueOf(a); 
          return solution; 
           
      } 
  } 
2
C/C++
快乐的犇
class Solution { public:     int Add(int num1, int num2)     {         while(num2--)         {             num1++;         }         return num1;     } };
2
~一念执着~
//递归版本很简单啊
class Solution {
public:
    int Add(int num1, int num2){       
        if((num1&num2)<<1)
            return Add(num1^num2,(num1&num2)<<1);
        else
            return num1^num2;
    }
};
