考点    

递归和循环

热点指数    89727
通过率    39.95%
题目    

变态跳台阶


具体题目    一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。
讨论    1030
dangle
 关于本题，前提是n个台阶会有  
查看全部
138
岚啊哪
  class Solution { 
  public: 
      int jumpFloorII(int number) { 
                int a=1; return a<<(number-1);  
      } 
  }; 
2^(n-1)可以用位移操作进行，更快。
373
Yano_nankai
因为n级台阶，第一步有n种跳法：跳1级、跳2级、到跳n级 跳1级，剩下n-1级，则剩下跳法是f(n-1) 跳2级，剩下n-2级，则剩下跳法是f(n-2) 所以f(n)=f(n-1)+f(n-2)+...+f(1) 因为f(n-1)=f(n-2)+f(n-3)+...+f(1)   所以f(n)=2*f(n-1) 
39
Java
FantasyLin
【分析】
每个台阶可以看作一块木板，让青蛙跳上去，n个台阶就有n块木板，最后一块木板是青蛙到达的位子，
必须存在，其他 (n-1) 块木板可以任意选择是否存在，则每个木板有存在和不存在两种选择，(n-1) 块木板
就有 [2^(n-1)] 种跳法，可以直接得到结果。
  其实我们所要求的序列为：0,1,2,4,8,16,…… 
  所以除了第一位外，其他位的数都是前一位的数去乘以2所得到的积。 
【参考代码】
package javaTest;
import java.util.Scanner;
public class JavaTest {
	public static void main(String[] args) {
		Scanner input = new Scanner(System.in);
		int target = input.nextInt();
		System.out.println("跳上一个" + target + "级的台阶总共有"
				+ jumpFloor(target) + "种跳法");
	}
	// 第一种做法
	public static int jumpFloor(int target) {
		if (target <= 0) return 0;
		return (int) Math.pow(2, target - 1);
	}
//       第二种做法
//	public static int jumpFloor(int target) {
//		if (target <= 0) return 0;
//		if (target == 1) return 1;
//		int a = 1;
//		int b = 2;
//		for (int i = 2; i <= target; i++) {
//			b = 2 * a;
//			a = b;
//		}
//		return b;
//	}
}
431
//
  每个台阶都有跳与不跳两种情况（除了最后一个台阶），最后一个台阶必须跳。所以共用2^(n-1)中情况 
441
HXY
  一行代码 return  1<<--number; 
32
Python
华科平凡
python solution: return 2**(number-1)
27
强子GOR
         
  根据上一个题目：青蛙只跳1或2可以得出是一个斐波那契问题，即a[n]=a[n-1]+a[n-2],那么能跳1,2,3个台阶时a[n]=a[n-1]+a[n-2]+a[n-3],...... 
          依次类推，能推出本题的a[n]=a[n-1]+a[n-2]+......+a[1];由此得出代码：
class Solution {
public:
    int jumpFloorII(int number) {
        int *a=new int[number+1];
        a[0]=1;
        a[1]=1;
        for(int i=2;i<=number;i++){
            a[i]=0;
            for(int j=i-1;j>=0;j--){
                a[i]+=a[j];
            }
        }
        return a[number];
    }
};
  但是上述代码时间复杂度达到O(n^2),空间复杂度也达到O(n),重新看一下上述结论： 
  a[n]=a[n-1]+a[n-2]+......+a[1];..........................① 
  a[n-1]=        a[n-2]+......+a[1];..........................② 
  两式相减可知：a[n]=2*a[n-1]; 
  所以代码进一步简化： 
class Solution {
public:
    int jumpFloorII(int number) {
        int f=1,fn=1;
        for(int i=2;i<=number;i++){
            fn=2*f;
            f=fn;
        }
        return fn;
    }
};
33
C/C++
EricZeng
拒绝时间开销，拒绝递归调用
class Solution {
public:
    int jumpFloorII(int number) {
    	int jumpFlo=1;
        while(--number)
        {
            jumpFlo*=2;
        }
        return jumpFlo;
    }
};
17
C/C++
Allen解神
  （1）假定第一次跳的是一阶，那么剩下的是n-1个台阶，跳法是f(n-1)；假定第一次跳的是2阶，那么剩下的是n-2个台阶，跳法是f(n-2)；假定第一次跳的是3阶，那么剩下的是n-3个台阶，跳法是f(n-3)......假定第一次跳的是n-1阶，那么剩下的是1个台阶，跳法是f(1)；
假定第一次跳的是n阶，那么剩下的是0个台阶，跳法是1种；
（2）总跳法为: f(n) = 1+f(n-1) + f(n-2)+....+f(1)  （第一个1是跳n阶只有一种方法）
（3）根据（2）可以得出有一阶的时候 f(1) = 1 ；有两阶的时候可以有 f(2) =
            1+f(1)=2；有三阶的时候可以有 f(3) = 1+f(2)+f(1)=4...依次内推，有n阶时f(n)=2^(n-1)。
为了加快运算速度，可以通过向左移移位来完成乘以2的工作：
class Solution{
public:
    int jumpFloorII(int number) {
        //通过移位计算2的次方
        return 1<<(number-1);        
    }
};
23
小肥猴
  直接看图就知道： 
11
鲜橙C
  其实是隔板问题，假设n个台阶，有n-1个空隙，可以用0~n-1个隔板分割，c(n-1,0)+c(n-1,1)+...+c(n-1,n-1)=2^(n-1)，其中c表示组合。 
  有人用移位1<<--number，这是最快的。直接连续乘以2不会慢多少，编译器会自动优化。不过移位还是最有启发的！ 
8
老石基
public class Solution {
    public int JumpFloorII(int target) {
        if(target<=0)
            return 0;
        return 1<<(target-1);
    }
}
10
zwzwzwzwz
假设有n级的台阶，其实就是找组合数，将n分成n个0或者1(1,1,0,0,0,1)第一个必须是1,其中1表示未被前面步数包含,0表示被前面步数包含,比如如果是4步，(1,1,1,1)表示一次跳一步,(1,0,0,1)表示3,1(1,1,0,1)表示1,2,1所以组合应该为2的n-1次方
5
微风中
  数学问题, n个台阶最多有n-1个分段,  每个分段可以跳也可以不跳,所以有2的n-1次方      class Solution {      public:          int jumpFloorII(int number) {              return pow(2,number-1);          }      };   
4
加油呀哥们
class Solution {
 public:
     int jumpFloorII(int number) {
 /*        //第一种
         long int sum=0;
         if(number==0) return 1;
         else if(number==1) return 1;
         else if(number==2) return 2;
         else
         {
                for(int i=number-1; i>=0; i--)
                    sum += jumpFloorII(i);
         }
         
         return sum;
         */
         //第二种做法
         return pow(2, number-1);
     }
 };
5
霹雳萌蛋
class Solution {
public:
    int jumpFloorII(int number) {
			return pow(2,number-1);
    }
};
2
OOMError
得出规律后，直接使用2的n-1次方公式。 public class Page79 {
    public int JumpFloorII(int target) {
        if (target == 0) {
            return 0;
        } else{
            return (int) Math.pow(2,target - 1);
        }
    }
    public static void main(String[] args) {
        Page79 page79 = new Page79();
        System.out.println(page79.JumpFloorII(3));
    }
}
2
HowieLee
public class Solution {
    public int JumpFloorII(int target) {
        int sum = 1;
        while(target > 1){
            sum *= 2;
            target--;
        }
        return sum;
    }
}
 或者是使用位运算
2
山找海味
class Solution { public:     int jumpFloorII(int number) {         return 1<<(number-1);     } };
2
乐天知命
public class Solution {
    public int JumpFloorII(int target) {
        // 假设：f(n)表示：n个台阶第一次1,2,...n阶的跳法数;
        // 若第一次跳了1阶，则还剩n-1阶，
        // 假设：f(n-1)表示：n-1个台阶第一次1,2,...n-1阶的跳法数;
        // 若第一次跳了2阶，则还剩n-2阶，
        // 假设：f(n-2)表示：n-1个台阶第一次1,2,...n-2阶的跳法数;
        // ...
        // 把所以可能的情况（第一次可能跳1,2,...,n阶）加起来：
        // 可以求出：f(n) = f(n-1) + f(n-2) + ... + f(1)
        // 递归：f(n-1) = f(n-2) + ... + f(1)
        // 可以求出：f(n) = 2*f(n-1) 
        
        /*
        if (target <= 0) {
            return 0;
        } else if (target == 1) {
            return 1;
        } else {
            return 2 * JumpFloorII(target - 1);
        }
        */ 
        // 更实用的解法是：从下往上计算，避免了递归的多余计算量
        int a = 1, b = 0;
        if (target <= 0) {
            return 0;
        } else if (target == 1) {
            return 1;
        } else {
            for (int i = 2; i <= target; i++) {
                b = 2 * a;
                a = b;
            }
            return b;
        }
    }
}
