考点    

抽象建模能力

热点指数    33223
通过率    29.35%
题目    

孩子们的游戏(圆圈中最后剩下的数)


具体题目    每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0...m-1报数....这样下去....直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)
讨论    157
张佃鹏
 如果只求最后一个报数胜利者
  
查看全部
42
Blankeer
int LastRemaining_Solution(int n, int m) {
		if (m == 0 || n == 0) {
			return -1;
		}
		ArrayList<Integer> data = new ArrayList<Integer>();
		for (int i = 0; i < n; i++) {
			data.add(i);
		}
		int index = -1;
		while (data.size() > 1) {
//			System.out.println(data);
			index = (index + m) % data.size();
//			System.out.println(data.get(index));
			data.remove(index);
			index--;
		}
		return data.get(0);
	}
244
weizier
    /*
    */
    public static int findLastNumber(int n,int m){
        if(n<1||m<1) return -1;
        int[] array = new int[n];
        int i = -1,step = 0, count = n;
        while(count>0){   //跳出循环时将最后一个元素也设置为了-1
            i++;          //指向上一个被删除对象的下一个元素。
            if(i>=n) i=0;  //模拟环。
            if(array[i] == -1) continue; //跳过被删除的对象。
            step++;                     //记录已走过的。
            if(step==m) {               //找到待删除的对象。
                array[i]=-1;
                step = 0;
                count--;
            }        
        }
        return i;//返回跳出循环时的i,即最后一个被设置为-1的元素
    }
71
一神
  用Java实现的话，可以使用LinkedList，考虑删除节点的效率。模拟游戏过程即可： 
import java.util.LinkedList;
public class Solution {
    public int LastRemaining_Solution(int n, int m) {
        LinkedList<Integer> list = new LinkedList<Integer>();
        for (int i = 0; i < n; i ++) {
            list.add(i);
        }
        
        int bt = 0;
       	while (list.size() > 1) {
           	bt = (bt + m - 1) % list.size();
            list.remove(bt);
        }
        
        return list.size() == 1 ? list.get(0) : -1;
    }
}
 其实这是个约瑟夫环问题，但是绝对没必要去死记硬背数学公式，直接用链表模拟游戏过程即可。
20
PandaMaomao
public class Solution {
    public int LastRemaining_Solution(int n, int m) {
        
        if(m <= 0 || n <= 0){
			return -1;
		}
		//先构造循环链表
		ListNode head = new ListNode(0); //头结点, 值为0
		ListNode pre = head;
		ListNode temp = null;
		for(int i = 1; i < n; i++){
			temp = new ListNode(i);
			pre.next = temp;
			pre = temp;
		}
		temp.next = head;//将第n-1个结点(也就是尾结点)指向头结点
		
		ListNode temp2 = null;
		while(n != 1){
			temp2 = head;
			//先找到第m个结点的前驱
			for(int i = 1; i < m - 1; i++){
				temp2 = temp2.next;
			}
			//删除第m个结点：将第m个结点的前驱指向第m个结点后面那个结点,temp2表示第m个结点的前驱
			temp2.next = temp2.next.next;
			head = temp2.next; //更新头结点
			n--;
		}
	
		return head.value;
        
    }
}
/**
 * 结点
 */
class ListNode {
	int value;
	ListNode next = null;
	
	public ListNode(int val) {
		this.value = val;
	}
}
27
多米@璟
import java.util.ArrayList;
public class Solution {
    public  int LastRemaining_Solution(int n, int m) {    
    	if(n==0)
    		return -1;
    	ArrayList<Integer> array=new ArrayList<>();
    	for(int i=0;i<n;i++){
    		array.add(i);
    	}
    	int tempIndex=(m-1)%array.size();//用于记录最初需清除的数字索引
    	while(array.size()!=1){ 
    		//System.out.println(array.get(tempIndex));
    		array.remove(tempIndex);
    		tempIndex=(tempIndex+(m-1))%array.size();//记录当前索引
    	}
    	return array.get(0);
    }
}
13
Python
Yannyezixin
  思路一：约瑟夫环，模拟这个过程就可以得出结果 
# -*- coding:utf-8 -*-
class Solution:
    def LastRemaining_Solution(self, n, m):
        if n < 1:
            return -1
        
        con = range(n)
        
        final = -1
        start = 0
        while con:
            k = (start + m - 1) % n
            final = con.pop(k)
            n -= 1
            start = k
            
        return final
23
crazychen
public class Solution {
    public int LastRemaining_Solution(int n,int m) {
        if(n==0) return -1;
        
       int s=0;
       for(int i=2;i<=n;i++){
           s=(s+m)%i;
       }
       return s;
    }
}
10
RainDrop
  何海涛的博客上说的很清楚，链接：http://zhedahht.blog.163.com/blog/static/2541117420072250322938/ 
class Solution {
public:
    int LastRemaining_Solution(unsigned int n, unsigned int m)
    {
        if(n==0)
            return -1;
        if(n==1)
            return 0;
        else
            return (LastRemaining_Solution(n-1,m)+m)%n;
    }
}; 
8
老石基
  开车啦 
public class Solution {
    class Child{
        int index;
        Child next;
        public Child(int index){
            this.index = index;
        }
    }
    public int LastRemaining_Solution(int n, int m) {
        if(m==0)
            return -1;
        if(n==0)
            return 0;
        Child laosiji = new Child(0);
        Child kaichele = laosiji;
        for(int i = 1;i<n;i++){
            Child daidaiwo = new Child(i);
            kaichele.next = daidaiwo;
            kaichele = daidaiwo;
        }
        kaichele.next = laosiji;
        Child qingshuaka = laosiji;
        while(qingshuaka.next!=qingshuaka){
            Child dixueshengka = null;
            for(int i = 0;i<m-1;i++){
                dixueshengka = qingshuaka;
                qingshuaka = dixueshengka.next;
            } 
            qingshuaka = qingshuaka.next;
            dixueshengka.next = qingshuaka;
        }
        return qingshuaka.index;
    }
}
13
Ron
   /*约瑟夫问题，求递推公式，每轮的序列中最后出序列的数都是同一个*/
     public int LastRemaining_Solution(int n,int m) {
        if(n < 1 || m < 1)
        	return -1;
    	if(n == 1){
        	return 0;
        }
        return (LastRemaining_Solution(n-1, m)+m)%n;
    }
6
Python
GooHub
约瑟夫环问题：
方法1：使用list模拟循环链表，用cur作为指向list的下标位置。
当cur移到list末尾直接指向list头部，当删除一个数后list的长度和cur的值相等则cur指向0
class Solution:
    def LastRemaining_Solution(self, n, m):
        # write code here
        if n < 1 or m < 1:
            return
        childNum = list(range(n))
        print(childNum)
        cur = 0  # 指向list的指针
        while len(childNum) > 1:
            for i in range(1,m):
                cur += 1
                # 当指针移到list的末尾，则将指针移到list的头
                if cur == len(childNum):
                    cur = 0
            # 删除一个数，此时由于删除之后list的下标随之变化
            # cur指向的便是原数组中的下一个数字，此时cur不需要移动
            childNum.remove(childNum[cur])
            if cur == len(childNum):  # list的长度和cur的值相等则cur指向0
                cur = 0
        return childNum
方法2：找规律
使用动态规划。我们注意到，输入的序列在删除一个元素后，序列的长度会改变，如果索引
在被删除的元素位置开始计算，那么每删除一个元素，序列的长度减一而索引会完全改变。
如果能找到改变前的索引和新索引的对应关系，那么该问题就容易解决了。
我们定义一个函数f(n, m)，表示每次在n个数字0,1,2,3,…,n-1中每次删除第m个数字后剩下
的数字。那么第一个被删除的数字的索引是(m-1)%n。删除该索引元素后，剩下的n-1个数字
为0,1,2,…,k-1,k+1,…,n-1。下次删除数字是重k+1位置开始，于是可以把序列看
作k+1,..,n-1,0,1,…,k-1。该序列最后剩下的序列也是f的函数。但该函数和第一个函数
不同，存在映射关系，使用f'来表示，于是有：f(n, m)=f'(n-1, m)。接下来需要找到映射关系。
k+1 --> 0
k+2 --> 1
     .
     .
     .
n-1 --> n-k-2
0   --> n-k-1
     .
     .
     .
k-1 --> n-2
所以可以得到：right = left-k-1，则p(x) = (x-k-1)%n，而逆映射是p'(x) = (x+k+1)%n
即0~n-1序列中最后剩下的数字等于（0~n-2序列中最后剩下的数字+k）%n，很明显当n=1时，
只有一个数，那么剩下的数字就是0.问题转化为动态规划问题，关系表示为：
	f(n)=(f(n-1)+m)%n； 当n=1,f(1)=0;
	class Solution:
    def LastRemaining_Solution(self, n, m):
        # write code here
 
        if n < 1 or m < 1:
            return -1
        last = 0
        for i in range(2, n+1):
            last = (last+m)%i
        return last
 
5
BillXXX
/*
//法一：C++实现 list容器+其迭代器实现圆形链表 （约瑟夫环问题）
class Solution {
public:
    int LastRemaining_Solution(int n, int m)//n为人数
    {
        if(n<1||m<1)
            return -1;
        list<int> numbers;
        for(int i=0;i<n;i++)
            numbers.push_back(i);
        list<int>::iterator current=numbers.begin();
        while(numbers.size()>1)
        {
            for(int i=1;i<m;i++)//走m-1步到达第m个数处
            {
                ++current;
                if(current==numbers.end())
                    current=numbers.begin();
            }
            
        	list<int>::iterator next=++current;
            if(next==numbers.end())
                next=numbers.begin();
            --current;
            numbers.erase(current);
            current=next;
        }
        return *current;//对迭代器取值，等价于对指针取值
    }
};
*/
//法二：找出规律,通项为：f(n,m)={f(n-1,m)+m}%n。
class Solution 
{
public:
    int LastRemaining_Solution(int n, int m)
    {
        if(n<1||m<1)
            return -1;
        
        int last=0;
        for(int i=2;i<=n;i++)
        {
            last=(last+m)%i;
        }
        return last;
    }
}; 
4
HowieLee
public class Solution {
    public int LastRemaining_Solution(int n, int m) {
        if(n < 1 || m < 1){
            return -1;
        }
        int last = 0;
        for(int i = 2; i <= n ; i++){
            last = (last+m)%i;
        }
        return last;
    }
}
   时间复杂度：O(n）    空间复杂度：O(1) 
4
lalala、
循环队列：
class node
{
	int num;
	node next;
	node (int num)
	{
		this.num = num;
	}
	}
public class Solution {
    public int LastRemaining_Solution(int n, int m) {
    	if(n == 0) return -1;
       node head = new node(0);
       node pre = head;
       node t = null;
       for(int i = 1; i< n; i++)
       {
    	    t = new node(i);
    	   pre.next = t;
    	   pre = t;
       }
       t.next = head;
       node p =t;
       for(int i = 0; i<n-1; i++)
       {
    	   for(int j = 0; j<m-1; j++)
    	   {
    		   p = p.next;
    	   }
    	   p.next = p.next.next;
       }
       return p.num;
    }
}
3
Python
zkqiang
# 笨方法  模拟一遍
# -*- coding:utf-8 -*-
class Solution:
    def LastRemaining_Solution(self, n, m):
        # write code here
        if not n and not m:
            return -1
        nums = list(range(n))
        last = 0
        for _ in range(n-1):
            last = (m+last-1)%len(nums)
            nums.pop(last)
        return nums[0]
 
3
pandigreat
 class Solution {
public:
    int LastRemaining_Solution(unsigned int n, unsigned int m)
    {
        
        if(n <= 0 && m <= 0) return -1; //蛋疼的特殊条件
        int t = 0;
        for(int i = 2; i <= n; i++)
            t = (t + m) % i;
        return t;
    }
};
/**
约瑟夫问题
递推公式
让f[i]为i个人玩游戏报m退出最后的胜利者的编号，最后的结果自然是f[n]
服了
f[1] = 0;
f[i] = (f[i - 1] + m) mod i;
因为递推，所以可以不用保存状态
代码如下 
*/ 
5
透明猫猫
  不用去计算各种公式，直接用循环链表不断循环m次删去节点，直至链表中只剩一个节点为止。  class Solution {
public:
    struct node
    {
        int no;
        node *next;
    };
    int LastRemaining_Solution(int n, int m)
    {
        node *head=new node;
        head->no=n-1;
        head->next=NULL;
        node *tail=head;//保留最后一个位置的节点一边将链表头尾连接
        for(int i=n-2; i>=0; i--)
        {
            node *p=new node;
            p->no=i;
            p->next=head;
            head=p;
        }
        tail->next=head;
        node *pre=tail;//保存被选中的节点前一个以便删去节点后重新连接链表
        while(head->next!=head)//判断条件是链表中只剩一个节点才停下
        {
            node *tmp=head;
            for(int i=0; i<m-1; i++)
            {
                tmp=tmp->next;
                pre=pre->next;
            }
            pre->next=tmp->next;
            head=pre->next;
            delete tmp;
        }
        return pre->no;
    }
}; 
8
tenacious
说好的从1开始，为何5，3会是3而不是4，答案根本就是从0开始数的
4
虵乡遇故知
  只想到了最直接的方法——循环链表（😂  public class Solution {
    
    // 构造循环链表结构
    public static class Node {
        private int value;
        private Node pre;
        private Node next;
        
        public Node(int value) {
            this.value = value;
            this.pre = null;
            this.next = null;
        }
    }
    
    public int LastRemaining_Solution(int n, int m) {
        if (m == 0 && n == 0) {
            return -1;
        }
        Node head = new Node(0);
        Node cur = head;
        Node last = null;
        for(int i = 1; i < n; i++) {
            last = new Node(i);
            last.pre = cur;
            cur.next = last;
            cur = last;
        }
        cur = head;
        last.next = head;
        head.pre = last;
        int count = n;
        while (count != 1) {
            for (int i = 0; i < m - 1; i++) {
                cur = cur.next;
            }
            cur.pre.next = cur.next;
            cur.next.pre = cur.pre;
            cur = cur.next;
            count--;
        }
        return cur.value;
    }
}
   
4
爱上溜溜梅vincent
class Solution {
/*
参考剑指offer,纯手打
定义一个关于m 和n的方程，f(n,m),表示n个数字0,1,2，….n-1;
中每次删除第m个数字最后剩下的数字。
第一个被删除的数字（m-1）%n.
例如0,1,2,3,4,5，删除第3个，即2，那么（3-1）%6=0….2,商0余2，所以2就是那个被删除的数。
在删除第m个数字(定义为k)之后的序列为
0,1,2，…k-1,k+1,…n-1;
在进入下一次循环时删除第m个的时候从第k+1个数开始，这个序列为k+1，，，n-1,0,1,…k-1;函数因此定为f*(n-1,m)
再将这个映射我从0开始的序列，如下：
K+1 → 0；
K+2 → 1;
…
n-1 →  n-1-(k+1)=n-k-2;
0   →  n-k-2+1=n-k-1;
1   →  n-k;
…
k-1 → n-k-1+（k-1）=n-2;
映射p(x)=p(x-k-1)%n;表示映射钱的数字是x,映射后的数字是x-k-1。逆映射为
P*(x)=(x+k+1)%n.
这里记住无论循环多少次删除第m个元素最后剩下的数字是一样的。
有f*(n-1,m)=P*( f(n-1,m))=( f(n-1,m)+k+1)%n.=（f(n-1,m)+m）%n.
因为k=(m-1)%n=(m-1)
*/
public:
    int LastRemaining_Solution(int n, int m)
    {
        if(n<1||m<1)
            return -1;
        int last=0;
        for(int i=2;i<=n;i++)
            last=(last+m)%i;
        return last;
        
    }
};
