考点    

知识迁移能力

热点指数    41023
通过率    33.86%
题目    

平衡二叉树


具体题目    输入一棵二叉树，判断该二叉树是否是平衡二叉树。
讨论    180
丁满历险记
  最直接的做法，遍历每个结点，借助一个获取树深度的递归函数，根据该结点的左右子树高度差判断是否平衡，然后递归地对左右子树进行判断。   public classSolution {
    public boolean IsBalanced_Solution(TreeNode root) {
        if(root == null) {
            return true;
        }
        return Math.abs(maxDepth(root.left) - maxDepth(root.right)) <= 1 &&
            IsBalanced_Solution(root.left) && IsBalanced_Solution(root.right);
    }
     
    private int maxDepth(TreeNode root) {
        if(root == null) {
            return 0;
        }
        return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
    }
} 这种做法有很明显的问题，在判断上层结点的时候，会多次重复遍历下层结点，增加了不必要的开销。如果改为从下往上遍历，如果子树是平衡二叉树，则返回子树的高度；如果发现子树不是平衡二叉树，则直接停止遍历，这样至多只对每个结点访问一次。  public class Solution {
    public boolean IsBalanced_Solution(TreeNode root) {
        return getDepth(root) != -1;
    }
    
    private int getDepth(TreeNode root) {
        if (root == null) return 0;
        int left = getDepth(root.left);
        if (left == -1) return -1;
        int right = getDepth(root.right);
        if (right == -1) return -1;
        return Math.abs(left - right) > 1 ? -1 : 1 + Math.max(left, right);
    }
} 
99
一直奔跑的蜗牛
public class Solution {
    //后续遍历时，遍历到一个节点，其左右子树已经遍历  依次自底向上判断，每个节点只需要遍历一次
    
	private boolean isBalanced=true;
    public boolean IsBalanced_Solution(TreeNode root) {
        
        getDepth(root);
		return isBalanced;
    }
    public int getDepth(TreeNode root){
    	if(root==null)
    		return 0;
    	int left=getDepth(root.left);
    	int right=getDepth(root.right);
    	
    	if(Math.abs(left-right)>1){
    		isBalanced=false;
    	}
    	return right>left ?right+1:left+1;
    	
    }
}
38
Julius
//后续遍历二叉树，遍历过程中求子树高度，判断是否平衡
class Solution {
public:
    bool IsBalanced(TreeNode *root, int & dep){
        if(root == NULL){
            return true;
        }
        int left = 0;
        int right = 0;
        if(IsBalanced(root->left,left) && IsBalanced(root->right, right)){
            int dif = left - right;
            if(dif<-1 || dif >1)
                return false;
            dep = (left > right ? left : right) + 1;
            return true;
        }
        return false;
    }
    bool IsBalanced_Solution(TreeNode* pRoot) {
        int dep = 0;
        return IsBalanced(pRoot, dep);
    }
};
23
Aurora1
public boolean IsBalanced_Solution(TreeNode root) {
		return f(root, new Holder());
	}
	private class Holder {
		int n;
	}
	boolean f(TreeNode root, Holder h) {
		if (root == null) {
			h.n = 0;
			return true;
		}
		Holder l = new Holder(), r = new Holder();
		if (f(root.left, l) && f(root.right, r)) {
			if (l.n - r.n > 1 || r.n - l.n > 1) 
				return false;
			h.n += (l.n > r.n ? l.n : r.n) + 1;
			return true;
		}
		return false;
	}
11
chestnut7
PYTHON 方法一：自顶向下,对于每个节点，都计算一下左子树以及右子树的差的绝对值，即每个节点都判断一下。算法复杂度为O（N*2） # -*- coding:utf-8 -*-
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    def IsBalanced_Solution(self, p):
        if p is None:
            return True
        left = self.depth(p.left)
        right = self.depth(p.right)
        return abs(left - right) <=1 and self.IsBalanced_Solution(p.left) and self.IsBalanced_Solution(p.right)
    def depth(self, p):
        if p is None:
            return 0
        return 1 + max(self.depth(p.left), self.depth(p.right))
 方法二：自下往上算法复杂度O(N) # -*- coding:utf-8 -*-
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    def IsBalanced_Solution(self, p):
        return self.dfs(p) != -1
    def dfs(self, p):
        if p is None:
            return 0
        left = self.dfs(p.left)
        if left == -1:
            return -1
        right = self.dfs(p.right)
        if right == -1:
            return -1
        if abs(left - right) > 1:
            return -1
        return max(left, right) + 1
11
冒菜。
# -*- coding:utf-8 -*-
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    res = True
    def IsBalanced_Solution(self, pRoot):
        # write code here
        self.helper(pRoot)
        return self.res
        
    def helper(self,root):
        if not root:
            return 0
        if not self.res : return 1
        left = 1 + self.helper(root.left)
        right = 1 + self.helper(root.right)
        if abs(left-right)>1:
            self.res = False
        return max(left,right)
        
#不要每个节点都去求一次高度，避免重复
#语言：Python
9
guo__庆
//pos-order遍历，使用辅助数组depth来保存每一步遍历的深度，同时返回该节点是否是平衡的
public class Solution {
    public boolean IsBalanced_Solution(TreeNode root) {
        return isBalance(root,new int[1]);
    }
    public boolean isBalance(TreeNode root,int []depth){
        if(root==null){
            depth[0]=0;
            return true;
        }
        boolean left=isBalance(root.left,depth);
        int leftdepth=depth[0];
        boolean right=isBalance(root.right,depth);
        int rightdepth=depth[0];
        depth[0]=Math.max(leftdepth+1,rightdepth+1);
        if(left&&right&&Math.abs(leftdepth-rightdepth)<=1)return true;
        return false;
    }
}
18
Python
华科平凡
  python solution     如果二叉树的每个节点的左子树和右子树的深度不大于1，它就是平衡二叉树。    先写一个求深度的函数，再对每一个节点判断，看该节点的左子树的深度和右子树的深度的差是否大于1   class Solution:
    def IsBalanced_Solution(self, root):
        if not root:
            return True
        if abs(self.maxDepth(root.left) - self.maxDepth(root.right)) > 1:
            return False
        return self.IsBalanced_Solution(root.left) and self.IsBalanced_Solution(root.right)
    def maxDepth(self, root):
        if not root: return 0
        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1
7
drdr
class Solution {
public:
    bool IsBalanced_Solution(TreeNode* pRoot) {
        if(helper(pRoot) < 0) return false;
        return true;
    }
private:
    int helper(TreeNode* node){
        if(node == NULL) return 0;
		int ld = helper(node->left);
        if(ld == -1) return -1;    //若左边已经不是平衡二叉树了，那就直接返回，没必要搜索右边了 
        int rd = helper(node->right);     
		if(rd == -1 || abs(ld-rd) > 1) return -1; //-1代表：不是平衡二叉树
        return max(ld, rd)+1;
    }
};
7
Java
牛客9188239号
改编自求树高代码，平衡的子树高度正常求，不平衡的直接设为-1
public class Solution {
    public int cheat(TreeNode root){
        if(root == null)return 0;
        int left = cheat(root.left);
        int right = cheat(root.right);
        return (left >= 0 && right >= 0 && Math.abs(left-right) <= 1) ? 1 + Math.max(left,right) : -1;
    }
    public boolean IsBalanced_Solution(TreeNode root) {
         return cheat(root) >= 0;
    }
}
6
Java
江南消夏
public class Solution {
    public boolean IsBalanced_Solution(TreeNode root) {
        if (root==null) return true;
        
        int leftDepth = getDepth(root.left);
        int rightDepth = getDepth(root.right);
        if (Math.abs(leftDepth - rightDepth) > 1) return false;
        
        return (IsBalanced_Solution(root.left) && IsBalanced_Solution(root.left));
        
    }
    
    private int getDepth(TreeNode root){
        if (root==null) return 0;
        
        int leftDepth = 1 + getDepth(root.left);
        int rightDepth = 1 + getDepth(root.right);
		
        return leftDepth > rightDepth ? leftDepth : rightDepth;
    }
}
5
EricG
  根据平衡二叉树定义，任意节点左右子数高度不能相差超过1。所以我们肯定要用到求树的高度的函数，但这个函数由于也需要用到递归，而且每个节点调用一次会很浪费时间。所以我们用递归在求高度的同时判断树是否平衡，如果平衡则返回子树高度给上一层，如果不平衡则直接返回-1。最终返回值如果是-1，则树是不平衡的，如果不是-1，则树是平衡的。  public class Solution {
    public boolean IsBalanced_Solution(TreeNode root) {
        if (root == null) {
            return true;
        }
        int res = heightOrUnbalanced(root);
        if (res == - 1) {
            return false;
        }
        return true;
    }
    private int heightOrUnbalanced(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int left = heightOrUnbalanced(root.left);
        int right = heightOrUnbalanced(root.right);
        if (left == -1 || right == -1) {
            return -1;
        }
        if (Math.abs(right - left) > 1) {
            return -1;
        }
        return Math.max(left, right) + 1;
    }
}
 
8
ahac
class Solution {
public:
    int getDepth(TreeNode* t){
        if(t==NULL)
            return 0;
        int leftDepth=getDepth(t->left);
        int rightDepth=getDepth(t->right);
        return leftDepth>rightDepth?leftDepth+1:rightDepth+1;
    }
    bool IsBalanced_Solution(TreeNode* pRoot) {
		if(pRoot==NULL)
            return true;
        int leftDepth=getDepth(pRoot->left);
        int rightDepth=getDepth(pRoot->right);
        int diffDepth=leftDepth-rightDepth;
        if(diffDepth<-1 || diffDepth>1){
            return false;
        }else{
            return (IsBalanced_Solution(pRoot->left)&&IsBalanced_Solution(pRoot->right));
        }
    }
};
4
C/C++
sichengLv
class Solution {
public:
    // 左右子树深度的最大值 + 1
    int TreeDepth(TreeNode* pRoot) {
        if(!pRoot) return 0;
        int left = TreeDepth(pRoot->left);
        int right = TreeDepth(pRoot->right);
        return 1 + max(left, right);
    }
    // 平衡二叉树
    // 解法一: 判断每个结点的左右子树的深度之差不超过一
    bool IsBalanced_Solution(TreeNode* pRoot) {
        if(!pRoot) return true;
        int left = TreeDepth(pRoot->left);
        int right = TreeDepth(pRoot->right);
        if(abs(left - right) > 1) {
            return false;
        }
        // 继续判断左右子树
        return IsBalanced_Solution(pRoot->left) && IsBalanced_Solution(pRoot->right);
    }
    // 平衡二叉树
    // 解法二: 后序遍历二叉树, 同时记录每个结点的深度, 并判断每个结点是否平衡
    // 此方法中每个结点只被访问一次
    bool IsBalanced_Solution(TreeNode* pRoot) {
        int depth = 0;
        return IsBalanced_Solution(pRoot, depth);
    }
    // 后序遍历
    bool IsBalanced_Solution(TreeNode* pRoot, int &pDepth) {
        if(!pRoot) {
            pDepth = 0;
            return true;
        }
        int left, right;  // 记录左右子树的深度
        if(IsBalanced_Solution(pRoot->left, left) && IsBalanced_Solution(pRoot->right, right)) {
            if(abs(left - right) <= 1) {
                pDepth = 1 + max(left, right);
                return true;
            }
        }
        return false;
    }
    
};
 
3
微微要崛起
  class Solution { 
  public: 
     int TreeDepth(TreeNode* pRoot) 
  { 
if(pRoot==NULL) return 0; 
return
  max(1+TreeDepth(pRoot->left),1+TreeDepth(pRoot->right)); 
  } 
  bool IsBalanced_Solution(TreeNode* pRoot) 
  { 
if(pRoot==NULL) return true; 
if(abs(TreeDepth(pRoot->left)-TreeDepth(pRoot->right))>1) 
return false; 
return
  IsBalanced_Solution(pRoot->left)&&IsBalanced_Solution(pRoot->right); 
  } 
  }; 
2
Python
LSayhi
# -*- coding:utf-8 -*-
"""
深度优先遍历二叉树
    某个结点的子树不平衡或者自己不平衡则返回-1
    其他情况返回树深（从叶向上数）
    最后调用DFS函数查看返回值是否为-1，不为-1，则返回True,否则返回False
"""
class Solution:
    def IsBalanced_Solution(self, pRoot):
        #方法1： 深度优先遍历结点，结点不平衡则返回-1
        def dfs(root):
            #这是给叶子结点的
            if root is None:return 0 
            l_depth  = dfs(root.left)
            r_depth = dfs(root.right)
            #左子树不平衡，或右子树不平衡，或当前树结点不平衡 直接返回-1
            if l_depth == -1 or r_depth == -1 or abs(l_depth - r_depth)>1:
                return -1
            return 1 + max(l_depth, r_depth) # 返回当前树的深度
        
        if not pRoot:return True#鲁棒性代码
        return dfs(pRoot) != -1 # 成立说明平衡
 
2
Java
瑟瑟不想说话
public class Solution {
    public boolean IsBalanced_Solution(TreeNode root) {
            if (root == null) {
            return true;
        }
        if(Math.abs(getDeep(root.left, 0) - getDeep(root.right, 0)) > 1) {
            return false;
        }
        IsBalanced_Solution(root.right);
        IsBalanced_Solution(root.left);
        return true;
    }    
    public int getDeep(TreeNode node, int count) {
        if (node == null) {
            return count;
        }
        return Math.max(getDeep(node.left, count + 1), getDeep(node.right, count + 1));
    }
}
2
虵乡遇故知
   import java.util.Stack;
import java.util.ArrayList;
public class Solution {
    public boolean res = true;
    public boolean IsBalanced_Solution(TreeNode root) {
        if (root == null) {
            return true;
        }
        TreeNode cur = root;
        bs(cur);
        return res;
        //return Math.abs(bs(cur.left) - bs(cur.right)) <= 1 ? true : false;
    }
    
    public int bs(TreeNode node) {
        if (node == null) {
            return 0;
        }
        int left = bs(node.left);
        int right = bs(node.right);
        if (Math.abs(left - right) > 1) {
            res = false;
        }
        return right > left ? right + 1 : left + 1;
    }
}
 
2
杨云同学
class Solution:
    def IsBalanced_Solution(self, pRoot):
        return self.solution(pRoot)
    
    def getDepth(self,tree):
        if tree is None: return 0
        if not (tree.left or tree.right):return 1
        return 1 + max(self.getDepth(tree.left),self.getDepth(tree.right))
    def solution(self,tree):
        if tree is None:return True
        
        left = self.getDepth(tree.left)
        right = self.getDepth(tree.right)
        if abs(left-right) > 1:return False
        
        return  self.solution(tree.left) and  self.solution(tree.right)
 
2
ChanKeh
class Solution {
public:
    bool IsBalanced_Solution(TreeNode* pRoot) {
         if(!pRoot)
               return true;
         if(!pRoot->left&&!pRoot->right)
               return true;
         int l = getDepth(pRoot->left);
         int r = getDepth(pRoot->right);
         if(l-r>1||l-r<-1)
             return false;
        return IsBalanced_Solution(pRoot->left)&&IsBalanced_Solution(pRoot->right);
        
    }
    int getDepth(TreeNode *pRoot)
    {
        if(!pRoot)
              return 0;
        if(!pRoot->left&&!pRoot->right)
              return 1;
        int l = getDepth(pRoot->left);
        int r = getDepth(pRoot->right);
        
        return l>r?l+1:r+1;
    }
}; 
