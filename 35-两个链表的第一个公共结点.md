考点    

时间空间效率的平衡

热点指数    43844
通过率    32.18%
题目    

两个链表的第一个公共结点


具体题目    输入两个链表，找出它们的第一个公共结点。
讨论    124
lizo
/* 找出2个链表的长度，然后  
查看全部
533
selfboot
  最短的代码，不用记长度 
class Solution {
public:
    ListNode* FindFirstCommonNode( ListNode *pHead1, ListNode *pHead2) {
    	ListNode *p1 = pHead1;
        ListNode *p2 = pHead2;
        while(p1!=p2){
            p1 = (p1==NULL ? pHead2 : p1->next);
            p2 = (p2==NULL ? pHead1 : p2->next);
        }
        return p1;
    }
};
  用两个指针扫描”两个链表“，最终两个指针到达 null 或者到达公共结点。 
62
writezen
//方法一：运用HasnMap的特性
import java.util.HashMap;
public class Solution {
    public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) {
        ListNode current1 = pHead1;
        ListNode current2 = pHead2;
        HashMap<ListNode, Integer> hashMap = new HashMap<ListNode, Integer>();
        while (current1 != null) {
            hashMap.put(current1, null);
            current1 = current1.next;
        }
        while (current2 != null) {
            if (hashMap.containsKey(current2))
                return current2;
            current2 = current2.next;
        }
        return null;
    }
}
//方法2：
public ListNode FindFirstCommonNodeII(ListNode pHead1, ListNode pHead2) {
        ListNode current1 = pHead1;// 链表1
        ListNode current2 = pHead2;// 链表2
        if (pHead1 == null || pHead2 == null)
            return null;
        int length1 = getLength(current1);
        int length2 = getLength(current2);
        // 两连表的长度差
        
        // 如果链表1的长度大于链表2的长度
        if (length1 >= length2) {
            int len = length1 - length2;
            // 先遍历链表1，遍历的长度就是两链表的长度差
            while (len > 0) {
                current1 = current1.next;
                len--;
            }
        }
        // 如果链表2的长度大于链表1的长度
        else if (length1 < length2) {
            int len = length2 - length1;
            // 先遍历链表1，遍历的长度就是两链表的长度差
            while (len > 0) {
                current2 = current2.next;
                len--;
            }
        }
        //开始齐头并进，直到找到第一个公共结点
        while(current1!=current2){
            current1=current1.next;
            current2=current2.next;
        }
        return current1;
    }
    // 求指定链表的长度
    public static int getLength(ListNode pHead) {
        int length = 0;
        ListNode current = pHead;
        while (current != null) {
            length++;
            current = current.next;
        }
        return length;
    }
35
C/C++
lowbee
//原理其他方法一样，写法比较简单，同时代码有解释。
class Solution {
public:
   ListNode* FindFirstCommonNode(ListNode* pHead1, ListNode* pHead2) {
       /*
        假定 List1长度: a+n  List2 长度:b+n, 且 a<b
        那么 p1 会先到链表尾部, 这时p2 走到 a+n位置,将p1换成List2头部
        接着p2 再走b+n-(n+a) =b-a 步到链表尾部,这时p1也走到List2的b-a位置，还差a步就到可能的第一个公共节点。
        将p2 换成 List1头部，p2走a步也到可能的第一个公共节点。如果恰好p1==p2,那么p1就是第一个公共节点。  或者p1和p2一起走n步到达列表尾部，二者没有公共节点，退出循环。 同理a>=b. 
        时间复杂度O(n+a+b)
        
       */
        ListNode* p1 = pHead1;
        ListNode* p2 = pHead2;
        while(p1 != p2) {
            if(p1 != NULL) p1 = p1->next;    
            if(p2 != NULL) p2 = p2->next;
            if(p1 != p2) {                   
                if(p1 == NULL) p1 = pHead2;
                if(p2 == NULL) p2 = pHead1;
            }
        }
        return p1;
    
}
       
};
39
Boooobby
思路： 如果存在共同节点的话，那么从该节点，两个链表之后的元素都是相同的。
       也就是说两个链表从尾部往前到某个点，节点都是一样的。
       我们可以用两个栈分别来装这两条链表。一个一个比较出来的值。
       找到第一个相同的节点。
import java.util.Stack;
public class Solution {
    public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) {
 	if (pHead1 == null || pHead2 == null) {
			return null;
		}
		Stack<ListNode> stack1 = new Stack<>();
		Stack<ListNode> stack2 = new Stack<>();
		while (pHead1 != null) {
			stack1.push(pHead1);
			pHead1 = pHead1.next;
		}
		while (pHead2 != null) {
			stack2.push(pHead2);
			pHead2 = pHead2.next;
		}
		ListNode commonListNode = null;
		while (!stack1.isEmpty() && !stack2.isEmpty() && stack1.peek() == stack2.peek() ) {
			stack2.pop();
			commonListNode = stack1.pop();;
		}
		return commonListNode;
    }
}
19
萌
case通过率为0.00%
测试用例:
{1,2,3},{4,5},{6,7}
对应输出应该为:
{6,7}
你的输出为:
{}
第一个测试用例就看不懂了。 这个不输出null吗？
18
Python
三三201803290855284
有个思路，不需要存储链表的额外空间。也不需要提前知道链表的长度。看下面的链表例子：
0-1-2-3-4-5-null
a-b-4-5-null
代码的ifelse语句，对于某个指针p1来说，其实就是让它跑了连接好的的链表，长度就变成一样了。
如果有公共结点，那么指针一起走到末尾的部分，也就一定会重叠。看看下面指针的路径吧。
p1： 0-1-2-3-4-5-null(此时遇到ifelse)-a-b-4-5-null
p2:  a-b-4-5-null(此时遇到ifelse)0-1-2-3-4-5-null
因此，两个指针所要遍历的链表就长度一样了！
class Solution:
    def FindFirstCommonNode(self, pHead1, pHead2):
        p1,p2=pHead1,pHead2
        while p1!=p2:
            p1 = p1.next if p1 else pHead2
            p2 = p2.next if p2 else pHead1
        return p1
 
18
Python
Yannyezixin
  两种思路 
  思路一：两条相交的链表呈Y型。可以从两条链表尾部同时出发，最后一个相同的结点就是链表的第一个相同的结点。可以利用栈来实现。时间复杂度有O(m
  + n), 空间复杂度为O(m + n) 
# -*- coding:utf-8 -*-
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
class Solution:
    def FindFirstCommonNode(self, pHead1, pHead2):
        if not pHead1 or not pHead2:
            return None
        
        stack1 = []
        stack2 = []
        
        while pHead1:
            stack1.append(pHead1)
            pHead1 = pHead1.next
            
        while pHead2:
            stack2.append(pHead2)
            pHead2 = pHead2.next
            
        first = None
        while stack1 and stack2:
            top1 = stack1.pop()
            top2 = stack2.pop()
            if top1 is top2:
                first = top1
            else:
                break
        return first
  思路二： 
  思路一其实利用栈主要解决就是同时到达第一个结点的问题。那么从链表头出发如何同时到达第一个相同的结点呢?
  链表的长度相同就可以，其实就是走的结点数目相同。所以可以让其中长的链表先走几步，剩余的长度到短链表的长度相同。 
# -*- coding:utf-8 -*-
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
class Solution:
    def FindFirstCommonNode(self, head1, head2):
        if not head1 or not head2:
            return None
        p1, p2= head1, head2
        length1 = length2 = 0
        while p1:
            length1 += 1
            p1 = p1.next
        while p2:
            length2 += 1
            p2 = p2.next
        if length1 > length2:
            while length1 - length2:
                head1 = head1.next
                length1 -= 1
        else:
            while length2 - length1:
                head2 = head2.next
                length2 -= 1
        while head1 and head2:
            if head1 is head2:
                return head1
            head1 = head1.next
            head2 = head2.next
        return None
8
Python
恭喜你又收割一个offer！
依次将链表中的元素压入两个栈中，然后每次从两个栈中抛出一个元素，直到抛出的结点相同时返回
后面的元素都是公共的
class Solution:
    def FindFirstCommonNode(self, pHead1, pHead2):
        # write code here
        lst1 = []
        lst2 = []
        result = []
        if not pHead1 or not pHead2:
            return None
        p1 = pHead1
        p2 = pHead2
        while p1:
            lst1.append(p1)
            p1 = p1.next
        while p2:
            lst2.append(p2)
            p2 = p2.next
        while lst1 and lst2:
            node1 = lst1.pop()
            node2 = lst2.pop()
            if node1 == node2:
                result.append(node1)
        
        if result:
            node = result.pop()
            return node
8
Bine
//用map做的，时间复杂度O(nlog(n))
classSolution {
public:
    ListNode* FindFirstCommonNode( ListNode *pHead1, ListNode *pHead2) {
        map<ListNode*, int> m;
        ListNode *p = pHead1;
        while(p != NULL) {
            m[p] = 1;
            p = p->next;
        }
        p = pHead2;
        while(p != NULL) {
            if(m[p]) {
                return p;
            }
            p = p->next;
        }
        return NULL;
    }
};
7
Ctrlturtle
/*分析：两个单链表如果存在第一个公共结点，则后续结点一定都公共，
因为结点里包含next指针，如果第一个公共结点相同，则next必然相同，
所以第一个公共结点后链表合并。
	思路1：设表1长度n，表2长度m，暴力法嵌套遍历两个链表需要O(mn)的时间复杂度， 
	可以采用hash的思想将其中一个转存为哈希表结构，这样建哈希表时间O(m)， 
	而遍历链表时间O(n)，而遍历时查找哈希表的时间为O(1)，因此复杂度降为O(m+n)， 
	但需要辅助空间。（这种哈希优化的策略是种一般性的思路，谨记！） 
	*/
	class Solution {
public:
    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) {
          if(pHead1==NULL||pHead2==NULL)return NULL;
          unordered_multiset<ListNode*> hashset;
          ListNode *pNode1=pHead1,*pNode2=pHead2;
          //把链表2转存为哈希表
          while(pNode2!=NULL){
              hashset.insert(pNode2);
              pNode2=pNode2->next;
          }
          //遍历第一个链表
          while(pNode1!=NULL){
			if(hashset.find(pNode1)!=hashset.end()){
                return pNode1;
            }
            pNode1=pNode1->next;
          }
          return NULL;
    }
};
	/*
	思路2：开始遍历两遍链表获取两个表的长度，比较长度让长的一个先走差值个步长， 
	再两个一起走。（快慢指针思想，也是链表问题的一般性思路） 
*/
class Solution {
public:
    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) {
          if(pHead1==NULL||pHead2==NULL)return NULL;
          //首先遍历两个链表获取长度
          ListNode *pNode1=pHead1,*pNode2=pHead2;
          int listLength1=0,listLength2=0;
          while(pNode1!=NULL){
				++listLength1;
                pNode1=pNode1->next;
          }
          while(pNode2!=NULL){
				++listLength2;
                pNode2=pNode2->next;
          }
          //比较长度，长的先走dist步
       	  pNode1=pHead1;
          pNode2=pHead2;
          if(listLength1>listLength2){
              for(int i=0;i<listLength1-listLength2;i++){
				pNode1=pNode1->next;
              }
          }
          else if(listLength1<listLength2){
              for(int i=0;i<listLength2-listLength1;i++){
                  pNode2=pNode2->next;
              }
          }
          while(pNode1!=NULL&&pNode2!=NULL&&pNode1!=pNode2){
		  	  pNode1=pNode1->next;
              pNode2=pNode2->next;
          }
          return pNode1;
    }
};
6
牛客255613号
public class Solution {
    /**
     * 思路：如果有公共节点，1）若两个链表长度相等，那么遍历一遍后，在某个时刻，p1 == p2
     * 				     2)若两个链表长度不相等，那么短的那个链表的指针pn（也就是p1或p2）
     *					   必先为null，那么这时再另pn = 链表头节点。经过一段时间后，
     *					   则一定会出现p1 == p2。
     *		如果没有公共节点：这种情况可以看成是公共节点为null，顾不用再考虑。
     */
    public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) {
 		ListNode p1 = pHead1;
        ListNode p2 = pHead2;
        while(p1 != p2) {
           	if(p1 != null) p1 = p1.next;	//防止空指针异常
           	if(p2 != null) p2 = p2.next;
            if(p1 != p2) {					//当两个链表长度不想等
                if(p1 == null) p1 = pHead1;
                if(p2 == null) p2 = pHead2;
            }
        }
        return p1;
    }
}
4
C/C++
卷积神经网络哦
class Solution {
public:
    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) {
        int len1 = 0, len2 = 0;
        ListNode *h1 = pHead1, *h2 = pHead2;
        while(h1 != NULL) {len1++; h1 = h1->next;}
        while(h2 != NULL) {len2++; h2 = h2->next;}
        ListNode *longger = (len1 >= len2)?pHead1: pHead2;
        ListNode *shorter = (len1 >= len2)?pHead2: pHead1;
        for(int i=0; i < abs(len1-len2);i++) longger = longger->next;
        while(longger && shorter){
            if(longger == shorter) return longger;
            longger = longger->next;
            shorter = shorter->next;
        }
        return NULL;
    }
};
6
Java
Nobody_Zheng
       /**  
          @author zhengyanan  
          @date 2017/2/22 @time 16:27  
         version_2:  
          核心思路：（此题最简单代码！！！）  
               1.参考了下面的某coder的一种处理方式，还是一样的思路，不过不用求长度,具体如下：  
               2.假定 List1长度: a+n  List2 长度:b+n, 且 a<b那么 p1
      会先到链表尾部,  
               这时p2 走到 a+n位置,将p1换成List2头部接着p2 再走b+n-(n+a) =b-a
      步到链  
               表尾部,这时p1也走到List2的b-a位置，还差a步就到可能的第一个公共节点。  
               将p2 换成 List1头部，p2走a步也到可能的第一个公共节点。如果恰好p1==p2,  
               那么p1就是第一个公共节点。或者p1和p2一起走n步到达列表尾部，二者没有公共  
               节点，退出循环。 同理a>=b.  
            
          复杂度：输入链表长度为m和n，时间O(m+n)，空间O(1)。  
          运行时间：35ms  
          占用内存：503k  
       */  
    public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) {
        ListNode p1 = pHead1,p2 = pHead2;
        while (p1 != p2){
            //style-3
            p1 = (p1 != null ? p1.next:pHead2);
            p2 = (p2 != null ? p2.next:pHead1);
            //style-2
//            if (p1 == null) p1 = pHead2;
//            else            p1 = p1.next;
//            if (p2 == null) p2 = pHead1;
//            else            p2 = p2.next;
            //style-1
//            if (p1 != null) p1 = p1.next;
//            if (p2 != null) p2 = p2.next;
//            if (p1 == null && p2 != null) p1 = pHead2;
//            if (p2 == null && p1 != null) p2 = pHead1;
        }
        return p1;
    }
 /**
 @author zhengyanan
 @date 2017/2/22 @time 15:40
 version_1:
 核心思路：
 1.最简单暴力的思路，就是嵌套循环遍历，找到第一个公共节点，这种显然复杂度是O(n*n)。
不到万不得已不要用这种方式。我们可以从数据特点出发进行考虑。
 2.假设2个链表有公共节点，那么从这个公共节点起，后面的所有节点都是公共的，
类似这种效果， 1 -> 2 -> 3 -> 4 -> 5 -> 6
 ^
 9 -> 0
 所以，如果能从链表的最后一个访问，我们分别从两个链表的最后访问，找到最后一个相等
节点，即为所求。
 但事实上不能，这是个单向聊表。
 换个思路：
先求出两个链表的长度len1，len2.算差值add = |len1 - len2|，长的链表先往后遍
历add个元素，然后再跟短的比较，相等就得到结果；不相等就都往后遍历一个再进行比较。
这样就去掉了那些无意义的比较（例如上面1和9比较，完全无意义，因为后面链表的长度都
不等，1 和 9不可能是同一个节点）。
 3.把以上思路写成代码即可
 复杂度：输入链表长度为m和n，时间O(m+n)，空间O(1)。
 运行时间：33ms
 占用内存：688k
 */
    public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) {
        int length1 = 0,length2 = 0;
        ListNode p1 = pHead1,p2 = pHead2;
        for (;p1 != null;length1++)    p1 = p1.next;
        for (;p2 != null;length2++)    p2 = p2.next;
        if (length1 == 0 || length2 == 0)   return null;
        else if (length1 >= length2){
            int add = length1 - length2;
            while (add > 0){
                pHead1 = pHead1.next;
                add--;
            }
        }
        else{
            int add = length2 - length1;
            while (add > 0){
                pHead2 = pHead2.next;
                add--;
            }
        }
        while (pHead1!=pHead2){
            pHead1 = pHead1.next;
            pHead2 = pHead2.next;
        }
        return pHead1;
    }
3
Python
林创伟
直接把第一个链表丢到set里面，然后遍历第二个链表，找到第一个一样的节点，时间O（M+N） class Solution:
    def FindFirstCommonNode(self, pHead1, pHead2):
        result_set = set()
        while pHead1:
            result_set.add(pHead1)
            pHead1 = pHead1.next
        while pHead2:
            if pHead2 in result_set:
                return pHead2
            pHead2 = pHead2.next
该思路来自旁边的师姐，同样是九年义务教育，她格外优秀
3
bairumoo
 //双层for循环暴力求解，遍历找出公共结点
ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) {
        ListNode *p1 = pHead1;
        ListNode *p2 = pHead2;
        for(; p1 != NULL; p1 = p1->next)
        {
            for(p2 = pHead2; p2 != NULL; p2 = p2->next)
                if(p1 == p2)
                    return p1;
        }
        return NULL;
}
 
3
马客(Mark)
  用个set存一下。。。 
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
typedef ListNode node;
typedef node* pnode;
class Solution {
public:
    ListNode* FindFirstCommonNode(pnode p, pnode q) {
        set<pnode> s;
        while(p || q){
            if(p){
                if(s.find(p) == s.end()) s.insert(p), p = p -> next;
                else return p;
            }
            if(q){
                if(s.find(q) == s.end()) s.insert(q), q = q -> next;
                else return q;
            }
        }
        return NULL;
    }
};
4
搬一块叫CV的砖
/*首先找到两个链表的长度len1和len2，然后确定哪条为长链表哪条为短链表，之后确定长度差，长的链表先走长度差步数，这样能保证两个链表能同时走在尾。一层循环直到两条链表走到相同的结点就返回。
;*/
  class Solution { 
  public: 
      int GetListLength(ListNode *pNode) 
      { 
          if(pNode==NULL) 
              return 0; 
          int count=0; 
          while(pNode!=NULL) 
          { 
              ++count; 
              pNode = pNode->next; 
          } 
          return count; 
      } 
      ListNode* FindFirstCommonNode( ListNode *pHead1, ListNode
  *pHead2) { 
          int length1 = GetListLength(pHead1); 
          int length2 = GetListLength(pHead2); 
          int lengthDif = 0; 
          ListNode *pLongList; 
          ListNode *pShortList; 
          if(length2>length1) 
          { 
          pLongList = pHead1; 
          pShortList = pHead2; 
              lengthDif = length2-length1; 
          }     
          else 
          { 
              pLongList = pHead1; 
          pShortList = pHead2; 
              lengthDif = length1-length2; 
          } 
          for(int i=0;i<lengthDif;i++) 
          { 
              pLongList = pLongList->next; 
          } 
         
  while(pLongList!=NULL&&pShortList!=NULL&&pLongList!=pShortList) 
          { 
              pLongList = pLongList->next; 
              pShortList = pShortList->next; 
          } 
          if(pLongList==NULL||pShortList==NULL) 
              return 0; 
          else 
              return pLongList; 
      } 
  }; 
4
gaigai152
public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) {
		
		if (pHead1 == null || pHead2 == null)
			return null;
		int fNum = 0;
		int sNum = 0;
		while (pHead1 != null) {
			pHead1 = pHead1.next;
			fNum++;
		}
		while (pHead2 != null) {
			pHead2 = pHead2.next;
			sNum++;
		}
		if (fNum > sNum) {
			int k = fNum - sNum;
			for (int i = 0; i < k; i++)
				pHead1 = pHead1.next;
					} else {
			int k = sNum - fNum;
			for (int i = 0; i < k; i++)
				pHead2 = pHead2.next;
			
		}
		
		while(pHead1!=pHead2){
			pHead1=pHead1.next;
			pHead2=pHead2.next;
			
		}
		return pHead1;
	}
  测试结果是  
测试用例:
 
{1,2,3},{4,5},{6,7}
 
对应输出应该为:
 
{6,7} 
但是没看出错误啊
2
虵乡遇故知
  首先要做的是得到两个链表的长度，判断哪一个链表是较长的那个。假设较长的那个链表是list1，较短的那个链表是list2，则list1的头结点首先走（list2的长度-list1的长度）这么多步，然后list1的当前节点和list2的头结点同时往后走，如果两个链表相交，则肯定会在某一个时刻相遇，此时判断的条件就是（list1Head == list2Head ?）  /*
public class ListNode {
    int val;
    ListNode next = null;
    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) {
        ListNode tmp1 = pHead1;
        ListNode tmp2 = pHead2;
        int size1 = 0;
        int size2 = 0;
        while (tmp1 != null) {
            size1++;
            tmp1 = tmp1.next;
        }
        while (tmp2 != null) {
            size2++;
            tmp2 = tmp2.next;
        }
        tmp1 = pHead1;
        tmp2 = pHead2;
        if (size1 < size2) {
            int p = size2 - size1 - 1;
            while (p >= 0) {
                tmp2 = tmp2.next;
                p--;
            }
        } else {
                int p = size1 - size2 - 1;
                while (p >= 0) {
                    tmp1 = tmp1.next;
                    p--;
                }
            }
        while (tmp1 != tmp2 && tmp1 != null && tmp2 != null) {
            tmp1 = tmp1.next;
            tmp2 = tmp2.next;
        }
        return tmp1;
    }
}
 
2
永往直前
/*
public class ListNode {
    int val;
    ListNode next = null;
    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) {
         if (pHead1 == null || pHead2 == null) {
             return null;
         }
        int length1 = length(pHead1);
        int length2 = length(pHead2);
        if (length2 > length1) { //保证pHead1为长的链表
            ListNode temp = pHead1;
            pHead1 = pHead2;
            pHead2 = temp;
        }
        //计算出长度差
        int gap = Math.abs(length1 - length2);
        while (gap > 0) {
            pHead1 = pHead1.next;
            gap--;
        }
        while (pHead1 != pHead2) {
            pHead1 = pHead1.next;
            pHead2 = pHead2.next;
        }
        return pHead1;
    }
    //统计链表的长度
    public int length(ListNode pHead1) {
        ListNode cur = pHead1;
        int result = 0;
        while (cur != null) {
            result++;
            cur = cur.next;
        }
        return result;
    }
}
 
