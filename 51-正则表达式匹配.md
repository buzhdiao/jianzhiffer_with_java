考点    

字符串

热点指数    25746
通过率    19.86%
题目    

正则表达式匹配


具体题目    请实现一个函数用来匹配包括'.'和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（包含0次）。      在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但是与"aa.a"和"ab*a"均不匹配
讨论    287
披萨大叔
当模式中的第二个字符不是“*”时：
  1、如果字符串第一个字符和模式中的第一个字符相匹配，那么字符串和模式都后移一个字符，然后匹配剩余的。 
  2、如果
字符串第一个字符和模式中的第一个字符相不匹配，直接返回false。
而当模式中的第二个字符是“*”时：
  如果字符串第一个字符跟模式第一个字符不匹配，则模式后移2个字符，继续匹配。如果字符串第一个字符跟模式第一个字符匹配，可以有3种匹配方式： 
  1、模式后移2字符，相当于x*被忽略； 
  2、字符串后移1字符，模式后移2字符； 
  3、字符串后移1字符，模式不变，即继续匹配字符下一位，因为*可以匹配多位； 
这里需要注意的是：Java里，要时刻检验数组是否越界。
public class Solution {
    public boolean match(char[] str, char[] pattern) {
    if (str == null || pattern == null) {
        return false;
    }
    int strIndex = 0;
    int patternIndex = 0;
    return matchCore(str, strIndex, pattern, patternIndex);
}
 
public boolean matchCore(char[] str, int strIndex, char[] pattern, int patternIndex) {
    //有效性检验：str到尾，pattern到尾，匹配成功
    if (strIndex == str.length && patternIndex == pattern.length) {
        return true;
    }
    //pattern先到尾，匹配失败
    if (strIndex != str.length && patternIndex == pattern.length) {
        return false;
    }
    //模式第2个是*，且字符串第1个跟模式第1个匹配,分3种匹配模式；如不匹配，模式后移2位
    if (patternIndex + 1 < pattern.length && pattern[patternIndex + 1] == '*') {
        if ((strIndex != str.length && pattern[patternIndex] == str[strIndex]) || (pattern[patternIndex] == '.' && strIndex != str.length)) {
            return matchCore(str, strIndex, pattern, patternIndex + 2)//模式后移2，视为x*匹配0个字符
                    || matchCore(str, strIndex + 1, pattern, patternIndex + 2)//视为模式匹配1个字符
                    || matchCore(str, strIndex + 1, pattern, patternIndex);//*匹配1个，再匹配str中的下一个
        } else {
            return matchCore(str, strIndex, pattern, patternIndex + 2);
        }
    }
    //模式第2个不是*，且字符串第1个跟模式第1个匹配，则都后移1位，否则直接返回false
    if ((strIndex != str.length && pattern[patternIndex] == str[strIndex]) || (pattern[patternIndex] == '.' && strIndex != str.length)) {
        return matchCore(str, strIndex + 1, pattern, patternIndex + 1);
    }
    return false;
	}
} 
162
跪求offer养家糊口
/*
    解这题需要把题意仔细研究清楚，反正我试了好多次才明白的。
    首先，考虑特殊情况：
         1>两个字符串都为空，返回true
         2>当第一个字符串不空，而第二个字符串空了，返回false（因为这样，就无法
            匹配成功了,而如果第一个字符串空了，第二个字符串非空，还是可能匹配成
            功的，比如第二个字符串是“a*a*a*a*”,由于‘*’之前的元素可以出现0次，
            所以有可能匹配成功）
    之后就开始匹配第一个字符，这里有两种可能：匹配成功或匹配失败。但考虑到pattern
    下一个字符可能是‘*’， 这里我们分两种情况讨论：pattern下一个字符为‘*’或
    不为‘*’：
          1>pattern下一个字符不为‘*’：这种情况比较简单，直接匹配当前字符。如果
            匹配成功，继续匹配下一个；如果匹配失败，直接返回false。注意这里的
            “匹配成功”，除了两个字符相同的情况外，还有一种情况，就是pattern的
            当前字符为‘.’,同时str的当前字符不为‘\0’。
          2>pattern下一个字符为‘*’时，稍微复杂一些，因为‘*’可以代表0个或多个。
            这里把这些情况都考虑到：
               a>当‘*’匹配0个字符时，str当前字符不变，pattern当前字符后移两位，
                跳过这个‘*’符号；
               b>当‘*’匹配1个或多个时，str当前字符移向下一个，pattern当前字符
                不变。（这里匹配1个或多个可以看成一种情况，因为：当匹配一个时，
                由于str移到了下一个字符，而pattern字符不变，就回到了上边的情况a；
                当匹配多于一个字符时，相当于从str的下一个字符继续开始匹配）
    之后再写代码就很简单了。
*/
class Solution {
public:
    bool match(char* str, char* pattern)
    {
        if (*str == '\0' && *pattern == '\0')
            return true;
        if (*str != '\0' && *pattern == '\0')
            return false;
        //if the next character in pattern is not '*'
        if (*(pattern+1) != '*')
        { 
            if (*str == *pattern || (*str != '\0' && *pattern == '.'))
            	return match(str+1, pattern+1);
            else
                return false;
        }
        //if the next character is '*'
        else
        {
            if (*str == *pattern || (*str != '\0' && *pattern == '.'))
                return match(str, pattern+2) || match(str+1, pattern);
            else
                return match(str, pattern+2);
        }
    }
}; 
36
Python
zxlly要offer
# -*- coding:utf-8 -*-
'''
题目：请实现一个函数用来匹配包括'.'和'*'的正则表达式。
模式中的字符'.'表示任意一个字符（不包括空字符！），而'*'表示它前面的字符可以出现任意次（包含0次）。 
在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但是与"aa.a"和"ab*a"均不匹配
'''
class Solution:
    # s, pattern都是字符串
    def match(self, s, pattern):
        # 如果s与pattern都为空，则True
        if len(s) == 0 and len(pattern) == 0:
            return True
        # 如果s不为空，而pattern为空，则False
        elif len(s) != 0 and len(pattern) == 0:
            return False
        # 如果s为空，而pattern不为空，则需要判断
        elif len(s) == 0 and len(pattern) != 0:
            # pattern中的第二个字符为*，则pattern后移两位继续比较
            if len(pattern) > 1 and pattern[1] == '*':
                return self.match(s, pattern[2:])
            else:
                return False
        # s与pattern都不为空的情况
        else:
            # pattern的第二个字符为*的情况
            if len(pattern) > 1 and pattern[1] == '*':
                # s与pattern的第一个元素不同，则s不变，pattern后移两位，相当于pattern前两位当成空
                if s[0] != pattern[0] and pattern[0] != '.':
                    return self.match(s, pattern[2:])
                else:
                    # 如果s[0]与pattern[0]相同，且pattern[1]为*，这个时候有三种情况
                    # pattern后移2个，s不变；相当于把pattern前两位当成空，匹配后面的
                    # pattern后移2个，s后移1个；相当于pattern前两位与s[0]匹配
                    # pattern不变，s后移1个；相当于pattern前两位，与s中的多位进行匹配，因为*可以匹配多位
                    return self.match(s, pattern[2:]) or self.match(s[1:], pattern[2:]) or self.match(s[1:], pattern)
            # pattern第二个字符不为*的情况
            else:
                if s[0] == pattern[0] or pattern[0] == '.':
                    return self.match(s[1:], pattern[1:])
                else:
                    return False
 
58
搬一块叫CV的砖
/*
思路：只有当模式串和字符串同时等于\0，才可以认为两个串匹配。
在匹配中，对于每个位的匹配可以分为三种情况
1、（相应位匹配||模式串为.&&字符串不是\0）&&模式串下一位是*
2、（相应位匹配||模式串为.&&字符串不是\0）&&模式串下一位不是*
3、相应位不匹配&&（模式位不为.||字符串是\0）
对应1，最复杂。分为*取0，*取1，*>=2三种情况。
*取0对应跳过当前匹配位，继续寻找patter的下一个匹配位，str不变，pattern+2
*取1对应当前匹配位算一次成功匹配，str+1，pattern+2
*取>=2对应一次成功匹配，继续匹配字符串的下一位是否匹配，str+1，pattern不变
三者取或。即只要有一种情况能匹配成功认为字符串就是匹配成功的。
对应2，相当于一次成功匹配，str+1，pattern+1
对应3，匹配失败，直接返回false
*/
class Solution {
public:
    bool match(char* str, char* pattern)
    {
    	if(str==NULL||pattern==NULL)
        	return false;
        return matchCore(str,pattern);
    }
    bool matchCore(char* str, char* pattern)
    {
        if(*str=='\0'&&*pattern=='\0')
            return true;
        if(*str!='\0'&&*pattern=='\0')
            return false;
        if(*(pattern+1)=='*')
        {
            if(*pattern==*str||(*pattern=='.'&&*str!='\0'))
 /*
                matchCore(str,pattern+2):模式串未匹配
                matchCore(str+1,pattern):模式串已经匹配成功，尝试匹配下一个字符串
                matchCore(str+1,pat+2)：模式串已经成功匹配，并且不匹配下一个字符串内容  注意这里 matchCore(str+1,pat+2)重复考虑了（代码中已经去除），谢谢@chlq的指出 */
                return matchCore(str+1,pattern)||matchCore(str,pattern+2);
            else
                return matchCore(str,pattern+2);
        }
        if(*str==*pattern||(*pattern=='.'&&*str!='\0'))
            return matchCore(str+1,pattern+1);
        return false;
    }
};
28
Java
hustZa
  ==================================递归的2种方================================   ===========================公共代码部分====================================  public static boolean match(char[] str, char[] pattern)
    {
        if(str == null || pattern == null)
            return false;
        return match(str, 0, pattern, 0);
    }    版本1：这里是剑指offer的解题思路      /* 讨论2种：先看 * 再看 匹配      * 前提：当pattern遍历完，return取决于str是否遍历完，str恰好遍历完才返回true，再接下来讨论      *  1.若当前字符存在下一个字符，看下一个字符是否是 '*'，如果是，有2种情况      *      一：当前匹配      *      1.1match(str,i + 1,pattern,j)//跳过str      *      1.2match(str,i,pattern,j + 2)//跳过pattern      *      1.3match(str,i + 1,pattern,j + 2)//这一种可以省略，相当于 1.1 + 1.2      *      二：当前不匹配      *      match(str,i,pattern,j + 2)//跳过pattern      * 2.下一个不是 *      *     当前匹配 return match(str,i + 1,pattern,j + 1)        */  private  boolean match(char[] str, int i, char[] pattern, int j) {
       if(j == pattern.length)//pattern遍历完了
            return str.length == i;//如果str也完了，返回true，不然false
       //注意数组越界问题，一下情况都保证数组不越界
       if(j < pattern.length - 1 && pattern[j + 1] == '*') {//下一个是*
           if(str.length != i && //当前匹配
                   (str[i] == pattern[j] || pattern[j] == '.')) //匹配
               return match(str,i,pattern,j + 2)
                       || match(str,i + 1,pattern,j);
           else//当前不匹配
               return match(str,i,pattern,j + 2);
       }
       //下一个不是“*”，当前匹配
       if(str.length != i && (str[i] == pattern[j] || pattern[j] == '.'))
           return match(str,i + 1,pattern,j + 1);
        return false;
    }
   //这里是第二个思路， 反过来，先看匹配 ，再看 *     /*前提：当pattern遍历完，return取决于str是否遍历完，再接下来讨论      * 1.先看当前字符是否匹配 记录first_isMatch      * 2.再看下一个字符是否为 '*'      *      2.1当前匹配first_isMatch && match(str,i + 1,pattern,j)      *      2.2无论匹配与否match(str,i,pattern,j + 2)//跳过      * 3.不匹配*，当前字符匹配的前提下，进入到下一个循环      * else first_isMatch && match(str,i + 1,pattern,j + 1)      */  private boolean match1(char[] str, int i, char[] pattern, int j) {
        if(j == pattern.length)//pattern遍历完了
             return str.length == i;//如果str也完了，返回true，不然false
        //1.先看当前是否匹配
        boolean first_isMatch = (i != str.length) && (str[i] == pattern[j] || pattern[j] == '.'); 
        //2.再看后面是否有* pattern[j + 1] == '*'
        if(j < pattern.length - 1 && pattern[j + 1] == '*') {
            return match1(str, i, pattern, j + 2) || 
                        (first_isMatch && match1(str, i + 1, pattern, j));
        }else {
            return first_isMatch && match1(str, i + 1, pattern, j + 1);
        }
     }
  //===========================下面是动态规划的2种方法============================//    //公共部分     /*       * 有了前面的认识，我们考虑用动态规划解题，动态规划有正向的和反向的，到底怎么取呢？      * 看下前面的递归调用：match1(str, i + 1, pattern, j + 1)相当于 dp[i][j]=dp[i+1][j+1]      * 适合反向遍历，于是，我们可以初始化boolean dp[len1+1][len2+1] 其中len1=str.length,len2=pattern.length      * 初始化dp[len1][len2]=true,含义是：str=aaa 和pattern=aa* 从末尾开始匹配 "" 和 "" 一定为true      * 这个时候开始循环      * 1.外循环：因为我们要用aa*匹配aaa,以aaa为外循环,注意，从""开始匹配接下来a,aa,aaa      * for(int i = len1;i>=0;i--)         * 2.内循环：拿aa*取匹配：匹配顺序 "*" "a*" "aa*",于是      * for(int j = len2 - 1;j>=0;j--)      * 循环体内部逻辑，参考递归调用： * =============  *版本1：=============          * 先看下一个是否是“*”，再看当前是否相等      * 1.若下一个是"*",分为当前相等和当前不等      *      1.1：当前相等dp[i][j]=dp[i][j+2] || dp[i+1][j]      *      1.2：当前不等dp[i][j]=dp[i][j+2]       * 2.若不是"*",但是当前相等 d[i][j]= dp[i + 1][j + 1];      public static boolean matchDP1(char[] str, char[] pattern) {
        if(str == null || pattern == null)
            return false;
        boolean [][] dp = new boolean[str.length + 1][pattern.length + 1];
        dp[str.length][pattern.length] = true;
        //开始循环
        for (int i = str.length; i >= 0; i--) {//外循环：从空串开始匹配
           for (int j = pattern.length - 1; j >= 0; j--) {//内循环：从最后一个字符开始匹配
               if(j < pattern.length - 1 && pattern[j + 1] == '*') {
                   //1.1：当前相等
                   if(i < str.length && (str[i] == pattern[j] || pattern[j] == '.'))
                       dp[i][j] = dp[i][j + 2] || dp[i + 1][j];
                   else//1.2当前不等
                       dp[i][j] = dp[i][j + 2];
               }else {//若不是"*",看当前是否相等
                    if(i != str.length && (str[i] == pattern[j] || pattern[j] == '.')) {//当前相等
                        dp[i][j] = dp[i + 1][j + 1];
                    }
               }
            }
        }
        return dp[0][0];
    }   * ============ *版本2.===============           * 先看当前是否相等，再看下一个是否为“*”      * 1.当前相等 立一个flag：      * first_isMatch=i != str.length && (str[i] == pattern[j] || pattern[j] == '.')      * 2.下一个是“*”      *   无论当前是否相等，都可以跳过dp[i][j]=dp[i][j+2] ||      *   或者，当前相等，那么 dp[i][j] = (first_isMatch && dp[i+1][j])      *   综合得： dp[i][j] = dp[i][j+2] ||(first_isMatch && dp[i+1][j]);      * 3.return dp[0][0]遍历完成  public static boolean matchDP2(char[] str, char[] pattern) {
        if(str == null || pattern == null)
            return false;
        boolean [][] dp = new boolean[str.length + 1][pattern.length + 1];
        dp[str.length][pattern.length] = true;
        //开始循环
        for (int i = str.length; i >= 0; i--) {//外循环：从空串开始匹配
           for (int j = pattern.length - 1; j >= 0; j--) {//内循环：从最后一个字符开始匹配
               //1.当前相等 立一个flag：相当于把if判断抽取出来，简化代码first_isMatch
               boolean first_isMatch = (i != str.length) && 
                                       (str[i] == pattern[j] || pattern[j] == '.');
               //2.下一个是“*”
               if(j < pattern.length - 1 && pattern[j + 1] == '*') {
                   dp[i][j] = dp[i][j + 2] || ( first_isMatch && dp[i + 1][j]);
               }else {
                   dp[i][j] = first_isMatch && dp[i + 1][j + 1];
               }
            }
        }
        return dp[0][0];
    }
16
M00N
	public boolean match(char[] str, char[] pattern) {
		if (str == null || pattern == null) {
			return false;
		}
		int strIndex = 0;
		int patternIndex = 0;
		return matchCore(str, strIndex, pattern, patternIndex);
	}
	
	public boolean matchCore(char[] str, int strIndex, char[] pattern, int patternIndex) {
		//str到尾，pattern到尾，匹配成功
		if (strIndex == str.length && patternIndex == pattern.length) {
			return true;
		}
		//str未到尾，pattern到尾，匹配失败
		if (strIndex != str.length && patternIndex == pattern.length) {
			return false;
		}
		//str到尾，pattern未到尾(不一定匹配失败，因为a*可以匹配0个字符)
		if (strIndex == str.length && patternIndex != pattern.length) {
			//只有pattern剩下的部分类似a*b*c*的形式，才匹配成功
			if (patternIndex + 1 < pattern.length && pattern[patternIndex + 1] == '*') {
				return matchCore(str, strIndex, pattern, patternIndex + 2);
			}
			return false;
		}
		
		//str未到尾，pattern未到尾
		if (patternIndex + 1 < pattern.length && pattern[patternIndex + 1] == '*') {
			if (pattern[patternIndex] == str[strIndex] || (pattern[patternIndex] == '.' && strIndex != str.length)) {
				return matchCore(str, strIndex, pattern, patternIndex + 2)//*匹配0个，跳过
						|| matchCore(str, strIndex + 1, pattern, patternIndex + 2)//*匹配1个，跳过
						|| matchCore(str, strIndex + 1, pattern, patternIndex);//*匹配1个，再匹配str中的下一个
			} else {
				//直接跳过*（*匹配到0个）
				return matchCore(str, strIndex, pattern, patternIndex + 2);
			}
		}
		
		if (pattern[patternIndex] == str[strIndex] || (pattern[patternIndex] == '.' && strIndex != str.length)) {
			return matchCore(str, strIndex + 1, pattern, patternIndex + 1);
		}
		
		return false;
	}
29
Java
詆調壹點
动态规划
如果 pattern[j] == str[i] || pattern[j] == '.', 此时dp[i][j] = dp[i-1][j-1];
如果 pattern[j] == '*'
    分两种情况:
    1: 如果pattern[j-1] != str[i] && pattern[j-1] != '.',
    此时dp[i][j] = dp[i][j-2] //a*匹配0次
    2: 如果pattern[j-1] == str[i] || pattern[j-1] == '.'
        此时dp[i][j] = dp[i][j-2] // a*匹配0次
        或者 dp[i][j] = dp[i][j-1] // a*匹配1次
        或者 dp[i][j] = dp[i-1][j] // a*匹配多次
    
public class Solution {
    public boolean match(char[] str, char[] pattern) {
		boolean[][] dp = new boolean[str.length + 1][pattern.length + 1];
		dp[0][0] = true;
		for (int i = 1; i < dp[0].length; i ++) {
			if(pattern[i - 1] == '*') dp[0][i] = dp[0][i - 2];
		}
		for (int i = 1; i < dp.length; i ++) {
			for (int j = 1; j < dp[0].length; j ++) {
				if(pattern[j - 1] == '.' || pattern[j - 1] == str[i - 1]) dp[i][j] = dp[i - 1][j - 1];
				else if(pattern[j - 1] == '*') {
					if(pattern[j - 2] != str[i - 1] && pattern[j - 2] != '.') dp[i][j] = dp[i][j - 2];
					else dp[i][j] = dp[i][j - 1] || dp[i][j - 2] || dp[i - 1][j];
				}
			}
		}
		return dp[str.length][pattern.length];
	}
}
10
Soo
  /** 
  这样写会被打的 
  */ 
      public boolean match(char[] str, char[] pattern) 
      { 
          return  new String(str).matches(new String(pattern)); 
      } 
6
~一念执着~
/*
要分为几种情况：（状态机）
（1）当第二个字符不为‘*’时：匹配就是将字符串和模式的指针都下移一个，不匹配就直接返回false
（2）当第二个字符为'*'时：
        匹配：
                a.字符串下移一个，模式不动
                b.字符串下移一个，模式下移两个
                c.字符串不动，模式下移两个
        不匹配：字符串下移不动，模式下移两个
搞清楚这几种状态后，用递归实现即可：
*/
class Solution {
public:
    bool match(char* str, char* pattern){
        if(str[0]=='\0'&&pattern[0]=='\0')
            return true;
        else if(str[0]!='\0'&&pattern[0]=='\0')
            return false;
        if(pattern[1]!='*'){
            if(str[0]==pattern[0]||(pattern[0]=='.'&&str[0]!='\0'))
                return match(str+1,pattern+1);
            else
                return false;
        }
        else{
            if(str[0]==pattern[0]||(pattern[0]=='.'&&str[0]!='\0'))
                return match(str,pattern+2)||match(str+1,pattern)||match(str+1,pattern+2); 
            else
                return match(str,pattern+2);
        }
    }
};
15
Bine
    bool match(char* str, char* pattern)
    {
        if (pattern[0] == 0 && str[0] == 0) {
            return true;
        }
        if (pattern[0] != 0 && pattern[1] == '*') {
            if (match(str, pattern + 2)) return true;
        }
        if ((pattern[0] == '.' && str[0]) || str[0] == pattern[0]) {
            if (match(str + 1, pattern + 1)) return true;
            if (pattern[1] == '*' && match(str + 1, pattern)) {
                return true;
            }
        }
        return false;
    }
12
张佃鹏
分析：递归实现
每次分别在str 和pattern中取一个字符进行匹配，如果匹配，则匹配下一个字符，否则，返回不匹配。 
设匹配递归函数 match(str, pattern)。
如果模式匹配字符的下一个字符是‘*’: 
•如果pttern当前字符和str的当前字符匹配，：有以下三种可能情况 
（1）pttern当前字符能匹配 str 中的 0 个字符：match(str, pattern+2)
（2）pttern当前字符能匹配 str 中的 1 个字符：match(str+1, pattern+2)
（3）pttern当前字符能匹配 str 中的 多 个字符：match(str+1, pattern)
 •如果pttern当前字符和和str的当前字符不匹配 
pttern当前字符能匹配 str 中的 0 个字符：(str, pattern+2)
如果模式匹配字符的下一个字符不是‘*’，进行逐字符匹配。
对于 ‘.’ 的情况比较简单，’.’ 和一个字符匹配 match(str+1, pattern+1) 
另外需要注意的是：空字符串”” 和 “.*” 是匹配的
 bool match(char* str, char* pattern)
    {
		if(str==NULL||pattern==NULL)
			return false;
		if(*str=='\0')
		{
			if(*pattern=='\0'||*(pattern+1)=='*'&&(pattern+2)=='\0')
				return true;
			else
				return false;
		}
		if(*pattern=='\0')
			return false;
		if(*(pattern+1)=='*')
		{
			if(*pattern==*str||*pattern=='.')
			{
			return match(str,pattern+2)||match(str+1,pattern);
			}
			else
				return match(str,pattern+2);
		}
		if(*pattern==*str||*pattern=='.')
			return match(str+1,pattern+1);
		return false;
    }
5
weizier
//递归的思想
public class Solution {
    boolean match(char[] str, char[] pattern)
    {
        return isMatch(str,0,pattern,0);
    }
    public boolean isMatch(char[] str,int start1,char[] pattern,int start2){
        if(start1==str.length&&start2==pattern.length) return true;
        if(start2>=pattern.length) return false;
        
        if(start2<pattern.length-1){
            if(pattern[start2+1]=='*'){
                if((start1<str.length)&&(str[start1]==pattern[start2]||pattern[start2]=='.')){
                    return isMatch(str,start1,pattern,start2+2)||isMatch(str,start1+1,pattern,start2+2)||isMatch(str,start1+1,pattern,start2);
                }else return isMatch(str,start1,pattern,start2+2);
            }
        }
        if(start1==str.length) return false;
        if(str[start1]==pattern[start2]||pattern[start2]=='.') return isMatch(str,start1+1,pattern,start2+1);
        return false;        
    }
}
4
马客(Mark)
  看到一堆指数级的回答,,还有题目都没说 .*
  是.的意义可以重复多次还是同一个字符重复多次（也就是.*能不能匹配abcdef），虽然我猜根本没有这种数据（hehe） 
  f(a, b) 表示s[a..n]和p[b..m]的匹配结果，枚举一个可匹配的前缀进行转移，记忆化避免重复计算。O(n^2) 
class Solution {
    char *s, *p;
    int n, m;
    char f[1000][1000];	//此处本应是动态申请f[n + 1][m + 1]，为了方便简洁就算了
    char judge(int a, int b){
        if(a > n || b > m) return 0;
        if(~f[a][b]) return f[a][b];
        char &ret = f[a][b];
        if(a == n && b == m) return ret = 1;
        if(p[b + 1] != '*'){
            if(p[b] == '.' || s[a] == p[b]) return ret = judge(a + 1, b + 1);
            else return ret = 0;
        }
        else{
            for(int i = a; i <= n; ++i){
                if(judge(i, b + 2)) return ret = 1;
                if(s[i] != p[b] && p[b] != '.') return ret = 0;
            }
            return ret = 0;
        }
    }
public:
    bool match(char* str, char* pat){
        s = str, n = strlen(s);
        p = pat, m = strlen(p);
        memset(f, 0xff, sizeof f);
        return judge(0, 0);
    }
};
3
xueyuanl
//这。。。
public boolean match(char[] str, char[] pattern)
    {
        String regex = String.valueOf(pattern);
        String s = String.valueOf(str);
        return s.matches(regex);
    }
3
C/C++
吴鹏_2016
class Solution {
public:
    bool match(char* s, char* p) {
        if (!s || !p) return false;
        if (!*p) return !*s;
        if (*(p + 1) == '*')
            return match(s, p + 2) || (*s == *p || *s && *p == '.') && match(s + 1, p);
        return (*s == *p || *s && *p == '.') && match(s + 1, p + 1);
    }
};
3
Java
绝对凌度
public boolean match(char[] str, char[] pattern){
        // .* 匹配一切
        if(pattern.length == 2
                && pattern[0] == '.'
                && pattern[1] == '*') return true;
        // 两个序列入栈
        Stack<Character> ori = new Stack<>();
        Stack<Character> pat = new Stack<>();
        for (int i = 0; i < str.length; i++) {
            ori.push(str[i]);
        }
        for (int i = 0; i < pattern.length; i++) {
            pat.push(pattern[i]);
        }
        // 从尾匹配，解决*重复前一个字符的问题
        while (!ori.empty() && !pat.empty()){
            // 如果是两个不相同的字母，匹配失败
            if(Character.isLetter(pat.peek())
                    && !pat.peek().equals(ori.peek()))
                return false;
            // 两个相同的字母，匹配成功，两个栈顶各弹出已经匹配的字符
            if(Character.isLetter(pat.peek())
                    && pat.peek().equals(ori.peek())){
                ori.pop();
                pat.pop();
            }else if(pat.peek().equals('.')){ // 如果模式串是 ‘.’，直接把它替换为所需的字符入栈
                pat.pop();
                pat.push(ori.peek());
            }else{ // 模式串是 *
                pat.pop();
                if(pat.peek().equals(ori.peek())){ // *的下一个是目标字符，则重复它再重新压入*
                    pat.push(ori.peek());
                    pat.push('*');
                    ori.pop();
                }else{ // 否则从模式栈弹栈，直到找到匹配目标串的字符，或遇到.
                    while (!pat.empty()
                            && !pat.peek().equals(ori.peek())
                            && !pat.peek().equals('.')) pat.pop();
                    // 如果遇到了‘.’ 直接替换为目标字符，再重新压入*
                    if(!pat.empty() && pat.peek() == '.'){
                        pat.pop();
                        pat.push(ori.peek());
                        pat.push('*');
                    }
                }
            }
        }
        // 两栈空，则匹配成功
        if(ori.empty() && pat.empty()) return true;
        // 如果模式栈不空
        // 仅当模式栈中的*可以‘吃掉’多余的字符时匹配成功
        // 例如 aa* / aa*bb* ,而不可以是baa*
        if(ori.empty() && !pat.empty()
                && pat.peek().equals('*')){
            char c = pat.pop();
            while (!pat.empty()){
                if(c == '*'
                        || pat.peek() == '*'
                        || c == pat.peek())
                    c = pat.pop();
                else return false;
            }
            return true;
        }
        // 其他情况均不成功
        return false;
    }
2
Java
放学后我不走~
  偷鸡，投机取巧法，直接利用字符串的正则匹配  public class Solution {
    public boolean match(char[] str, char[] pattern){
          String ss = new String(str);    
      String sp = new String(pattern);   
      return ss.matches(sp);
    }
}
 
2
C/C++
jiarenyf
class Solution {
  public:
    bool match(char* s, char* p) {
      int slen = strlen(s), plen = strlen(p);
      // dp[i+1][k+1] tells if s[:i] matches p[:k] ...
      vector<vector<bool>> dp(slen+1, vector<bool>(plen+1, false));
      dp[0][0] = true;
      for(int k=0; k < plen; ++k) {
        if(p[k] == '*') {
          dp[0][k+1] = dp[0][k-1];
        }
      }
      for(int i=0; i < slen; ++i) {
        for(int k=0; k < plen; ++k) {
          if(p[k]=='.' || s[i]==p[k]) {
            dp[i+1][k+1] = dp[i][k];
          }
          else if(p[k]=='*') {
            if(p[k-1]==s[i] || p[k-1]=='.') {
              dp[i+1][k+1] = dp[i+1][k-1] || dp[i+1][k] || dp[i][k+1];
            }
            else {
              dp[i+1][k+1] = dp[i+1][k-1];
            }
          }
        }
      }
      return dp[slen][plen];
    }
};
	
 
2
Cavs
1.利用标准库
#include<regex>
class Solution {
public:
    bool match(char* str, char* pattern)
    {
    	regex reg(pattern);
        return regex_match(str,reg);
    }
};
2.动态规划
#include<regex>
class Solution {
public:
    bool match(char* str, char* pattern)
    {
        string s = str;
        string p = pattern;
    	vector<vector<char>> dp(s.size() + 1,vector<char>(p.size() + 1,-1));
        return isMatch(0,s,0,p,dp);
    }
    bool isMatch(int i, string& s, int j, string &p, vector<vector<char>> &dp)
    {
        if(dp[i][j] > -1) return dp[i][j];
        int pn = p.size(), sn = s.size();
        if(j==pn) return dp[i][j] = i==sn;
        if(j+1<pn && p[j+1]=='*') 
        {
            if(isMatch(i,s,j+2,p,dp) || 
               i<sn && (p[j] == '.' || s[i] == p[j]) && isMatch(i+1,s,j,p,dp)) 
                return dp[i][j] = 1;
        } 
        else if (i<sn && (p[j]=='.'|| s[i]==p[j]) && isMatch(i+1,s,j+1,p,dp)) 
            return dp[i][j] = 1;
        
        return dp[i][j] = 0;
    }
};
2
泡面加鸡蛋
看到那么多答案要么抄剑指offer，要么互相抄袭，我就放心了
