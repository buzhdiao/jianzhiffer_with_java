#### 题目    滑动窗口的最大值

考点    栈和队列	热点指数    28352	通过率    23.84%

#### 具体题目

   给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个：      {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}，      {2,3,[4,2,6],2,5,1}，      {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}，      {2,3,4,2,6,[2,5,1]}。

/**

 * 题目：滑动窗口的最大值
 * 思路：滑动窗口应当是队列，但为了得到滑动窗口的最大值，队列序可以从两端删除元素，因此使用双端队列。
 *     原则：
 *     对新来的元素k，将其与双端队列中的元素相比较
 *     1）前面比k小的，直接移出队列（因为不再可能成为后面滑动窗口的最大值了!）,
 *     2）前面比k大的X，比较两者下标，判断X是否已不在窗口之内，不在了，直接移出队列
 *     队列的第一个元素是滑动窗口中的最大值
 */
public class P65_滑动窗口的最大值 {
	
    public ArrayList<Integer> maxInWindows(int [] num, int size)
    {
    	ArrayList<Integer> ret = new ArrayList<>();
    	if (num == null) {
    		return ret;
    	}
    	if (num.length < size || size < 1) {
    		return ret;
    	}
    	
    	LinkedList<Integer> indexDeque = new LinkedList<>();
    	for (int i = 0; i < size - 1; i++) {
    		while (!indexDeque.isEmpty() && num[i] > num[indexDeque.getLast()]) {
    			indexDeque.removeLast();
    		}
    		indexDeque.addLast(i);
    	}
    	
    	for (int i = size - 1; i < num.length; i++) {
    		while (!indexDeque.isEmpty() && num[i] > num[indexDeque.getLast()]) {
    			indexDeque.removeLast();
    		}
    		indexDeque.addLast(i);
    		if (i - indexDeque.getFirst() + 1 > size) {
    			indexDeque.removeFirst();
    		}
    		ret.add(num[indexDeque.getFirst()]);
    	}
    	return ret;
    }
}

  我看见都用了队列，就想了一个不用队列的方法，虽然有点麻烦。。。       首先，用一个值index记录窗口最大值的位置，以及一个记录窗口最大值的max。    然后就可以用i遍历数组了，用index和i比较，小于就说明窗口最左边已经过了之前的那个最大值，于是从i向右size个单位找到最大值，并记录，不小于就说明最大值还在窗口内，由于窗口每次滑动都会向右移动一个元素，使用这个元素和max比较再记录。最后添加到ArrayList中。  import java.util.*;
public class Solution {
    public ArrayList<Integer> maxInWindows(int [] num, int size)
    {
        ArrayList<Integer> list = new ArrayList<>();
        if (num == null) {
            return list;
        }
        if (num.length < size || size < 1) {
            return list;
        }
        
        int max = 0;//记录每个窗口的最大值
        int index = -1;//这个是记录这个窗口的最大值的位置
        for(int i = 0; i <= num.length - size; i++){
            if(index < i){//当最大位置的索引小于i的时候，就说明窗口过了这个元素
                max = num[i];
                for(int j = i; j < i + size; j++){//那么就从这个元素开始向后查找这个窗口的最大值
                    if(max <= num[j]){
                        index = j;
                        max = num[j];
                    }
                }
            } else{//没过的话，就判断这个窗口的最后一个元素是否比max大。
                if(max <= num[i + size - 1]){
                    index = i + size - 1;
                    max = num[i + size - 1];
                }
                
            }
            list.add(max);
        }
        return list;
    }
}


import java.util.ArrayList;
import java.util.Deque;
import java.util.LinkedList;
import java.util.PriorityQueue;
/**
 * 滑动窗口的最大值
 * 给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。
 */
public class Solution52 {
    public static void main(String[] args) {
        Solution52 solution52 = new Solution52();
        int[] num = {2, 3, 4, 2, 6, 2, 5, 1};
        int size = 3;
        ArrayList list = solution52.maxInWindows(num, size);
        System.out.println(list);
    }
    /**
     * 最大堆方法
     * 构建一个窗口size大小的最大堆，每次从堆中取出窗口的最大值，随着窗口往右滑动，需要将堆中不属于窗口的堆顶元素删除。
     *
     * [@param num
     * @param size
     * @return](/profile/547241) */
    public ArrayList maxInWindows_2(int[] num, int size) {
        ArrayList res = new ArrayList();
        if (size > num.length || size < 1) return res;
        // 构建最大堆，即堆顶元素是堆的最大值。
        PriorityQueue heap = new PriorityQueue((o1, o2) -> o2 - o1);
        for (int i = 0; i < size; i++) heap.add(num[i]);
        res.add(heap.peek());
        for (int i = 1; i + size - 1 < num.length; i++) {
            heap.remove(num[i - 1]);
            heap.add(num[i + size - 1]);
            res.add(heap.peek());
        }
        return res;
    }
    /**
     * 双队列方法
     * 滑动窗口的最大值总是保存在队列首部，队列里面的数据总是从大到小排列。
     *
     * [@param num
     * @param size
     * @return](/profile/547241) */
    public ArrayList maxInWindows(int[] num, int size) {
        ArrayList res = new ArrayList();
        if (num == null || num.length == 0 || size == 0 || size > num.length) {
            return res;
        }
        Deque deque = new LinkedList();
        for (int i = 0; i < num.length; i++) {
            if (!deque.isEmpty()) {
                // 如果队列头元素不在滑动窗口中了，就删除头元素
                if (i >= deque.peek() + size) {
                    deque.pop();
                }
                // 如果当前数字大于队列尾，则删除队列尾，直到当前数字小于等于队列尾，或者队列空
                while (!deque.isEmpty() && num[i] >= num[deque.getLast()]) {
                    deque.removeLast();
                }
            }
            deque.offer(i); // 入队列
            // 滑动窗口经过一个滑动窗口的大小，就获取当前的最大值，也就是队列的头元素
            if (i + 1 >= size) {
                res.add(num[deque.peek()]);
            }
        }
        return res;
    }
}
